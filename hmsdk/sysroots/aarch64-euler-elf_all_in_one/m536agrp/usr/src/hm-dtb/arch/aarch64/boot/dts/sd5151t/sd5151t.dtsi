/*
 * Device Tree Include file for SD5151T
 */

/ {
	#address-cells = <2>;
	#size-cells = <2>;
	hmmicrokernel {
		model = "sd5151";
		#address-cells = <2>;
		#size-cells = <2>;
		interrupt-parent = <&gic>;
		sysproc {
			#address-cells = <2>;
			#size-cells = <2>;
			sysmgr {
				compatible = "sysproc", "sysmgr";
				/* filled by bootloader */
				reg      = <0x0 0x0 0x0 0x0>;
				vphdr    = <0x0 0x0>;
				ventry   = <0x0 0x0>;
				pvoffset = <0x0 0x0>;
				nphdrs   = <0>;
				stack_start = <0x0 0x0>;
				stack_end = <0x0 0x0>;
				canary = <0x0 0x0>;
			};
			idle {
				compatible = "sysproc", "idle";
				/* filled by bootloader */
				reg      = <0x0 0x0 0x0 0x0>;
				vphdr    = <0x0 0x0>;
				ventry   = <0x0 0x0>;
				pvoffset = <0x0 0x0>;
				nphdrs   = <0>;
				stack_start = <0x0 0x0>;
				stack_end = <0x0 0x0>;
				canary = <0x0 0x0>;
			};
			uappscpiodata {
				compatible = "sysproc", "uappscpio";
				/* filled by bootloader */
				reg      = <0x0 0x0 0x0 0x0>;
				ventry   = <0x0 0x0>;
			};
		};

		kernel {
			compatible = "kernel";
			/* filled by bootloader */
			canary = <0x0 0x0>;
		};

		bootdata {
			#address-cells = <2>;
			#size-cells = <2>;
			dtb {
				compatible = "bootdata", "dtb";
				/* filled by bootloader */
				reg = <0x0 0x0 0x0 0x0>;
			};
		};

		hm-hypervisor {
			compatible = "hm-hypervisor";
			#address-cells = <2>;
			#size-cells = <2>;

			interrupt-parent = <&gic>;
			interrupts = < 7 0x00000060 0xFFFFFFFF>,
				     <25 0x00000060 0xFFFFFFFF>,
				     <27 0x00000060 0xFFFFFFFF>;

			virtual-timer-irq = <27>;
			vgic-base-address = <0x7F 0xFF000000>;

			hmv {
				compatible = "bootdata";
				/* filled by bootloader */
				entry = <0x0 0x0>;
				reg = <0x0 0x0 0x0 0x0>;
			};

			/*
                         * deployment for physical memory
                         *
                         * +----------------+ 0xFFF00000
                         * | resv bsp himem | 1M
                         * +----------------+ 0xFFE00000
                         *         |
                         * +----------------+ 0xFF800000
                         * |     kbox       | 3968K
                         * +----------------+ 0xFF420000
                         * |     ekbox      | 128K
                         * +----------------+ 0xFF400000
                         * |     klog       | 4M
                         * +----------------+ 0xFF000000
                         * |     unused     | 4M
                         * +----------------+ 0xFEC00000
                         * |      shm       | 32M+8K+4K    -->0xFEC00000 -->0xFEC00000
                         * +----------------+ 0xFCBFD000          ^             ^
                         * |                | 1012K               |             |
                         * + third-party vm + 0xFCB00000        1024M           |
                         * | (guest mem01)  | 991M                |           1900M
                         * |                | (final: 1332M)      V             |
                         * +----------------+ 0xBEC00000   -->0xBEC00000        |
                         * |      host      | 876M                              |
                         * |  (include hpe) | (final: 567M)                     V
                         * +----------------+ 0x88000000 -->0x88000000 -->0x88000000
                         * |    lsw sdk     | 128M
                         * +----------------+ 0x80000000
                         */
			/* Mem for device-group 0 which is based on vgic */
			mem00 {
				device-group = <0>;
				normal-mem;
				uvmm-access;
				map = <0x0 0x00010000 0x0 0x04000000>;
			};

			mem01 {
				device-group = <0>;
				compatible = "udrv";
				normal-mem;
				uvmm-access;
				reg = <0x0 0xBEC00000 0x0 0x3DFFD000>;
				map = <0x0 0xC0E00000 0x0 0x3DFFD000>;
			};
			/* For gpiochip2 which only support RDONLY */
			mem02 {
				device-group = <0>;
				compatible = "udrv";
				reg = <0x0 0x1010C000 0x0 0x00001000>;
				map = <0x0 0x1010C000 0x0 0x00001000>;
			};
			/* Mem for device-group 1 which is based on gic-passthrough */
			mem10 {
				device-group = <1>;
				normal-mem;
				uvmm-access;
				map = <0x0 0x00010000 0x0 0x04000000>;
			};

			mem11 {
				device-group = <1>;
				normal-mem;
				uvmm-access;
				map = <0x0 0xD0000000 0x0 0x20000000>;
			};

			/* Map device-group<0> memory to device-group<1> */
			mem12 {
				device-group = <1>;
				normal-mem;
				uvmm-access;
				reg = <0x0 0xBEC00000 0x0 0x3DFFD000>;
				map = <0x1 0x00000000 0x0 0x3DFFD000>;
			};

			gic_vcpu_if0 {
				device-group = <0>;
				compatible = "udrv";
				reg = <0x00 0x15006000 0x0 0x0002000>;
				map = <0x7F 0xFF010000 0x0 0x0002000>;
			};

			gic_vcpu_if1 {
				device-group = <1>;
				compatible = "udrv";
				reg = <0x00 0x15006000 0x0 0x0002000>;
				map = <0x7F 0xFF010000 0x0 0x0002000>;
			};

			uart0 {
				device-group = <0>;
				compatible = "udrv";
				reg = <0x00 0x10106000 0x0 0x00001000>;
				map = <0x00 0x80300000 0x0 0x00001000>;
			};

			/*
			 * SD5151t has 3 timers, the other 2 timers are used
			 * by product drivers.
			 * Passthrough this timer to device-group 1 VM.
			 */
			timer0 {
				device-group = <1>;
				compatible = "udrv";
				reg = <0x00 0x10102000 0x0 0x00001000>;
				map = <0x7F 0xFD000000 0x0 0x00001000>;
			};

			uart1 {
				device-group = <1>;
				compatible = "udrv";
				reg = <0x00 0x10106000 0x0 0x00001000>;
				map = <0x7F 0xFE000000 0x0 0x00001000>;
			};

			shm {
				device-group = <1>;
				compatible = "shm","udrv";
				share-mem;
				vnotify_irq = <12>;
				/*
				 * GPA address, length and the segments order
				 * are consistent with hpe. Modify them carefully!
				 */
				reg = <0x0 0xFEBFE000 0x0 0x00002000>,
				      <0x0 0xFCBFE000 0x0 0x02000000>,
				      <0x0 0xFCBFD000 0x0 0x00001000>;
				map = <0x00 0x08050000 0x0 0x00002000>,
				      <0x00 0xF0000000 0x0 0x02000000>,
				      <0x00 0xF8000000 0x0 0x00001000>;
			};

			gic1 {
				compatible = "udrv";
				gic-passthrough;
				device-group = <1>;
				reg =	<0x0 0x15001000 0x0 0x1000>, /* GICD */
					<0x0 0x15002000 0x0 0x2000>; /* GICC */
				map =	<0x0 0x8000000  0x0 0x1000>, /* GICD */
					<0x0 0x8010000  0x0 0x2000>; /* GICC */
			};

			/*
			 * For a vm based on gic-passthrough mode, IRQs may be received
			 * by host while pending in gic. Currently, host will disable and
			 * drop it if it's not registered, so we need to register a handler
			 * for virtio IRQs so that host will assert it to guest again to
			 * make the device (like irq 0x61 here which is virt-console) work.
			 */
			virtio1 {
				device-group = <1>;
				compatible = "hm-hypervisor,virtio";
				no-regs;
				gic-passthrough;
				interrupt-parent = <&gic>;
				interrupts =	<37 0x000000E0 0xFFFFFFFF>, /* passthrough timer */
						<96 0x000000E0 0xFFFFFFFF>,
						<97 0x000000E0 0xFFFFFFFF>,
						<98 0x000000E0 0xFFFFFFFF>,
						<99 0x000000E0 0xFFFFFFFF>,
						<100 0x000000E0 0xFFFFFFFF>;
			};

			/*
			 * For a smp vm based on gic-passthrough mode, SGIs used by it should
			 * be different from host, and the vm must ensure 1:1 mapping for vcpus,
			 * which means vcpu0 should bind to cpu0, so that SGIs will be sent to
			 * expected cores. Here we reserve ID 8-15 for guest IPIs.
			 */
			ipi1 {
				device-group = <1>;
				compatible = "hm-hypervisor,smp-ipi";
				no-regs;
				gic-passthrough;
				interrupt-parent = <&gic>;
				interrupts =	< 8 0x00000060 0xFFFFFFFF>,
						< 9 0x00000060 0xFFFFFFFF>,
						<10 0x00000060 0xFFFFFFFF>,
						<11 0x00000060 0xFFFFFFFF>,
						<12 0x00000060 0xFFFFFFFF>, /* vnotify */
						<13 0x00000060 0xFFFFFFFF>,
						<14 0x00000060 0xFFFFFFFF>,
						<15 0x00000060 0xFFFFFFFF>;
			};
			pie {
				device-group = <1>;
				compatible = "udrv";
				reg = <0x0 0x15210000 0x0 0x10000>;
				map = <0x0 0x15210000 0x0 0x10000>;
			};
			dio {
				device-group = <1>;
				compatible = "udrv";
				reg = <0x0 0x14880000 0x0 0x1000>;
				map = <0x0 0x14880000 0x0 0x1000>;
			};
			sec {
				device-group = <1>;
				compatible = "udrv";
				reg = <0x0 0x15220000 0x0 0x1000>;
				map = <0x0 0x15220000 0x0 0x1000>;
			};
			sysctrl {
				device-group = <1>;
				compatible = "udrv";
				reg = <0x0 0x10100000 0x0 0x1000>;
				map = <0x0 0x10100000 0x0 0x1000>;
			};
		};

		gic: interrupt-controller@0x15001000{
			compatible = "arm,gic-400", "arm,gic-v2";
			#interrupt-cells = <3>;
			interrupt-controller;
			irqctrl_id = <0x10000>;

			/* enable group 0 & 1, split EOI mode */
			cpuif-config = <0x601>;

			reg =	<0x0 0x15001000 0x0 0x1000>, /* GICD */
				<0x0 0x15002000 0x0 0x2000>, /* GICC */
				<0x0 0x15004000 0x0 0x2000>, /* GICH */
				<0x0 0x15006000 0x0 0x2000>; /* GICV */
			alignment = <0x1000 0x2000 0x2000 0x2000>;
		};

		arm_generic_timer: generic_timer@0 {
			compatible = "arm,armv8-timer";
			clock-frequency = <25000000>;

			/* interrupt settings */
			interrupt-parent = <&gic>;

			/* PPI 30: Non-secure physical timer
			 * level triggered, hw_prio:0x60 */
			interrupts = <30 0x00000060 0xFFFFFFFF>;
			reg = <0x0 0x0 0x0 0x0>;
		};
	};

	/* For kernel uart driver */
	uart@10106000 {
		compatible = "snps,dw-apb-uart", "arm,dw8250,uart";
		reg = <0x0 0x10106000 0x0 0x1000>;
		alignment = <0x1000>;

		interrupt-parent = <&gic>;
		/* priority 0b0110, level-triggered, target cpu 0 */
		interrupts = <41 0x60 0x1>;
		/* enable fifo */
		fifo-enabled;
	};
	soc {
		compatible = "simple-bus";
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;

		/* For user mode uart driver */
                uart@10106000 {
			compatible = "user,snps,dw-apb-uart";
			reg = <0x0 0x10106000 0x0 0x1000>;
			alignment = <0x1000>;
			clock_frequency = <112500000>; /* 112.5MHz */
			/* kernel control input, must be set in SD5151 */
			kernel-input;
			/* enable fifo */
			fifo-enabled;
			/*
			 * Bit0 and bit1 of flow_state indicate the output and
			 * input status of the serial port, respectively, 1 is
			 * enabled, and 0 is disabled.
			 */
			flow_state = <0x3>;
			no-autoload;
		};
        };
};
