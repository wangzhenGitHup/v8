/dts-v1/;
/ { #address-cells = <2>; #size-cells = <2>; hmmicrokernel {
	compatible = "hisilicon,hi1910-evb", "hisilicon,hi1910";
	hisi,boardid = <0 9 0 2>;
	hisi,slotid = <0 0 0 0>;
	interrupt-parent = <&gic>;
	#address-cells = <2>;
	#size-cells = <2>;
	model = "EVB(EP)";

	psci {
		compatible = "arm,psci";
		method = "smc";
	};

	cpus {
		#address-cells = <1>;
		#size-cells = <0>;
		cpu0: cpu@0 {
			compatible = "arm,cortex-a55", "arm,armv8";
			device_type = "cpu";
			logic_id = <0>;
			reg = <0x81080000>;
			pmu {
				compatible = "arm,armv8-pmuv3";
				interrupt-parent = <&gic>;
				/* PPI 23: PMUIRQ, level triggered, hwprio:0x60 */
				interrupts = <23 0x00000060 0xFFFFFFFF>;
			};

		};
		cpu1: cpu@1 {
			compatible = "arm,cortex-a55", "arm,armv8";
			device_type = "cpu";
			logic_id = <1>;
			reg = <0x81080100>;
			pmu {
				compatible = "arm,armv8-pmuv3";
				interrupt-parent = <&gic>;
				/* PPI 23: PMUIRQ, level triggered, hwprio:0x60 */
				interrupts = <23 0x00000060 0xFFFFFFFF>;
			};

		};
		cpu2: cpu@2 {
			compatible = "arm,cortex-a55", "arm,armv8";
			device_type = "cpu";
			logic_id = <2>;
			reg = <0x81080200>;
			pmu {
				compatible = "arm,armv8-pmuv3";
				interrupt-parent = <&gic>;
				/* PPI 23: PMUIRQ, level triggered, hwprio:0x60 */
				interrupts = <23 0x00000060 0xFFFFFFFF>;
			};

		};
		cpu3: cpu@3 {
			compatible = "arm,cortex-a55", "arm,armv8";
			device_type = "cpu";
			logic_id = <3>;
			reg = <0x81080300>;
			pmu {
				compatible = "arm,armv8-pmuv3";
				interrupt-parent = <&gic>;
				/* PPI 23: PMUIRQ, level triggered, hwprio:0x60 */
				interrupts = <23 0x00000060 0xFFFFFFFF>;
			};

		};
	};

	memory@00000000 {
		device_type = "memory";
		reg = <0x00000000 0x07e00000 0x00000000 0x17400000>,
		      <0x00000000 0x20000000 0x00000000 0x40000000>,
		      <0x00000008 0x80000000 0x00000000 0x10000000>;
	};

	/* The reserved memory is taken from the whole system memory. */
	reserved-memory {
		compatible = "reserved-memory";
		#address-cells = <2>;
		#size-cells = <2>;
		memory@0x1fa00000 {
			id = <0x0>;
			reg = <0x0 0x1fa00000 0x0 0x400000>;
			alignment = <0x1000>;
		};
	};

	sysproc {
		#address-cells = <2>;
		#size-cells = <2>;
		sysmgr {
			compatible = "sysproc", "sysmgr";
			/* filled by bootloader */
			reg      = <0x0 0x0 0x0 0x0>;
			vphdr    = <0x0 0x0>;
			ventry   = <0x0 0x0>;
			pvoffset = <0x0 0x0>;
			nphdrs   = <0>;
			stack_start = <0x0 0x0>;
			stack_end = <0x0 0x0>;
			canary = <0x0 0x0>;
		};

		idle {
			compatible = "sysproc", "idle";
			/* filled by bootloader */
			reg      = <0x0 0x0 0x0 0x0>;
			vphdr    = <0x0 0x0>;
			ventry   = <0x0 0x0>;
			pvoffset = <0x0 0x0>;
			nphdrs   = <0>;
			stack_start = <0x0 0x0>;
			stack_end = <0x0 0x0>;
			canary = <0x0 0x0>;
		};

		rootfsdata {
			compatible = "sysproc", "rootfs";
			reg = <0x8 0x80004000 0x0 0x0FFFC000>;
			ventry = <0x0 0x0>;
			/* filled by bootloader */
			pvoffset = <0x0 0x0>;
		};

	};

	kernel {
		compatible = "kernel";
		/* filled by bootloader */
		canary = <0x0 0x0>;
	};

	bootdata {
		#address-cells = <2>;
		#size-cells = <2>;
		dtb {
			compatible = "bootdata", "dtb";
			/* filled by bootloader */
			reg = <0x0 0x0 0x0 0x0>;
		};
	};

	timer {
		compatible = "arm,armv8-timer";
		clock-frequency = <19200000>;

		/* interrupt settings */
		interrupt-parent = <&gic>;

		/* PPI 30: Non-secure physical timer
		 * level triggered, hwprio:0x60 */
		interrupts = <30 0x00000060 0xFFFFFFFF>,
			     <26 0x00000060 0xFFFFFFFF>;
	};

	hm-hypervisor {
		compatible = "hm-hypervisor";
		#address-cells = <2>;
		#size-cells = <2>;

		interrupt-parent = <&gic>;
		interrupts = < 7 0x00000060 0xFFFFFFFF>,
			     <25 0x00000060 0xFFFFFFFF>,
			     <27 0x00000060 0xFFFFFFFF>;

		virtual-timer-irq = <27>;
		vgic-base-address = <0x7F 0xFF000000>;

		hmv {
			compatible = "bootdata";
			/* filled by bootloader */
			entry = <0x0 0x0>;
			reg = <0x0 0x0 0x0 0x0>;
		};

		mem0 {
			device-group = <0>;
			compatible = "udrv";
			normal-mem;
			uvmm-access;
			reg = <0x8 0x90000000 0x0 0x08000000>,
			      <0x8 0xa0000000 0x0 0x10000000>;
			map = <0x0 0x00000000 0x0 0x08000000>,
			      <0x8 0x90000000 0x0 0x10000000>;
		};

		mem1 {
			device-group = <1>;
			compatible = "udrv";
			normal-mem;
			uvmm-access;
			reg = <0x8 0xb0000000 0x0 0x08000000>,
			      <0x8 0xc0000000 0x0 0x10000000>;
			map = <0x0 0x00000000 0x0 0x08000000>,
			      <0x8 0x90000000 0x0 0x10000000>;
		};

		uart0 {
			device-group = <0>;
			reg = <0x01 0x0CF80000 0x0 0x00010000>;
			map = <0x7F 0xFE000000 0x0 0x00010000>;
		};

		uart1 {
			device-group = <0>;
			compatible = "udrv";
			interrupt-parent = <&gic>;
			interrupts = <358 0x000000E0 0xFFFFFFFF>;
			reg = <0x01 0x30930000 0x0 0x00010000>;
			map = <0x7F 0xFE010000 0x0 0x00010000>;
		};

		uart2 {
			device-group = <1>;
			reg = <0x01 0x0CF80000 0x0 0x00010000>;
			map = <0x7F 0xFE000000 0x0 0x00010000>;
		};

		dev_debug {
			device-group = <0>;
			compatible = "udrv";
			msi-parent = <&its>;
			interrupts = <0x2ed 0x0 0xE0 0>;
			reg = <0x1 0x0CF90000 0 0x10000>;
			map = <0x0 0x09010000 0 0x10000>;
		};
	};

	/* See Documentation/dts-gic.md for interrupts and distributor_config */
	gic: interrupt-controller@109000000 {
		compatible = "arm,gic-v3";

		#address-cells = <2>;
		#size-cells = <2>;

		/* Enable group 0, Group1NS, Group1S, ARE_NS, ARE_S,
		 * Split EOI and Deactive Mode */
		distributor-config = <0x80000037>;

		#interrupt-cells = <3>;
		#redistributor-regions = <1>;
		redistributor-stride = <0x20000>;
		interrupt-controller;

		reg =	<0x1 0x09000000 0x0 0x10000>,	/* GICD */
			<0x1 0x09100000 0x0 0x800000>;	/* GICR */
		alignment = <0x100000 0x100000>;

		interrupts = <25 0x000000E0 0xFFFFFFFF>;

		/* We haven't support this */
		its: interrupt-controller@108000000 {
			compatible = "arm,gic-v3-its";
			msi-controller;
			reg = <0x1 0x08000000 0x0 0x1000000>;
			alignment = <0x100000>;
			#interrupt-cells = <4>;
		};
	};

	ipi {
		/* smp ipi */
		compatible = "arm,smp-ipi";

		interrupt-parent = <&gic>;

		/* interrupt settings:
		 * 1st cell: real hardware irq number
		 *     ARM recommendation: ID 0-7 for Non-Secure;
		 *                         ID 8-15 for Secure Interrupt
		 * 2nd cell: interrupt config
		 *     bit [27:26]: Group setting
		 *     bit [24]: Trigger Type
		 *     bit [23:8]: Reserved
		 *     bit [7:0]: Priority
		 * 3rd cell: interrupt target config
		 *     Warning: Send to all cpus by default
		 */
		interrupts =	<0 0x00000060 0xFFFFFFFF>, /* IPI_RESCHEDULE */
				<1 0x00000060 0xFFFFFFFF>; /* IPI_CALL_FUNC */
	};

	/* used to debug its driver */
	debug_dev0:dev_debug@0 {
		compatible = "arm,gic-its-debug0";
		interrupts =	<0x245 0 0xE0 0>,
				<0x245 7 0xE0 0>,
				<0x245 14 0xE0 0>,
				<0x245 23 0xE0 0>;
		msi-parent = <&its>;
	};

	smmu8:smmu_fte@102000000 {
		compatible = "arm,smmu-v3";

		#address-cells = <2>;
		#size-cells = <2>;
		reg = <0x1 0x02000000 0x0 0x20000>;
		alignment = <0x10000>;
		smmu-controller;
		interrupt-parent = <&gic>;

		interrupts = <67 0x02000060 0x00000001>,
			     <68 0x02000060 0x00000001>,
			     <69 0x02000060 0x00000001>;
		#iommu-cells = <0x1>;
		dma-coherent;
		hisilicon,broken-prefetch-cmd;
		hisilicon,broken-spi;
		#iommu-spi-base = <0x1 0x9000040>;
	};

	kev {
		compatible = "huawei,kev-trace";

		/*
		 * This is just a sample configuration. The ring buffer size is
		 * intentially set to a small value to pass the CI test which
		 * calls kev_print() to print ALL kev data in a panic test.
		 */
		memory@0 {
			type = <0x1>;
			id = <0x0>;
			ring-buffer-count = <0x4>;
			/*
			 * Only ring buffer DATA sizes. Memory head and ring
			 * buffer heads are not included.
			 * ring buffer 0: 32K
			 * ring buffer 1: 1M (perf)
			 * ring buffer 2: 256K
			 * ring buffer 3: 2M (klog)
			 */
			ring-buffer-sizes = <0x8000 0x100000 0x40000 0x200000>;
		};
		memory@1 {
			type = <0x0>;
			ring-buffer-count = <0x1>;
			/*
			 * ring buffer 4: 16K(audit)
			 */
			ring-buffer-sizes = <0x4000>;
		};
		kev_sample {
			config = <0x2>;
			enable = <0x1>;
		};
		kev_klog {
			config = <0x8>;
			enable = <0x1>;
		};
		kev_fiq {
			enable = <0x1>;
		};
		kev_audit {
			config = <0x10>;
			enable = <0x1>;
		};
	};

	hm-udrv {
		compatible = "udrv";
		reg = <0x1 0x0cf80000 0x0 0x010000>,
		      <0x1 0x10400000 0x0 0x010000>,
		      <0x1 0x100c0000 0x0 0x010000>,
		      <0x1 0x0cf00000 0x0 0x01000>,
		      <0x1 0x30920000 0x0 0x01000>,
		      <0x1 0x30070000 0x0 0x10000>,
		      <0x0 0x1fe00000 0x0 0x200000>,
		      <0x0 0x1f200000 0x0 0x800000>,
		      <0x1 0x02040000 0x0 0x010000>,
		      <0x1 0x0c000000 0x0 0x010000>;
	};

	coredump {
		coredump_force = <1>;
	};

	security {
		trusted_boot = "disabled";
	};
	};

	soc {
		compatible = "simple-bus";
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;

		uart0: uart@10cf80000 {
			compatible = "arm,pl011", "arm,pl011,uart";
			reg = <0x1 0x0cf80000 0x0 0x10000>;
			alignment = <0x1000>;

			/* kernel control input */
			kernel-input;
			/* enable fifo */
			fifo-enabled;

			clock_frequency = <200000000>; /* 200MHz */
			interrupt-parent=<&gic>;
			interrupts=<357 0x00000060 0x00000001>;
		};

		uio_test: uio_test@10cf80000 {
			compatible = "genuio";
			reg = <0x1 0x0cf80000 0x0 0x10000>;
			alignment = <0x1000>;
		};

		higmac: ethernet@110400000 {
			compatible = "hisilicon,higmac";
			reg = <0x01 0x10400000 0x0 0x10000>,
				<0x01 0x100c0000 0x0 0x10000>,
				<0x01 0x0cf00000 0x0 0x1000>;
			alignment = <0x1000>;
			interrupt-parent = <&gic>;
			interrupts = <234 0x000000E0 0x1>;
			#address-cells = <0x1>;
			#size-cells = <0x0>;
			platform-type = <0x1>;
			phy-mode = "rgmii";
			dma-coherent;
			phy-handle = <&phy0>;
			phy-id = <0x1410e80>;
			mac-where = <0x1>;
			mac-address = [00 00 00 00 00 00];
		};

		/* TODO: the timer is only for single core system. The smp system
		 * is not supported
		 * Thers is no kernel tick field here. This node is just for the
		 * user-space timer to probe.
		 */
		arm_generic_timer: generic_timer {
			compatible = "arm,armv8-generic-timer";
			clock-frequency = <19200000>;

			/* interrupt settings */
			interrupt-parent = <&gic>;

			/* PPI 30: Non-secure physical timer
			 * level triggered, only cpu0, hwprio:0x60 */
			interrupts = <30 0x00000060 0x00000001>;
		};

		peri_c_subctrl: sub_ctrl_c@10c000000 {
			compatible = "hisilicon,peri-c-subctrl", "syscon";
			reg = <0x1 0x30070000 0x0 0x10000>;
		};

		mdio@0x130920000 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "hisilicon,hns-mdio";
			reg = <1 0x30920000 0 0x1000>;
			subctrl-vbase = <&peri_c_subctrl 0x630 0xd30 0x5630 0x5d30>;
			alignment = <0x1000>;
			gpio-type = <0x1>;
			status = "ok";
			phy0: ethernet-phy@0 {
				compatible = "ethernet-phy-ieee802.3-c22";
				reg = <0x0>;
				max-speed = <1000>;
			};
		};

		pramdisk0: pramdisk@0x1f200000 {
			compatible = "udrv", "hm-pramdisk", "hm-reserved-memory";
			reg = <0x00000000 0x1f200000 0x00000000 0x0800000>;
		};

		iccshmem: iccshmem@1fe00000 {
			compatible = "hm-iccshmem";
			reg = <0x00000000 0x1fe00000 0x00000000 0x200000>;
		};

		/include/ "hi1910-aicpu-drv.dtsi"

		master0: test_master0 {
			iommus = <&smmu8 776>;
		};

		master1: test_master1 {
			iommus = <&smmu8 777>;
		};

		peri_fte: peri_fte@0x102040000 {
			compatible = "hisilicon, fte_smmu_drv";
			iommus = <&smmu8 0x7f8a>;
			alignment = <0x1000>;
		};

	};

	watchdog {
		compatible = "watchdog";
		/* reserve 35s for hguard to take over the watchdog */
		highdog-timeout = <35>;
		/* reserve 10s for subcore to be pulled up*/
		lowdog-timeout = <10>;
	};

	sbsa-gwdt {
		compatible = "arm,sbsa-gwdt";
		reg = <0x1 0x0c200000 0x0 0x20000>;
		timeout-sec = <10>;
		alignment = <0x20000>;
	};

	chosen {
		 bootargs = "";
	};
};
