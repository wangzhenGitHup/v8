/*
* Automatically generated file; DO NOT EDIT.
* Automatically generated sysif apis for fs
* Using command: ../recipe-sysroot-native/usr/bin/hm-dsl/hm-dsl sysif ../../../../../work-shared/hm-filesystems/git/fslibs/libhmsrv_fs/include/libsysif/fs/api.sysif -I ../../../../../work-shared/hm-filesystems/git/fslibs/libhmsrv_fs/include --api-dest ../image/usr/include/generated/sysif_client/fs/libsysif/fs/api.h --server-dest ../image/usr/include/generated/sysif_server/fs/libsysif/fs/server.h --legacy-mode
* Create: Mon Nov 28 09:47:53 2022
*/
#ifndef LIBSYSIF_FS_SERVER_H
#define LIBSYSIF_FS_SERVER_H
#ifndef LIBSYSIF_FS_COMMON_H
#define LIBSYSIF_FS_COMMON_H
#include <libsysif/utils_common.h>
#include <hongmeng/compiler.h>
#include <hongmeng/types.h>
#include <asm/actv_rpc.h>
#ifndef LIBSYSIF_BASE_API_COMMON_H
#define LIBSYSIF_BASE_API_COMMON_H
#include <stddef.h>
#include <stdint.h>
#include <hmkernel/capability.h>
struct sysif_reply_header {
	int32_t retval;
	uint32_t msgsz;
};

#define SYSIF_REPLY_LEN_MAX 256UL
extern void* hm_actvpool_prepare_ret(unsigned long long sender, unsigned long credential, unsigned long size);


extern struct arch_actv_local* hm_actv_current_arch_actv_local(void);


#endif
#include <fs/version.h>


#define PROCFS_PATH_NAME_MAX 256
#define SVP_NAME_MAX 32

struct procfs_ops_cb {
	char svpname[SVP_NAME_MAX];
	unsigned int read_method_id;
	unsigned int write_method_id;
	int tagid;
	uint64_t ctx;
};



#define SYSFS_PATH_NAME_MAX 256
#define SVP_NAME_MAX 32

struct sysfs_ops_cb {
	char svpname[SVP_NAME_MAX];
	unsigned int read_method_id;
	unsigned int write_method_id;
	unsigned int poll_method_id;
	int tagid;
	uint64_t ctx;
};


#include <fsnotify.h>


#include <fsnotify.h>


#include <fs_ioaccount.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/sysmacros.h>
#include <sys/types.h>
#include <unistd.h>

#define VFS_FILE_CRED_DATA_LEN 64
struct vfs_file_cred {
	char data[VFS_FILE_CRED_DATA_LEN];
};

struct sysif_getxattr_args {
	unsigned long long name;
	unsigned long long value;
	unsigned int namelen;
	unsigned int size;
};


raw_static_assert(sizeof(struct procfs_ops_cb) <= 96,
                    fscall_procfs_create_data_arg_ops_is_too_large);
raw_static_assert(sizeof(struct sysfs_ops_cb) <= 96,
                    fscall_sysfs_create_file_arg_ops_is_too_large);
raw_static_assert(sizeof(struct fsnotify_mark_pars) <= 96,
                    fscall_inotify_add_watch_internal_arg_pars_is_too_large);
raw_static_assert(sizeof(struct fsnotify_mark_pars) <= 96,
                    fscall_fanotify_mark_internal_arg_pars_is_too_large);
raw_static_assert(sizeof(uref_t) <= 96,
                    fscall_vfs_client_init_arg_uref_is_too_large);
raw_static_assert(sizeof(uref_t) <= 96,
                    fscall_vfs_bind_update_arg_uref1_is_too_large);
raw_static_assert(sizeof(uref_t) <= 96,
                    fscall_vfs_bind_update_arg_uref2_is_too_large);
raw_static_assert(sizeof(time_t) <= 96,
                    fscall_vfs_timerfd_settime_arg_it_inval_sec_is_too_large);
raw_static_assert(sizeof(time_t) <= 96,
                    fscall_vfs_timerfd_settime_arg_it_val_sec_is_too_large);
raw_static_assert(sizeof(mode_t) <= 96,
                    fscall_vfs_fchmodat_arg_mode_is_too_large);
raw_static_assert(sizeof(mode_t) <= 96,
                    fscall_vfs_fchmod_arg_mode_is_too_large);
raw_static_assert(sizeof(uid_t) <= 96,
                    fscall_vfs_fchownat_arg_uid_is_too_large);
raw_static_assert(sizeof(gid_t) <= 96,
                    fscall_vfs_fchownat_arg_gid_is_too_large);
raw_static_assert(sizeof(uid_t) <= 96,
                    fscall_vfs_fchown_arg_uid_is_too_large);
raw_static_assert(sizeof(gid_t) <= 96,
                    fscall_vfs_fchown_arg_gid_is_too_large);
raw_static_assert(sizeof(mode_t) <= 96,
                    fscall_vfs_mkdirat_arg_mode_is_too_large);
raw_static_assert(sizeof(struct sysif_getxattr_args) <= 96,
                    fscall_vfs_getxattr_arg_sga_is_too_large);
raw_static_assert(sizeof(rref_t) <= 96,
                    fscall_vfs_iommap_arg_vs_rref_is_too_large);
raw_static_assert(sizeof(uref_t) <= 96,
                    fscall_vfs_anon_register_devhost_arg_dh_ap_uref_is_too_large);
struct __actvret_fscall_procfs_create_data {
};

struct __actvret_fscall_procfs_delete_data {
};

struct __actvret_fscall_procfs_get_process_fds {
};

struct __actvret_fscall_procfs_get_fd_mode {
	mode_t mode;
};

struct __actvret_fscall_sysfs_create_file {
};

struct __actvret_fscall_sysfs_create_dir {
};

struct __actvret_fscall_sysfs_create_symlink {
};

struct __actvret_fscall_sysfs_delete {
	int tagid;
};

struct __actvret_fscall_sysfs_notify {
};

struct __actvret_fscall_clock_settime {
};

struct __actvret_fscall_clock_gettime {
};

struct __actvret_fscall_clock_getres {
};

struct __actvret_fscall_clock_adjtime {
};

struct __actvret_fscall_inotify_init1 {
};

struct __actvret_fscall_inotify_add_watch {
	int wd;
};

struct __actvret_fscall_inotify_rm_watch {
};

struct __actvret_fscall_inotify_add_watch_internal {
	unsigned int index;
	unsigned long long dev_id;
};

struct __actvret_fscall_inotify_rm_watch_internal {
};

struct __actvret_fscall_inotify_notify {
};

struct __actvret_fscall_inotify_inode_destroyed {
};

struct __actvret_fscall_fanotify_init {
};

struct __actvret_fscall_fanotify_mark {
};

struct __actvret_fscall_fanotify_mark_internal {
	unsigned int index;
	unsigned long long dev_id;
};

struct __actvret_fscall_fanotify_rm_watch_internal {
};

struct __actvret_fscall_fanotify_notify {
};

struct __actvret_fscall_fanotify_destroyed {
};

struct __actvret_fscall_fanotify_open {
	int type;
	int has_buf;
	unsigned int nread;
};

struct __actvret_fscall_endio_io_done {
};

struct __actvret_fscall_vfs_set_label {
};

struct __actvret_fscall_vfs_set_label_by_path {
};

struct __actvret_fscall_vfs_get_label {
	unsigned long long label;
};

struct __actvret_fscall_vfs_init_audit {
};

struct __actvret_fscall_vfs_add_audit_rule {
};

struct __actvret_fscall_vfs_del_audit_rule {
};

struct __actvret_fscall_vfs_match_audit_watch_file {
};

struct __actvret_fscall_vfs_match_audit_watch_dir {
};

struct __actvret_fscall_vfs_client_init {
};

struct __actvret_fscall_vfs_bind_update {
};

struct __actvret_fscall_vfs_clone {
};

struct __actvret_fscall_vfs_close {
};

struct __actvret_fscall_vfs_mount {
};

struct __actvret_fscall_vfs_clone_mount_entry {
};

struct __actvret_fscall_vfs_clone_mount_entry_from_orig_parent {
};

struct __actvret_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent {
};

struct __actvret_fscall_vfs_destroy_cloned_mount_entry {
};

struct __actvret_fscall_vfs_check_mount {
};

struct __actvret_fscall_vfs_mountpoint_del_mount {
};

struct __actvret_fscall_vfs_open {
	int type;
	int has_buf;
	unsigned int nread;
};

struct __actvret_fscall_vfs_ftruncate {
};

struct __actvret_fscall_vfs_fstat {
};

struct __actvret_fscall_vfs_stat {
};

struct __actvret_fscall_vfs_statfs {
};

struct __actvret_fscall_vfs_fstatfs {
};

struct __actvret_fscall_vfs_fsync {
};

struct __actvret_fscall_vfs_unmount {
};

struct __actvret_fscall_vfs_unmount_from_server {
};

struct __actvret_fscall_vfs_unmount_child {
};

struct __actvret_fscall_vfs_truncate {
};

struct __actvret_fscall_vfs_fs_fork {
};

struct __actvret_fscall_vfs_query_info {
	rref_t rref;
	unsigned long long filep;
	unsigned long long file_idx;
};

struct __actvret_fscall_vfs_lseek {
	long long new_pos;
};

struct __actvret_fscall_vfs_trans {
};

struct __actvret_fscall_vfs_pipe2 {
	int remote_read_fd;
	int remote_write_fd;
};

struct __actvret_fscall_vfs_tee {
};

struct __actvret_fscall_vfs_splice {
	long long spliced_bytes;
};

struct __actvret_fscall_vfs_do_splice_srvs {
	long long nwritten;
};

struct __actvret_fscall_vfs_revoke_process {
};

struct __actvret_fscall_vfs_setrlimit {
};

struct __actvret_fscall_vfs_get_ns {
	unsigned int curr_nsid;
};

struct __actvret_fscall_vfs_put_ns {
};

struct __actvret_fscall_vfs_init_eventfd {
};

struct __actvret_fscall_vfs_write_eventfd {
};

struct __actvret_fscall_vfs_timerfd_create {
};

struct __actvret_fscall_vfs_timerfd_settime {
	long long od_it_inval_sec;
	long long od_it_inval_nsec;
	long long od_it_val_sec;
	long long od_it_val_nsec;
};

struct __actvret_fscall_vfs_timerfd_gettime {
	long long cur_it_inval_sec;
	long long cur_it_inval_nsec;
	long long cur_it_val_sec;
	long long cur_it_val_nsec;
};

struct __actvret_fscall_vfs_open_exec {
	int uapp_rfd;
	int sys_rfd;
	unsigned int type;
	struct vfs_file_cred file_cred;
};

struct __actvret_fscall_vfs_close_exec {
};

struct __actvret_fscall_vfs_set_elf_file {
};

struct __actvret_fscall_vfs_ioctl {
};

struct __actvret_fscall_vfs_read {
	long long nread;
};

struct __actvret_fscall_vfs_readv {
	long long nread;
};

struct __actvret_fscall_vfs_getcwd {
};

struct __actvret_fscall_vfs_get_process_cwdrootexe {
};

struct __actvret_fscall_vfs_readdir {
};

struct __actvret_fscall_vfs_write {
	long long nwritten;
};

struct __actvret_fscall_vfs_writev {
	long long nwritten;
};

struct __actvret_fscall_vfs_sync {
};

struct __actvret_fscall_vfs_do_sync {
};

struct __actvret_fscall_vfs_utimensat {
};

struct __actvret_fscall_vfs_futimens {
};

struct __actvret_fscall_vfs_fchmodat {
};

struct __actvret_fscall_vfs_fchmod {
};

struct __actvret_fscall_vfs_drop_caches {
};

struct __actvret_fscall_vfs_do_drop_caches {
};

struct __actvret_fscall_vfs_fadvise {
};

struct __actvret_fscall_vfs_readahead {
};

struct __actvret_fscall_vfs_get_fd_path {
};

struct __actvret_fscall_vfs_sysmgr_get_fd_path {
};

struct __actvret_fscall_vfs_fcntl {
};

struct __actvret_fscall_vfs_device_mounted {
};

struct __actvret_fscall_vfs_quotactl {
};

struct __actvret_fscall_vfs_copy_file_range {
	long long ncopy;
	long long off_in;
	long long off_out;
};

struct __actvret_fscall_vfs_same_file {
};

struct __actvret_fscall_vfs_access {
};

struct __actvret_fscall_vfs_flock {
};

struct __actvret_fscall_vfs_fchownat {
};

struct __actvret_fscall_vfs_fchown {
};

struct __actvret_fscall_vfs_binderfs_mmap {
};

struct __actvret_fscall_vfs_init_signalfd {
};

struct __actvret_fscall_vfs_epoll_ctl {
};

struct __actvret_fscall_vfs_epoll_et_revents {
	unsigned int revents;
};

struct __actvret_fscall_vfs_epoll_reinit {
};

struct __actvret_fscall_vfs_signalfd_notify {
};

struct __actvret_fscall_vfs_pid_io_stats {
	struct io_account io_ac;
};

struct __actvret_fscall_vfs_fallocate {
};

struct __actvret_fscall_vfs_set_cwdroot {
};

struct __actvret_fscall_vfs_fchdir {
};

struct __actvret_fscall_vfs_disable_cwdroot {
};

struct __actvret_fscall_vfs_update_cwdroot {
};

struct __actvret_fscall_vfs_handle_global_locks {
	unsigned long long lock_id;
};

struct __actvret_fscall_vfs_send_fd {
};

struct __actvret_fscall_vfs_recv_fd {
	int type;
};

struct __actvret_fscall_vfs_get_buffer_wrapper {
	unsigned long long vaddr_start;
	unsigned long long vaddr_end;
	unsigned long long data_size;
	unsigned long long offsets_buffer_size;
};

struct __actvret_fscall_vfs_get_pathname_by_me_idx {
};

struct __actvret_fscall_vfs_sfile_put {
};

struct __actvret_fscall_vfs_readlinkat {
	int retry;
};

struct __actvret_fscall_vfs_get_slabinfo {
};

struct __actvret_fscall_vfs_do_get_slabinfo {
};

struct __actvret_fscall_vfs_fscache_print_info {
};

struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device {
	unsigned int fs_handle;
};

struct __actvret_fscall_vfs_free_fs_handle_for_same_device {
};

struct __actvret_fscall_vfs_memfd_create {
};

struct __actvret_fscall_vfs_mknod {
};

struct __actvret_fscall_vfs_rename {
};

struct __actvret_fscall_vfs_mkdirat {
};

struct __actvret_fscall_vfs_link {
};

struct __actvret_fscall_vfs_unlink {
};

struct __actvret_fscall_vfs_symlink {
};

struct __actvret_fscall_vfs_getxattr {
	long long nbyte;
};

struct __actvret_fscall_vfs_fgetxattr {
	long long nbyte;
};

struct __actvret_fscall_vfs_setxattr {
};

struct __actvret_fscall_vfs_fsetxattr {
};

struct __actvret_fscall_vfs_listxattr {
	long long nbyte;
};

struct __actvret_fscall_vfs_flistxattr {
	long long nbyte;
};

struct __actvret_fscall_vfs_removexattr {
};

struct __actvret_fscall_vfs_fremovexattr {
};

struct __actvret_fscall_vfs_iommap {
	unsigned long long rvaddr;
};

struct __actvret_fscall_vfs_mmap_create {
	unsigned int index;
	unsigned long long dev_id;
	int fid;
	unsigned int pagesize;
	unsigned long long magic;
};

struct __actvret_fscall_vfs_mmap_release_file {
};

struct __actvret_fscall_vfs_mmap_change {
};

struct __actvret_fscall_vfs_mmap_fill_page {
	unsigned long long vaddr;
};

struct __actvret_fscall_vfs_mmap_fetch_page {
	unsigned long long vaddr;
};

struct __actvret_fscall_vfs_mmap_change_page {
};

struct __actvret_fscall_vfs_mmap_fallocate {
};

struct __actvret_fscall_vfs_gfd_table_update {
};

struct __actvret_fscall_vfs_gfd_table_remove {
};

struct __actvret_fscall_vfs_gfd_table_expand {
};

struct __actvret_fscall_vfs_gfd_table_acquire {
};

struct __actvret_fscall_vfs_gfd_table_release {
};

struct __actvret_fscall_vfs_gfd_table_replace {
};

struct __actvret_fscall_vfs_gfd_table_fault {
};

struct __actvret_fscall_vfs_anon_register_devhost {
};

struct __actvret_fscall_vfs_get_unused_fd {
};

struct __actvret_fscall_vfs_put_unused_fd {
};

struct __actvret_fscall_vfs_fd_info_update {
};

struct __actvret_fscall_vfs_get_root_path {
};

struct __actvret_fscall_vfs_transfs_fget {
	unsigned int sb_index;
	unsigned int f_index;
	unsigned long long hm_filp;
	unsigned int me_index;
};

struct __actvret_fscall_vfs_do_trans_fget {
	unsigned int sb_index;
	unsigned int f_index;
	unsigned long long hm_filp;
};

struct __actvret_fscall_vfs_transfs_fput {
};

struct __actvret_fscall_vfs_do_trans_fput {
};

struct __actvret_fscall_vfs_read_mounts {
	size_t offset;
};

union __actvret_fscall {
	struct __actvret_fscall_procfs_create_data procfs_create_data;
	struct __actvret_fscall_procfs_delete_data procfs_delete_data;
	struct __actvret_fscall_procfs_get_process_fds procfs_get_process_fds;
	struct __actvret_fscall_procfs_get_fd_mode procfs_get_fd_mode;
	struct __actvret_fscall_sysfs_create_file sysfs_create_file;
	struct __actvret_fscall_sysfs_create_dir sysfs_create_dir;
	struct __actvret_fscall_sysfs_create_symlink sysfs_create_symlink;
	struct __actvret_fscall_sysfs_delete sysfs_delete;
	struct __actvret_fscall_sysfs_notify sysfs_notify;
	struct __actvret_fscall_clock_settime clock_settime;
	struct __actvret_fscall_clock_gettime clock_gettime;
	struct __actvret_fscall_clock_getres clock_getres;
	struct __actvret_fscall_clock_adjtime clock_adjtime;
	struct __actvret_fscall_inotify_init1 inotify_init1;
	struct __actvret_fscall_inotify_add_watch inotify_add_watch;
	struct __actvret_fscall_inotify_rm_watch inotify_rm_watch;
	struct __actvret_fscall_inotify_add_watch_internal inotify_add_watch_internal;
	struct __actvret_fscall_inotify_rm_watch_internal inotify_rm_watch_internal;
	struct __actvret_fscall_inotify_notify inotify_notify;
	struct __actvret_fscall_inotify_inode_destroyed inotify_inode_destroyed;
	struct __actvret_fscall_fanotify_init fanotify_init;
	struct __actvret_fscall_fanotify_mark fanotify_mark;
	struct __actvret_fscall_fanotify_mark_internal fanotify_mark_internal;
	struct __actvret_fscall_fanotify_rm_watch_internal fanotify_rm_watch_internal;
	struct __actvret_fscall_fanotify_notify fanotify_notify;
	struct __actvret_fscall_fanotify_destroyed fanotify_destroyed;
	struct __actvret_fscall_fanotify_open fanotify_open;
	struct __actvret_fscall_endio_io_done endio_io_done;
	struct __actvret_fscall_vfs_set_label vfs_set_label;
	struct __actvret_fscall_vfs_set_label_by_path vfs_set_label_by_path;
	struct __actvret_fscall_vfs_get_label vfs_get_label;
	struct __actvret_fscall_vfs_init_audit vfs_init_audit;
	struct __actvret_fscall_vfs_add_audit_rule vfs_add_audit_rule;
	struct __actvret_fscall_vfs_del_audit_rule vfs_del_audit_rule;
	struct __actvret_fscall_vfs_match_audit_watch_file vfs_match_audit_watch_file;
	struct __actvret_fscall_vfs_match_audit_watch_dir vfs_match_audit_watch_dir;
	struct __actvret_fscall_vfs_client_init vfs_client_init;
	struct __actvret_fscall_vfs_bind_update vfs_bind_update;
	struct __actvret_fscall_vfs_clone vfs_clone;
	struct __actvret_fscall_vfs_close vfs_close;
	struct __actvret_fscall_vfs_mount vfs_mount;
	struct __actvret_fscall_vfs_clone_mount_entry vfs_clone_mount_entry;
	struct __actvret_fscall_vfs_clone_mount_entry_from_orig_parent vfs_clone_mount_entry_from_orig_parent;
	struct __actvret_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent vfs_destroy_cloned_mount_entry_from_orig_parent;
	struct __actvret_fscall_vfs_destroy_cloned_mount_entry vfs_destroy_cloned_mount_entry;
	struct __actvret_fscall_vfs_check_mount vfs_check_mount;
	struct __actvret_fscall_vfs_mountpoint_del_mount vfs_mountpoint_del_mount;
	struct __actvret_fscall_vfs_open vfs_open;
	struct __actvret_fscall_vfs_ftruncate vfs_ftruncate;
	struct __actvret_fscall_vfs_fstat vfs_fstat;
	struct __actvret_fscall_vfs_stat vfs_stat;
	struct __actvret_fscall_vfs_statfs vfs_statfs;
	struct __actvret_fscall_vfs_fstatfs vfs_fstatfs;
	struct __actvret_fscall_vfs_fsync vfs_fsync;
	struct __actvret_fscall_vfs_unmount vfs_unmount;
	struct __actvret_fscall_vfs_unmount_from_server vfs_unmount_from_server;
	struct __actvret_fscall_vfs_unmount_child vfs_unmount_child;
	struct __actvret_fscall_vfs_truncate vfs_truncate;
	struct __actvret_fscall_vfs_fs_fork vfs_fs_fork;
	struct __actvret_fscall_vfs_query_info vfs_query_info;
	struct __actvret_fscall_vfs_lseek vfs_lseek;
	struct __actvret_fscall_vfs_trans vfs_trans;
	struct __actvret_fscall_vfs_pipe2 vfs_pipe2;
	struct __actvret_fscall_vfs_tee vfs_tee;
	struct __actvret_fscall_vfs_splice vfs_splice;
	struct __actvret_fscall_vfs_do_splice_srvs vfs_do_splice_srvs;
	struct __actvret_fscall_vfs_revoke_process vfs_revoke_process;
	struct __actvret_fscall_vfs_setrlimit vfs_setrlimit;
	struct __actvret_fscall_vfs_get_ns vfs_get_ns;
	struct __actvret_fscall_vfs_put_ns vfs_put_ns;
	struct __actvret_fscall_vfs_init_eventfd vfs_init_eventfd;
	struct __actvret_fscall_vfs_write_eventfd vfs_write_eventfd;
	struct __actvret_fscall_vfs_timerfd_create vfs_timerfd_create;
	struct __actvret_fscall_vfs_timerfd_settime vfs_timerfd_settime;
	struct __actvret_fscall_vfs_timerfd_gettime vfs_timerfd_gettime;
	struct __actvret_fscall_vfs_open_exec vfs_open_exec;
	struct __actvret_fscall_vfs_close_exec vfs_close_exec;
	struct __actvret_fscall_vfs_set_elf_file vfs_set_elf_file;
	struct __actvret_fscall_vfs_ioctl vfs_ioctl;
	struct __actvret_fscall_vfs_read vfs_read;
	struct __actvret_fscall_vfs_readv vfs_readv;
	struct __actvret_fscall_vfs_getcwd vfs_getcwd;
	struct __actvret_fscall_vfs_get_process_cwdrootexe vfs_get_process_cwdrootexe;
	struct __actvret_fscall_vfs_readdir vfs_readdir;
	struct __actvret_fscall_vfs_write vfs_write;
	struct __actvret_fscall_vfs_writev vfs_writev;
	struct __actvret_fscall_vfs_sync vfs_sync;
	struct __actvret_fscall_vfs_do_sync vfs_do_sync;
	struct __actvret_fscall_vfs_utimensat vfs_utimensat;
	struct __actvret_fscall_vfs_futimens vfs_futimens;
	struct __actvret_fscall_vfs_fchmodat vfs_fchmodat;
	struct __actvret_fscall_vfs_fchmod vfs_fchmod;
	struct __actvret_fscall_vfs_drop_caches vfs_drop_caches;
	struct __actvret_fscall_vfs_do_drop_caches vfs_do_drop_caches;
	struct __actvret_fscall_vfs_fadvise vfs_fadvise;
	struct __actvret_fscall_vfs_readahead vfs_readahead;
	struct __actvret_fscall_vfs_get_fd_path vfs_get_fd_path;
	struct __actvret_fscall_vfs_sysmgr_get_fd_path vfs_sysmgr_get_fd_path;
	struct __actvret_fscall_vfs_fcntl vfs_fcntl;
	struct __actvret_fscall_vfs_device_mounted vfs_device_mounted;
	struct __actvret_fscall_vfs_quotactl vfs_quotactl;
	struct __actvret_fscall_vfs_copy_file_range vfs_copy_file_range;
	struct __actvret_fscall_vfs_same_file vfs_same_file;
	struct __actvret_fscall_vfs_access vfs_access;
	struct __actvret_fscall_vfs_flock vfs_flock;
	struct __actvret_fscall_vfs_fchownat vfs_fchownat;
	struct __actvret_fscall_vfs_fchown vfs_fchown;
	struct __actvret_fscall_vfs_binderfs_mmap vfs_binderfs_mmap;
	struct __actvret_fscall_vfs_init_signalfd vfs_init_signalfd;
	struct __actvret_fscall_vfs_epoll_ctl vfs_epoll_ctl;
	struct __actvret_fscall_vfs_epoll_et_revents vfs_epoll_et_revents;
	struct __actvret_fscall_vfs_epoll_reinit vfs_epoll_reinit;
	struct __actvret_fscall_vfs_signalfd_notify vfs_signalfd_notify;
	struct __actvret_fscall_vfs_pid_io_stats vfs_pid_io_stats;
	struct __actvret_fscall_vfs_fallocate vfs_fallocate;
	struct __actvret_fscall_vfs_set_cwdroot vfs_set_cwdroot;
	struct __actvret_fscall_vfs_fchdir vfs_fchdir;
	struct __actvret_fscall_vfs_disable_cwdroot vfs_disable_cwdroot;
	struct __actvret_fscall_vfs_update_cwdroot vfs_update_cwdroot;
	struct __actvret_fscall_vfs_handle_global_locks vfs_handle_global_locks;
	struct __actvret_fscall_vfs_send_fd vfs_send_fd;
	struct __actvret_fscall_vfs_recv_fd vfs_recv_fd;
	struct __actvret_fscall_vfs_get_buffer_wrapper vfs_get_buffer_wrapper;
	struct __actvret_fscall_vfs_get_pathname_by_me_idx vfs_get_pathname_by_me_idx;
	struct __actvret_fscall_vfs_sfile_put vfs_sfile_put;
	struct __actvret_fscall_vfs_readlinkat vfs_readlinkat;
	struct __actvret_fscall_vfs_get_slabinfo vfs_get_slabinfo;
	struct __actvret_fscall_vfs_do_get_slabinfo vfs_do_get_slabinfo;
	struct __actvret_fscall_vfs_fscache_print_info vfs_fscache_print_info;
	struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device vfs_alloc_fs_handle_for_same_device;
	struct __actvret_fscall_vfs_free_fs_handle_for_same_device vfs_free_fs_handle_for_same_device;
	struct __actvret_fscall_vfs_memfd_create vfs_memfd_create;
	struct __actvret_fscall_vfs_mknod vfs_mknod;
	struct __actvret_fscall_vfs_rename vfs_rename;
	struct __actvret_fscall_vfs_mkdirat vfs_mkdirat;
	struct __actvret_fscall_vfs_link vfs_link;
	struct __actvret_fscall_vfs_unlink vfs_unlink;
	struct __actvret_fscall_vfs_symlink vfs_symlink;
	struct __actvret_fscall_vfs_getxattr vfs_getxattr;
	struct __actvret_fscall_vfs_fgetxattr vfs_fgetxattr;
	struct __actvret_fscall_vfs_setxattr vfs_setxattr;
	struct __actvret_fscall_vfs_fsetxattr vfs_fsetxattr;
	struct __actvret_fscall_vfs_listxattr vfs_listxattr;
	struct __actvret_fscall_vfs_flistxattr vfs_flistxattr;
	struct __actvret_fscall_vfs_removexattr vfs_removexattr;
	struct __actvret_fscall_vfs_fremovexattr vfs_fremovexattr;
	struct __actvret_fscall_vfs_iommap vfs_iommap;
	struct __actvret_fscall_vfs_mmap_create vfs_mmap_create;
	struct __actvret_fscall_vfs_mmap_release_file vfs_mmap_release_file;
	struct __actvret_fscall_vfs_mmap_change vfs_mmap_change;
	struct __actvret_fscall_vfs_mmap_fill_page vfs_mmap_fill_page;
	struct __actvret_fscall_vfs_mmap_fetch_page vfs_mmap_fetch_page;
	struct __actvret_fscall_vfs_mmap_change_page vfs_mmap_change_page;
	struct __actvret_fscall_vfs_mmap_fallocate vfs_mmap_fallocate;
	struct __actvret_fscall_vfs_gfd_table_update vfs_gfd_table_update;
	struct __actvret_fscall_vfs_gfd_table_remove vfs_gfd_table_remove;
	struct __actvret_fscall_vfs_gfd_table_expand vfs_gfd_table_expand;
	struct __actvret_fscall_vfs_gfd_table_acquire vfs_gfd_table_acquire;
	struct __actvret_fscall_vfs_gfd_table_release vfs_gfd_table_release;
	struct __actvret_fscall_vfs_gfd_table_replace vfs_gfd_table_replace;
	struct __actvret_fscall_vfs_gfd_table_fault vfs_gfd_table_fault;
	struct __actvret_fscall_vfs_anon_register_devhost vfs_anon_register_devhost;
	struct __actvret_fscall_vfs_get_unused_fd vfs_get_unused_fd;
	struct __actvret_fscall_vfs_put_unused_fd vfs_put_unused_fd;
	struct __actvret_fscall_vfs_fd_info_update vfs_fd_info_update;
	struct __actvret_fscall_vfs_get_root_path vfs_get_root_path;
	struct __actvret_fscall_vfs_transfs_fget vfs_transfs_fget;
	struct __actvret_fscall_vfs_do_trans_fget vfs_do_trans_fget;
	struct __actvret_fscall_vfs_transfs_fput vfs_transfs_fput;
	struct __actvret_fscall_vfs_do_trans_fput vfs_do_trans_fput;
	struct __actvret_fscall_vfs_read_mounts vfs_read_mounts;
};

enum __fs_mgr {
	__fs_INVAL_mgr=0,
	__fs_procfs_mgr,
	__fs_sysfs_mgr,
	__fs_clock_mgr,
	__fs_inotify_mgr,
	__fs_fanotify_mgr,
	__fs_endio_mgr,
	__fs_sec_mgr,
	__fs_vfs_mgr,
	__fs_MAX_mgr,
};

#define __fs_method_MIN __ACTV_HIGHTABLE_START
#define __fs_method_procfs_create_data (__ACTV_HIGHTABLE_START + 1)
#define __fs_method_procfs_delete_data (__ACTV_HIGHTABLE_START + 2)
#define __fs_method_procfs_get_process_fds (__ACTV_HIGHTABLE_START + 3)
#define __fs_method_procfs_get_fd_mode (__ACTV_HIGHTABLE_START + 4)
#define __fs_method_procfs_rsvd_4 (__ACTV_HIGHTABLE_START + 5)
#define __fs_method_procfs_rsvd_3 (__ACTV_HIGHTABLE_START + 6)
#define __fs_method_procfs_rsvd_2 (__ACTV_HIGHTABLE_START + 7)
#define __fs_method_procfs_rsvd_1 (__ACTV_HIGHTABLE_START + 8)
#define __fs_method_sysfs_create_file (__ACTV_HIGHTABLE_START + 9)
#define __fs_method_sysfs_create_dir (__ACTV_HIGHTABLE_START + 10)
#define __fs_method_sysfs_create_symlink (__ACTV_HIGHTABLE_START + 11)
#define __fs_method_sysfs_delete (__ACTV_HIGHTABLE_START + 12)
#define __fs_method_sysfs_notify (__ACTV_HIGHTABLE_START + 13)
#define __fs_method_sysfs_rsvd_3 (__ACTV_HIGHTABLE_START + 14)
#define __fs_method_sysfs_rsvd_2 (__ACTV_HIGHTABLE_START + 15)
#define __fs_method_sysfs_rsvd_1 (__ACTV_HIGHTABLE_START + 16)
#define __fs_method_clock_settime (__ACTV_HIGHTABLE_START + 17)
#define __fs_method_clock_gettime (__ACTV_HIGHTABLE_START + 18)
#define __fs_method_clock_getres (__ACTV_HIGHTABLE_START + 19)
#define __fs_method_clock_adjtime (__ACTV_HIGHTABLE_START + 20)
#define __fs_method_clock_rsvd_4 (__ACTV_HIGHTABLE_START + 21)
#define __fs_method_clock_rsvd_3 (__ACTV_HIGHTABLE_START + 22)
#define __fs_method_clock_rsvd_2 (__ACTV_HIGHTABLE_START + 23)
#define __fs_method_clock_rsvd_1 (__ACTV_HIGHTABLE_START + 24)
#define __fs_method_inotify_init1 (__ACTV_HIGHTABLE_START + 25)
#define __fs_method_inotify_add_watch (__ACTV_HIGHTABLE_START + 26)
#define __fs_method_inotify_rm_watch (__ACTV_HIGHTABLE_START + 27)
#define __fs_method_inotify_add_watch_internal (__ACTV_HIGHTABLE_START + 28)
#define __fs_method_inotify_rm_watch_internal (__ACTV_HIGHTABLE_START + 29)
#define __fs_method_inotify_notify (__ACTV_HIGHTABLE_START + 30)
#define __fs_method_inotify_inode_destroyed (__ACTV_HIGHTABLE_START + 31)
#define __fs_method_inotify_rsvd_9 (__ACTV_HIGHTABLE_START + 32)
#define __fs_method_inotify_rsvd_8 (__ACTV_HIGHTABLE_START + 33)
#define __fs_method_inotify_rsvd_7 (__ACTV_HIGHTABLE_START + 34)
#define __fs_method_inotify_rsvd_6 (__ACTV_HIGHTABLE_START + 35)
#define __fs_method_inotify_rsvd_5 (__ACTV_HIGHTABLE_START + 36)
#define __fs_method_inotify_rsvd_4 (__ACTV_HIGHTABLE_START + 37)
#define __fs_method_inotify_rsvd_3 (__ACTV_HIGHTABLE_START + 38)
#define __fs_method_inotify_rsvd_2 (__ACTV_HIGHTABLE_START + 39)
#define __fs_method_inotify_rsvd_1 (__ACTV_HIGHTABLE_START + 40)
#define __fs_method_fanotify_init (__ACTV_HIGHTABLE_START + 41)
#define __fs_method_fanotify_mark (__ACTV_HIGHTABLE_START + 42)
#define __fs_method_fanotify_mark_internal (__ACTV_HIGHTABLE_START + 43)
#define __fs_method_fanotify_rm_watch_internal (__ACTV_HIGHTABLE_START + 44)
#define __fs_method_fanotify_notify (__ACTV_HIGHTABLE_START + 45)
#define __fs_method_fanotify_destroyed (__ACTV_HIGHTABLE_START + 46)
#define __fs_method_fanotify_open (__ACTV_HIGHTABLE_START + 47)
#define __fs_method_fanotify_rsvd_9 (__ACTV_HIGHTABLE_START + 48)
#define __fs_method_fanotify_rsvd_8 (__ACTV_HIGHTABLE_START + 49)
#define __fs_method_fanotify_rsvd_7 (__ACTV_HIGHTABLE_START + 50)
#define __fs_method_fanotify_rsvd_6 (__ACTV_HIGHTABLE_START + 51)
#define __fs_method_fanotify_rsvd_5 (__ACTV_HIGHTABLE_START + 52)
#define __fs_method_fanotify_rsvd_4 (__ACTV_HIGHTABLE_START + 53)
#define __fs_method_fanotify_rsvd_3 (__ACTV_HIGHTABLE_START + 54)
#define __fs_method_fanotify_rsvd_2 (__ACTV_HIGHTABLE_START + 55)
#define __fs_method_fanotify_rsvd_1 (__ACTV_HIGHTABLE_START + 56)
#define __fs_method_endio_io_done (__ACTV_HIGHTABLE_START + 57)
#define __fs_method_endio_rsvd_7 (__ACTV_HIGHTABLE_START + 58)
#define __fs_method_endio_rsvd_6 (__ACTV_HIGHTABLE_START + 59)
#define __fs_method_endio_rsvd_5 (__ACTV_HIGHTABLE_START + 60)
#define __fs_method_endio_rsvd_4 (__ACTV_HIGHTABLE_START + 61)
#define __fs_method_endio_rsvd_3 (__ACTV_HIGHTABLE_START + 62)
#define __fs_method_endio_rsvd_2 (__ACTV_HIGHTABLE_START + 63)
#define __fs_method_endio_rsvd_1 (__ACTV_HIGHTABLE_START + 64)
#define __fs_method_vfs_set_label (__ACTV_HIGHTABLE_START + 65)
#define __fs_method_vfs_set_label_by_path (__ACTV_HIGHTABLE_START + 66)
#define __fs_method_vfs_get_label (__ACTV_HIGHTABLE_START + 67)
#define __fs_method_vfs_init_audit (__ACTV_HIGHTABLE_START + 68)
#define __fs_method_vfs_add_audit_rule (__ACTV_HIGHTABLE_START + 69)
#define __fs_method_vfs_del_audit_rule (__ACTV_HIGHTABLE_START + 70)
#define __fs_method_vfs_match_audit_watch_file (__ACTV_HIGHTABLE_START + 71)
#define __fs_method_vfs_match_audit_watch_dir (__ACTV_HIGHTABLE_START + 72)
#define __fs_method_sec_rsvd_8 (__ACTV_HIGHTABLE_START + 73)
#define __fs_method_sec_rsvd_7 (__ACTV_HIGHTABLE_START + 74)
#define __fs_method_sec_rsvd_6 (__ACTV_HIGHTABLE_START + 75)
#define __fs_method_sec_rsvd_5 (__ACTV_HIGHTABLE_START + 76)
#define __fs_method_sec_rsvd_4 (__ACTV_HIGHTABLE_START + 77)
#define __fs_method_sec_rsvd_3 (__ACTV_HIGHTABLE_START + 78)
#define __fs_method_sec_rsvd_2 (__ACTV_HIGHTABLE_START + 79)
#define __fs_method_sec_rsvd_1 (__ACTV_HIGHTABLE_START + 80)
#define __fs_method_vfs_client_init (__ACTV_HIGHTABLE_START + 81)
#define __fs_method_vfs_bind_update (__ACTV_HIGHTABLE_START + 82)
#define __fs_method_vfs_clone (__ACTV_HIGHTABLE_START + 83)
#define __fs_method_vfs_close (__ACTV_HIGHTABLE_START + 84)
#define __fs_method_vfs_mount (__ACTV_HIGHTABLE_START + 85)
#define __fs_method_vfs_clone_mount_entry (__ACTV_HIGHTABLE_START + 86)
#define __fs_method_vfs_clone_mount_entry_from_orig_parent (__ACTV_HIGHTABLE_START + 87)
#define __fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent (__ACTV_HIGHTABLE_START + 88)
#define __fs_method_vfs_destroy_cloned_mount_entry (__ACTV_HIGHTABLE_START + 89)
#define __fs_method_vfs_check_mount (__ACTV_HIGHTABLE_START + 90)
#define __fs_method_vfs_mountpoint_del_mount (__ACTV_HIGHTABLE_START + 91)
#define __fs_method_vfs_open (__ACTV_HIGHTABLE_START + 92)
#define __fs_method_vfs_ftruncate (__ACTV_HIGHTABLE_START + 93)
#define __fs_method_vfs_fstat (__ACTV_HIGHTABLE_START + 94)
#define __fs_method_vfs_stat (__ACTV_HIGHTABLE_START + 95)
#define __fs_method_vfs_statfs (__ACTV_HIGHTABLE_START + 96)
#define __fs_method_vfs_fstatfs (__ACTV_HIGHTABLE_START + 97)
#define __fs_method_vfs_fsync (__ACTV_HIGHTABLE_START + 98)
#define __fs_method_vfs_unmount (__ACTV_HIGHTABLE_START + 99)
#define __fs_method_vfs_unmount_from_server (__ACTV_HIGHTABLE_START + 100)
#define __fs_method_vfs_unmount_child (__ACTV_HIGHTABLE_START + 101)
#define __fs_method_vfs_truncate (__ACTV_HIGHTABLE_START + 102)
#define __fs_method_vfs_fs_fork (__ACTV_HIGHTABLE_START + 103)
#define __fs_method_vfs_query_info (__ACTV_HIGHTABLE_START + 104)
#define __fs_method_vfs_lseek (__ACTV_HIGHTABLE_START + 105)
#define __fs_method_vfs_trans (__ACTV_HIGHTABLE_START + 106)
#define __fs_method_vfs_pipe2 (__ACTV_HIGHTABLE_START + 107)
#define __fs_method_vfs_tee (__ACTV_HIGHTABLE_START + 108)
#define __fs_method_vfs_splice (__ACTV_HIGHTABLE_START + 109)
#define __fs_method_vfs_do_splice_srvs (__ACTV_HIGHTABLE_START + 110)
#define __fs_method_vfs_revoke_process (__ACTV_HIGHTABLE_START + 111)
#define __fs_method_vfs_setrlimit (__ACTV_HIGHTABLE_START + 112)
#define __fs_method_vfs_get_ns (__ACTV_HIGHTABLE_START + 113)
#define __fs_method_vfs_put_ns (__ACTV_HIGHTABLE_START + 114)
#define __fs_method_vfs_init_eventfd (__ACTV_HIGHTABLE_START + 115)
#define __fs_method_vfs_write_eventfd (__ACTV_HIGHTABLE_START + 116)
#define __fs_method_vfs_timerfd_create (__ACTV_HIGHTABLE_START + 117)
#define __fs_method_vfs_timerfd_settime (__ACTV_HIGHTABLE_START + 118)
#define __fs_method_vfs_timerfd_gettime (__ACTV_HIGHTABLE_START + 119)
#define __fs_method_vfs_open_exec (__ACTV_HIGHTABLE_START + 120)
#define __fs_method_vfs_close_exec (__ACTV_HIGHTABLE_START + 121)
#define __fs_method_vfs_set_elf_file (__ACTV_HIGHTABLE_START + 122)
#define __fs_method_vfs_ioctl (__ACTV_HIGHTABLE_START + 123)
#define __fs_method_vfs_read (__ACTV_HIGHTABLE_START + 124)
#define __fs_method_vfs_readv (__ACTV_HIGHTABLE_START + 125)
#define __fs_method_vfs_getcwd (__ACTV_HIGHTABLE_START + 126)
#define __fs_method_vfs_get_process_cwdrootexe (__ACTV_HIGHTABLE_START + 127)
#define __fs_method_vfs_readdir (__ACTV_HIGHTABLE_START + 128)
#define __fs_method_vfs_write (__ACTV_HIGHTABLE_START + 129)
#define __fs_method_vfs_writev (__ACTV_HIGHTABLE_START + 130)
#define __fs_method_vfs_sync (__ACTV_HIGHTABLE_START + 131)
#define __fs_method_vfs_do_sync (__ACTV_HIGHTABLE_START + 132)
#define __fs_method_vfs_utimensat (__ACTV_HIGHTABLE_START + 133)
#define __fs_method_vfs_futimens (__ACTV_HIGHTABLE_START + 134)
#define __fs_method_vfs_fchmodat (__ACTV_HIGHTABLE_START + 135)
#define __fs_method_vfs_fchmod (__ACTV_HIGHTABLE_START + 136)
#define __fs_method_vfs_drop_caches (__ACTV_HIGHTABLE_START + 137)
#define __fs_method_vfs_do_drop_caches (__ACTV_HIGHTABLE_START + 138)
#define __fs_method_vfs_fadvise (__ACTV_HIGHTABLE_START + 139)
#define __fs_method_vfs_readahead (__ACTV_HIGHTABLE_START + 140)
#define __fs_method_vfs_get_fd_path (__ACTV_HIGHTABLE_START + 141)
#define __fs_method_vfs_sysmgr_get_fd_path (__ACTV_HIGHTABLE_START + 142)
#define __fs_method_vfs_fcntl (__ACTV_HIGHTABLE_START + 143)
#define __fs_method_vfs_device_mounted (__ACTV_HIGHTABLE_START + 144)
#define __fs_method_vfs_quotactl (__ACTV_HIGHTABLE_START + 145)
#define __fs_method_vfs_copy_file_range (__ACTV_HIGHTABLE_START + 146)
#define __fs_method_vfs_same_file (__ACTV_HIGHTABLE_START + 147)
#define __fs_method_vfs_access (__ACTV_HIGHTABLE_START + 148)
#define __fs_method_vfs_flock (__ACTV_HIGHTABLE_START + 149)
#define __fs_method_vfs_fchownat (__ACTV_HIGHTABLE_START + 150)
#define __fs_method_vfs_fchown (__ACTV_HIGHTABLE_START + 151)
#define __fs_method_vfs_binderfs_mmap (__ACTV_HIGHTABLE_START + 152)
#define __fs_method_vfs_init_signalfd (__ACTV_HIGHTABLE_START + 153)
#define __fs_method_vfs_epoll_ctl (__ACTV_HIGHTABLE_START + 154)
#define __fs_method_vfs_epoll_et_revents (__ACTV_HIGHTABLE_START + 155)
#define __fs_method_vfs_epoll_reinit (__ACTV_HIGHTABLE_START + 156)
#define __fs_method_vfs_signalfd_notify (__ACTV_HIGHTABLE_START + 157)
#define __fs_method_vfs_pid_io_stats (__ACTV_HIGHTABLE_START + 158)
#define __fs_method_vfs_fallocate (__ACTV_HIGHTABLE_START + 159)
#define __fs_method_vfs_set_cwdroot (__ACTV_HIGHTABLE_START + 160)
#define __fs_method_vfs_fchdir (__ACTV_HIGHTABLE_START + 161)
#define __fs_method_vfs_disable_cwdroot (__ACTV_HIGHTABLE_START + 162)
#define __fs_method_vfs_update_cwdroot (__ACTV_HIGHTABLE_START + 163)
#define __fs_method_vfs_handle_global_locks (__ACTV_HIGHTABLE_START + 164)
#define __fs_method_vfs_send_fd (__ACTV_HIGHTABLE_START + 165)
#define __fs_method_vfs_recv_fd (__ACTV_HIGHTABLE_START + 166)
#define __fs_method_vfs_get_buffer_wrapper (__ACTV_HIGHTABLE_START + 167)
#define __fs_method_vfs_get_pathname_by_me_idx (__ACTV_HIGHTABLE_START + 168)
#define __fs_method_vfs_sfile_put (__ACTV_HIGHTABLE_START + 169)
#define __fs_method_vfs_readlinkat (__ACTV_HIGHTABLE_START + 170)
#define __fs_method_vfs_get_slabinfo (__ACTV_HIGHTABLE_START + 171)
#define __fs_method_vfs_do_get_slabinfo (__ACTV_HIGHTABLE_START + 172)
#define __fs_method_vfs_fscache_print_info (__ACTV_HIGHTABLE_START + 173)
#define __fs_method_vfs_alloc_fs_handle_for_same_device (__ACTV_HIGHTABLE_START + 174)
#define __fs_method_vfs_free_fs_handle_for_same_device (__ACTV_HIGHTABLE_START + 175)
#define __fs_method_vfs_memfd_create (__ACTV_HIGHTABLE_START + 176)
#define __fs_method_vfs_mknod (__ACTV_HIGHTABLE_START + 177)
#define __fs_method_vfs_rename (__ACTV_HIGHTABLE_START + 178)
#define __fs_method_vfs_mkdirat (__ACTV_HIGHTABLE_START + 179)
#define __fs_method_vfs_link (__ACTV_HIGHTABLE_START + 180)
#define __fs_method_vfs_unlink (__ACTV_HIGHTABLE_START + 181)
#define __fs_method_vfs_symlink (__ACTV_HIGHTABLE_START + 182)
#define __fs_method_vfs_getxattr (__ACTV_HIGHTABLE_START + 183)
#define __fs_method_vfs_fgetxattr (__ACTV_HIGHTABLE_START + 184)
#define __fs_method_vfs_setxattr (__ACTV_HIGHTABLE_START + 185)
#define __fs_method_vfs_fsetxattr (__ACTV_HIGHTABLE_START + 186)
#define __fs_method_vfs_listxattr (__ACTV_HIGHTABLE_START + 187)
#define __fs_method_vfs_flistxattr (__ACTV_HIGHTABLE_START + 188)
#define __fs_method_vfs_removexattr (__ACTV_HIGHTABLE_START + 189)
#define __fs_method_vfs_fremovexattr (__ACTV_HIGHTABLE_START + 190)
#define __fs_method_vfs_iommap (__ACTV_HIGHTABLE_START + 191)
#define __fs_method_vfs_mmap_create (__ACTV_HIGHTABLE_START + 192)
#define __fs_method_vfs_mmap_release_file (__ACTV_HIGHTABLE_START + 193)
#define __fs_method_vfs_mmap_change (__ACTV_HIGHTABLE_START + 194)
#define __fs_method_vfs_mmap_fill_page (__ACTV_HIGHTABLE_START + 195)
#define __fs_method_vfs_mmap_fetch_page (__ACTV_HIGHTABLE_START + 196)
#define __fs_method_vfs_mmap_change_page (__ACTV_HIGHTABLE_START + 197)
#define __fs_method_vfs_mmap_fallocate (__ACTV_HIGHTABLE_START + 198)
#define __fs_method_vfs_gfd_table_update (__ACTV_HIGHTABLE_START + 199)
#define __fs_method_vfs_gfd_table_remove (__ACTV_HIGHTABLE_START + 200)
#define __fs_method_vfs_gfd_table_expand (__ACTV_HIGHTABLE_START + 201)
#define __fs_method_vfs_gfd_table_acquire (__ACTV_HIGHTABLE_START + 202)
#define __fs_method_vfs_gfd_table_release (__ACTV_HIGHTABLE_START + 203)
#define __fs_method_vfs_gfd_table_replace (__ACTV_HIGHTABLE_START + 204)
#define __fs_method_vfs_gfd_table_fault (__ACTV_HIGHTABLE_START + 205)
#define __fs_method_vfs_anon_register_devhost (__ACTV_HIGHTABLE_START + 206)
#define __fs_method_vfs_get_unused_fd (__ACTV_HIGHTABLE_START + 207)
#define __fs_method_vfs_put_unused_fd (__ACTV_HIGHTABLE_START + 208)
#define __fs_method_vfs_fd_info_update (__ACTV_HIGHTABLE_START + 209)
#define __fs_method_vfs_get_root_path (__ACTV_HIGHTABLE_START + 210)
#define __fs_method_vfs_transfs_fget (__ACTV_HIGHTABLE_START + 211)
#define __fs_method_vfs_do_trans_fget (__ACTV_HIGHTABLE_START + 212)
#define __fs_method_vfs_transfs_fput (__ACTV_HIGHTABLE_START + 213)
#define __fs_method_vfs_do_trans_fput (__ACTV_HIGHTABLE_START + 214)
#define __fs_method_vfs_read_mounts (__ACTV_HIGHTABLE_START + 215)
#define __fs_method_vfs_rsvd_121 (__ACTV_HIGHTABLE_START + 216)
#define __fs_method_vfs_rsvd_120 (__ACTV_HIGHTABLE_START + 217)
#define __fs_method_vfs_rsvd_119 (__ACTV_HIGHTABLE_START + 218)
#define __fs_method_vfs_rsvd_118 (__ACTV_HIGHTABLE_START + 219)
#define __fs_method_vfs_rsvd_117 (__ACTV_HIGHTABLE_START + 220)
#define __fs_method_vfs_rsvd_116 (__ACTV_HIGHTABLE_START + 221)
#define __fs_method_vfs_rsvd_115 (__ACTV_HIGHTABLE_START + 222)
#define __fs_method_vfs_rsvd_114 (__ACTV_HIGHTABLE_START + 223)
#define __fs_method_vfs_rsvd_113 (__ACTV_HIGHTABLE_START + 224)
#define __fs_method_vfs_rsvd_112 (__ACTV_HIGHTABLE_START + 225)
#define __fs_method_vfs_rsvd_111 (__ACTV_HIGHTABLE_START + 226)
#define __fs_method_vfs_rsvd_110 (__ACTV_HIGHTABLE_START + 227)
#define __fs_method_vfs_rsvd_109 (__ACTV_HIGHTABLE_START + 228)
#define __fs_method_vfs_rsvd_108 (__ACTV_HIGHTABLE_START + 229)
#define __fs_method_vfs_rsvd_107 (__ACTV_HIGHTABLE_START + 230)
#define __fs_method_vfs_rsvd_106 (__ACTV_HIGHTABLE_START + 231)
#define __fs_method_vfs_rsvd_105 (__ACTV_HIGHTABLE_START + 232)
#define __fs_method_vfs_rsvd_104 (__ACTV_HIGHTABLE_START + 233)
#define __fs_method_vfs_rsvd_103 (__ACTV_HIGHTABLE_START + 234)
#define __fs_method_vfs_rsvd_102 (__ACTV_HIGHTABLE_START + 235)
#define __fs_method_vfs_rsvd_101 (__ACTV_HIGHTABLE_START + 236)
#define __fs_method_vfs_rsvd_100 (__ACTV_HIGHTABLE_START + 237)
#define __fs_method_vfs_rsvd_99 (__ACTV_HIGHTABLE_START + 238)
#define __fs_method_vfs_rsvd_98 (__ACTV_HIGHTABLE_START + 239)
#define __fs_method_vfs_rsvd_97 (__ACTV_HIGHTABLE_START + 240)
#define __fs_method_vfs_rsvd_96 (__ACTV_HIGHTABLE_START + 241)
#define __fs_method_vfs_rsvd_95 (__ACTV_HIGHTABLE_START + 242)
#define __fs_method_vfs_rsvd_94 (__ACTV_HIGHTABLE_START + 243)
#define __fs_method_vfs_rsvd_93 (__ACTV_HIGHTABLE_START + 244)
#define __fs_method_vfs_rsvd_92 (__ACTV_HIGHTABLE_START + 245)
#define __fs_method_vfs_rsvd_91 (__ACTV_HIGHTABLE_START + 246)
#define __fs_method_vfs_rsvd_90 (__ACTV_HIGHTABLE_START + 247)
#define __fs_method_vfs_rsvd_89 (__ACTV_HIGHTABLE_START + 248)
#define __fs_method_vfs_rsvd_88 (__ACTV_HIGHTABLE_START + 249)
#define __fs_method_vfs_rsvd_87 (__ACTV_HIGHTABLE_START + 250)
#define __fs_method_vfs_rsvd_86 (__ACTV_HIGHTABLE_START + 251)
#define __fs_method_vfs_rsvd_85 (__ACTV_HIGHTABLE_START + 252)
#define __fs_method_vfs_rsvd_84 (__ACTV_HIGHTABLE_START + 253)
#define __fs_method_vfs_rsvd_83 (__ACTV_HIGHTABLE_START + 254)
#define __fs_method_vfs_rsvd_82 (__ACTV_HIGHTABLE_START + 255)
#define __fs_method_vfs_rsvd_81 (__ACTV_HIGHTABLE_START + 256)
#define __fs_method_vfs_rsvd_80 (__ACTV_HIGHTABLE_START + 257)
#define __fs_method_vfs_rsvd_79 (__ACTV_HIGHTABLE_START + 258)
#define __fs_method_vfs_rsvd_78 (__ACTV_HIGHTABLE_START + 259)
#define __fs_method_vfs_rsvd_77 (__ACTV_HIGHTABLE_START + 260)
#define __fs_method_vfs_rsvd_76 (__ACTV_HIGHTABLE_START + 261)
#define __fs_method_vfs_rsvd_75 (__ACTV_HIGHTABLE_START + 262)
#define __fs_method_vfs_rsvd_74 (__ACTV_HIGHTABLE_START + 263)
#define __fs_method_vfs_rsvd_73 (__ACTV_HIGHTABLE_START + 264)
#define __fs_method_vfs_rsvd_72 (__ACTV_HIGHTABLE_START + 265)
#define __fs_method_vfs_rsvd_71 (__ACTV_HIGHTABLE_START + 266)
#define __fs_method_vfs_rsvd_70 (__ACTV_HIGHTABLE_START + 267)
#define __fs_method_vfs_rsvd_69 (__ACTV_HIGHTABLE_START + 268)
#define __fs_method_vfs_rsvd_68 (__ACTV_HIGHTABLE_START + 269)
#define __fs_method_vfs_rsvd_67 (__ACTV_HIGHTABLE_START + 270)
#define __fs_method_vfs_rsvd_66 (__ACTV_HIGHTABLE_START + 271)
#define __fs_method_vfs_rsvd_65 (__ACTV_HIGHTABLE_START + 272)
#define __fs_method_vfs_rsvd_64 (__ACTV_HIGHTABLE_START + 273)
#define __fs_method_vfs_rsvd_63 (__ACTV_HIGHTABLE_START + 274)
#define __fs_method_vfs_rsvd_62 (__ACTV_HIGHTABLE_START + 275)
#define __fs_method_vfs_rsvd_61 (__ACTV_HIGHTABLE_START + 276)
#define __fs_method_vfs_rsvd_60 (__ACTV_HIGHTABLE_START + 277)
#define __fs_method_vfs_rsvd_59 (__ACTV_HIGHTABLE_START + 278)
#define __fs_method_vfs_rsvd_58 (__ACTV_HIGHTABLE_START + 279)
#define __fs_method_vfs_rsvd_57 (__ACTV_HIGHTABLE_START + 280)
#define __fs_method_vfs_rsvd_56 (__ACTV_HIGHTABLE_START + 281)
#define __fs_method_vfs_rsvd_55 (__ACTV_HIGHTABLE_START + 282)
#define __fs_method_vfs_rsvd_54 (__ACTV_HIGHTABLE_START + 283)
#define __fs_method_vfs_rsvd_53 (__ACTV_HIGHTABLE_START + 284)
#define __fs_method_vfs_rsvd_52 (__ACTV_HIGHTABLE_START + 285)
#define __fs_method_vfs_rsvd_51 (__ACTV_HIGHTABLE_START + 286)
#define __fs_method_vfs_rsvd_50 (__ACTV_HIGHTABLE_START + 287)
#define __fs_method_vfs_rsvd_49 (__ACTV_HIGHTABLE_START + 288)
#define __fs_method_vfs_rsvd_48 (__ACTV_HIGHTABLE_START + 289)
#define __fs_method_vfs_rsvd_47 (__ACTV_HIGHTABLE_START + 290)
#define __fs_method_vfs_rsvd_46 (__ACTV_HIGHTABLE_START + 291)
#define __fs_method_vfs_rsvd_45 (__ACTV_HIGHTABLE_START + 292)
#define __fs_method_vfs_rsvd_44 (__ACTV_HIGHTABLE_START + 293)
#define __fs_method_vfs_rsvd_43 (__ACTV_HIGHTABLE_START + 294)
#define __fs_method_vfs_rsvd_42 (__ACTV_HIGHTABLE_START + 295)
#define __fs_method_vfs_rsvd_41 (__ACTV_HIGHTABLE_START + 296)
#define __fs_method_vfs_rsvd_40 (__ACTV_HIGHTABLE_START + 297)
#define __fs_method_vfs_rsvd_39 (__ACTV_HIGHTABLE_START + 298)
#define __fs_method_vfs_rsvd_38 (__ACTV_HIGHTABLE_START + 299)
#define __fs_method_vfs_rsvd_37 (__ACTV_HIGHTABLE_START + 300)
#define __fs_method_vfs_rsvd_36 (__ACTV_HIGHTABLE_START + 301)
#define __fs_method_vfs_rsvd_35 (__ACTV_HIGHTABLE_START + 302)
#define __fs_method_vfs_rsvd_34 (__ACTV_HIGHTABLE_START + 303)
#define __fs_method_vfs_rsvd_33 (__ACTV_HIGHTABLE_START + 304)
#define __fs_method_vfs_rsvd_32 (__ACTV_HIGHTABLE_START + 305)
#define __fs_method_vfs_rsvd_31 (__ACTV_HIGHTABLE_START + 306)
#define __fs_method_vfs_rsvd_30 (__ACTV_HIGHTABLE_START + 307)
#define __fs_method_vfs_rsvd_29 (__ACTV_HIGHTABLE_START + 308)
#define __fs_method_vfs_rsvd_28 (__ACTV_HIGHTABLE_START + 309)
#define __fs_method_vfs_rsvd_27 (__ACTV_HIGHTABLE_START + 310)
#define __fs_method_vfs_rsvd_26 (__ACTV_HIGHTABLE_START + 311)
#define __fs_method_vfs_rsvd_25 (__ACTV_HIGHTABLE_START + 312)
#define __fs_method_vfs_rsvd_24 (__ACTV_HIGHTABLE_START + 313)
#define __fs_method_vfs_rsvd_23 (__ACTV_HIGHTABLE_START + 314)
#define __fs_method_vfs_rsvd_22 (__ACTV_HIGHTABLE_START + 315)
#define __fs_method_vfs_rsvd_21 (__ACTV_HIGHTABLE_START + 316)
#define __fs_method_vfs_rsvd_20 (__ACTV_HIGHTABLE_START + 317)
#define __fs_method_vfs_rsvd_19 (__ACTV_HIGHTABLE_START + 318)
#define __fs_method_vfs_rsvd_18 (__ACTV_HIGHTABLE_START + 319)
#define __fs_method_vfs_rsvd_17 (__ACTV_HIGHTABLE_START + 320)
#define __fs_method_vfs_rsvd_16 (__ACTV_HIGHTABLE_START + 321)
#define __fs_method_vfs_rsvd_15 (__ACTV_HIGHTABLE_START + 322)
#define __fs_method_vfs_rsvd_14 (__ACTV_HIGHTABLE_START + 323)
#define __fs_method_vfs_rsvd_13 (__ACTV_HIGHTABLE_START + 324)
#define __fs_method_vfs_rsvd_12 (__ACTV_HIGHTABLE_START + 325)
#define __fs_method_vfs_rsvd_11 (__ACTV_HIGHTABLE_START + 326)
#define __fs_method_vfs_rsvd_10 (__ACTV_HIGHTABLE_START + 327)
#define __fs_method_vfs_rsvd_9 (__ACTV_HIGHTABLE_START + 328)
#define __fs_method_vfs_rsvd_8 (__ACTV_HIGHTABLE_START + 329)
#define __fs_method_vfs_rsvd_7 (__ACTV_HIGHTABLE_START + 330)
#define __fs_method_vfs_rsvd_6 (__ACTV_HIGHTABLE_START + 331)
#define __fs_method_vfs_rsvd_5 (__ACTV_HIGHTABLE_START + 332)
#define __fs_method_vfs_rsvd_4 (__ACTV_HIGHTABLE_START + 333)
#define __fs_method_vfs_rsvd_3 (__ACTV_HIGHTABLE_START + 334)
#define __fs_method_vfs_rsvd_2 (__ACTV_HIGHTABLE_START + 335)
#define __fs_method_vfs_rsvd_1 (__ACTV_HIGHTABLE_START + 336)
#define __fs_method_MAX_NOCOMPAT (__ACTV_HIGHTABLE_START + 337)
#define __fs_method_MAX_COMPAT ((__ACTV_HIGHTABLE_START + 337) * 2)
raw_static_assert(sizeof(struct __actvret_fscall_procfs_create_data) < 512,
                fscall_procfs_create_data_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_procfs_delete_data) < 512,
                fscall_procfs_delete_data_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_procfs_get_process_fds) < 512,
                fscall_procfs_get_process_fds_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_procfs_get_fd_mode) < 512,
                fscall_procfs_get_fd_mode_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_sysfs_create_file) < 512,
                fscall_sysfs_create_file_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_sysfs_create_dir) < 512,
                fscall_sysfs_create_dir_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_sysfs_create_symlink) < 512,
                fscall_sysfs_create_symlink_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_sysfs_delete) < 512,
                fscall_sysfs_delete_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_sysfs_notify) < 512,
                fscall_sysfs_notify_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_clock_settime) < 512,
                fscall_clock_settime_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_clock_gettime) < 512,
                fscall_clock_gettime_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_clock_getres) < 512,
                fscall_clock_getres_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_clock_adjtime) < 512,
                fscall_clock_adjtime_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_inotify_init1) < 512,
                fscall_inotify_init1_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_inotify_add_watch) < 512,
                fscall_inotify_add_watch_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_inotify_rm_watch) < 512,
                fscall_inotify_rm_watch_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_inotify_add_watch_internal) < 512,
                fscall_inotify_add_watch_internal_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_inotify_rm_watch_internal) < 512,
                fscall_inotify_rm_watch_internal_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_inotify_notify) < 512,
                fscall_inotify_notify_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_inotify_inode_destroyed) < 512,
                fscall_inotify_inode_destroyed_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_fanotify_init) < 512,
                fscall_fanotify_init_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_fanotify_mark) < 512,
                fscall_fanotify_mark_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_fanotify_mark_internal) < 512,
                fscall_fanotify_mark_internal_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_fanotify_rm_watch_internal) < 512,
                fscall_fanotify_rm_watch_internal_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_fanotify_notify) < 512,
                fscall_fanotify_notify_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_fanotify_destroyed) < 512,
                fscall_fanotify_destroyed_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_fanotify_open) < 512,
                fscall_fanotify_open_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_endio_io_done) < 512,
                fscall_endio_io_done_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_set_label) < 512,
                fscall_vfs_set_label_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_set_label_by_path) < 512,
                fscall_vfs_set_label_by_path_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_label) < 512,
                fscall_vfs_get_label_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_init_audit) < 512,
                fscall_vfs_init_audit_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_add_audit_rule) < 512,
                fscall_vfs_add_audit_rule_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_del_audit_rule) < 512,
                fscall_vfs_del_audit_rule_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_match_audit_watch_file) < 512,
                fscall_vfs_match_audit_watch_file_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_match_audit_watch_dir) < 512,
                fscall_vfs_match_audit_watch_dir_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_client_init) < 512,
                fscall_vfs_client_init_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_bind_update) < 512,
                fscall_vfs_bind_update_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_clone) < 512,
                fscall_vfs_clone_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_close) < 512,
                fscall_vfs_close_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mount) < 512,
                fscall_vfs_mount_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_clone_mount_entry) < 512,
                fscall_vfs_clone_mount_entry_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_clone_mount_entry_from_orig_parent) < 512,
                fscall_vfs_clone_mount_entry_from_orig_parent_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent) < 512,
                fscall_vfs_destroy_cloned_mount_entry_from_orig_parent_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_destroy_cloned_mount_entry) < 512,
                fscall_vfs_destroy_cloned_mount_entry_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_check_mount) < 512,
                fscall_vfs_check_mount_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mountpoint_del_mount) < 512,
                fscall_vfs_mountpoint_del_mount_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_open) < 512,
                fscall_vfs_open_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_ftruncate) < 512,
                fscall_vfs_ftruncate_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fstat) < 512,
                fscall_vfs_fstat_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_stat) < 512,
                fscall_vfs_stat_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_statfs) < 512,
                fscall_vfs_statfs_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fstatfs) < 512,
                fscall_vfs_fstatfs_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fsync) < 512,
                fscall_vfs_fsync_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_unmount) < 512,
                fscall_vfs_unmount_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_unmount_from_server) < 512,
                fscall_vfs_unmount_from_server_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_unmount_child) < 512,
                fscall_vfs_unmount_child_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_truncate) < 512,
                fscall_vfs_truncate_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fs_fork) < 512,
                fscall_vfs_fs_fork_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_query_info) < 512,
                fscall_vfs_query_info_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_lseek) < 512,
                fscall_vfs_lseek_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_trans) < 512,
                fscall_vfs_trans_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_pipe2) < 512,
                fscall_vfs_pipe2_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_tee) < 512,
                fscall_vfs_tee_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_splice) < 512,
                fscall_vfs_splice_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_do_splice_srvs) < 512,
                fscall_vfs_do_splice_srvs_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_revoke_process) < 512,
                fscall_vfs_revoke_process_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_setrlimit) < 512,
                fscall_vfs_setrlimit_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_ns) < 512,
                fscall_vfs_get_ns_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_put_ns) < 512,
                fscall_vfs_put_ns_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_init_eventfd) < 512,
                fscall_vfs_init_eventfd_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_write_eventfd) < 512,
                fscall_vfs_write_eventfd_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_timerfd_create) < 512,
                fscall_vfs_timerfd_create_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_timerfd_settime) < 512,
                fscall_vfs_timerfd_settime_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_timerfd_gettime) < 512,
                fscall_vfs_timerfd_gettime_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_open_exec) < 512,
                fscall_vfs_open_exec_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_close_exec) < 512,
                fscall_vfs_close_exec_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_set_elf_file) < 512,
                fscall_vfs_set_elf_file_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_ioctl) < 512,
                fscall_vfs_ioctl_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_read) < 512,
                fscall_vfs_read_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_readv) < 512,
                fscall_vfs_readv_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_getcwd) < 512,
                fscall_vfs_getcwd_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_process_cwdrootexe) < 512,
                fscall_vfs_get_process_cwdrootexe_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_readdir) < 512,
                fscall_vfs_readdir_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_write) < 512,
                fscall_vfs_write_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_writev) < 512,
                fscall_vfs_writev_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_sync) < 512,
                fscall_vfs_sync_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_do_sync) < 512,
                fscall_vfs_do_sync_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_utimensat) < 512,
                fscall_vfs_utimensat_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_futimens) < 512,
                fscall_vfs_futimens_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fchmodat) < 512,
                fscall_vfs_fchmodat_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fchmod) < 512,
                fscall_vfs_fchmod_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_drop_caches) < 512,
                fscall_vfs_drop_caches_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_do_drop_caches) < 512,
                fscall_vfs_do_drop_caches_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fadvise) < 512,
                fscall_vfs_fadvise_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_readahead) < 512,
                fscall_vfs_readahead_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_fd_path) < 512,
                fscall_vfs_get_fd_path_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_sysmgr_get_fd_path) < 512,
                fscall_vfs_sysmgr_get_fd_path_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fcntl) < 512,
                fscall_vfs_fcntl_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_device_mounted) < 512,
                fscall_vfs_device_mounted_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_quotactl) < 512,
                fscall_vfs_quotactl_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_copy_file_range) < 512,
                fscall_vfs_copy_file_range_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_same_file) < 512,
                fscall_vfs_same_file_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_access) < 512,
                fscall_vfs_access_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_flock) < 512,
                fscall_vfs_flock_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fchownat) < 512,
                fscall_vfs_fchownat_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fchown) < 512,
                fscall_vfs_fchown_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_binderfs_mmap) < 512,
                fscall_vfs_binderfs_mmap_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_init_signalfd) < 512,
                fscall_vfs_init_signalfd_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_epoll_ctl) < 512,
                fscall_vfs_epoll_ctl_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_epoll_et_revents) < 512,
                fscall_vfs_epoll_et_revents_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_epoll_reinit) < 512,
                fscall_vfs_epoll_reinit_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_signalfd_notify) < 512,
                fscall_vfs_signalfd_notify_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_pid_io_stats) < 512,
                fscall_vfs_pid_io_stats_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fallocate) < 512,
                fscall_vfs_fallocate_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_set_cwdroot) < 512,
                fscall_vfs_set_cwdroot_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fchdir) < 512,
                fscall_vfs_fchdir_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_disable_cwdroot) < 512,
                fscall_vfs_disable_cwdroot_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_update_cwdroot) < 512,
                fscall_vfs_update_cwdroot_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_handle_global_locks) < 512,
                fscall_vfs_handle_global_locks_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_send_fd) < 512,
                fscall_vfs_send_fd_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_recv_fd) < 512,
                fscall_vfs_recv_fd_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_buffer_wrapper) < 512,
                fscall_vfs_get_buffer_wrapper_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_pathname_by_me_idx) < 512,
                fscall_vfs_get_pathname_by_me_idx_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_sfile_put) < 512,
                fscall_vfs_sfile_put_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_readlinkat) < 512,
                fscall_vfs_readlinkat_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_slabinfo) < 512,
                fscall_vfs_get_slabinfo_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_do_get_slabinfo) < 512,
                fscall_vfs_do_get_slabinfo_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fscache_print_info) < 512,
                fscall_vfs_fscache_print_info_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device) < 512,
                fscall_vfs_alloc_fs_handle_for_same_device_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_free_fs_handle_for_same_device) < 512,
                fscall_vfs_free_fs_handle_for_same_device_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_memfd_create) < 512,
                fscall_vfs_memfd_create_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mknod) < 512,
                fscall_vfs_mknod_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_rename) < 512,
                fscall_vfs_rename_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mkdirat) < 512,
                fscall_vfs_mkdirat_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_link) < 512,
                fscall_vfs_link_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_unlink) < 512,
                fscall_vfs_unlink_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_symlink) < 512,
                fscall_vfs_symlink_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_getxattr) < 512,
                fscall_vfs_getxattr_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fgetxattr) < 512,
                fscall_vfs_fgetxattr_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_setxattr) < 512,
                fscall_vfs_setxattr_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fsetxattr) < 512,
                fscall_vfs_fsetxattr_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_listxattr) < 512,
                fscall_vfs_listxattr_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_flistxattr) < 512,
                fscall_vfs_flistxattr_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_removexattr) < 512,
                fscall_vfs_removexattr_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fremovexattr) < 512,
                fscall_vfs_fremovexattr_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_iommap) < 512,
                fscall_vfs_iommap_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mmap_create) < 512,
                fscall_vfs_mmap_create_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mmap_release_file) < 512,
                fscall_vfs_mmap_release_file_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mmap_change) < 512,
                fscall_vfs_mmap_change_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mmap_fill_page) < 512,
                fscall_vfs_mmap_fill_page_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mmap_fetch_page) < 512,
                fscall_vfs_mmap_fetch_page_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mmap_change_page) < 512,
                fscall_vfs_mmap_change_page_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_mmap_fallocate) < 512,
                fscall_vfs_mmap_fallocate_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_gfd_table_update) < 512,
                fscall_vfs_gfd_table_update_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_gfd_table_remove) < 512,
                fscall_vfs_gfd_table_remove_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_gfd_table_expand) < 512,
                fscall_vfs_gfd_table_expand_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_gfd_table_acquire) < 512,
                fscall_vfs_gfd_table_acquire_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_gfd_table_release) < 512,
                fscall_vfs_gfd_table_release_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_gfd_table_replace) < 512,
                fscall_vfs_gfd_table_replace_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_gfd_table_fault) < 512,
                fscall_vfs_gfd_table_fault_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_anon_register_devhost) < 512,
                fscall_vfs_anon_register_devhost_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_unused_fd) < 512,
                fscall_vfs_get_unused_fd_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_put_unused_fd) < 512,
                fscall_vfs_put_unused_fd_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_fd_info_update) < 512,
                fscall_vfs_fd_info_update_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_get_root_path) < 512,
                fscall_vfs_get_root_path_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_transfs_fget) < 512,
                fscall_vfs_transfs_fget_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_do_trans_fget) < 512,
                fscall_vfs_do_trans_fget_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_transfs_fput) < 512,
                fscall_vfs_transfs_fput_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_do_trans_fput) < 512,
                fscall_vfs_do_trans_fput_too_many_actvret_data);
raw_static_assert(sizeof(struct __actvret_fscall_vfs_read_mounts) < 512,
                fscall_vfs_read_mounts_too_many_actvret_data);
raw_static_assert(sizeof(union __actvret_fscall) < 512,
        fscall_too_many_actvret_data);
extern int __actvcall_fscall_procfs_create_data(unsigned long long __rpc_info, void *__buf, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);


extern int __actvcapcall_fscall_procfs_create_data(rref_t __rref, unsigned long long __rpc_info, void *__buf, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);


static inline int __attribute__((always_inline)) actvxactcall_fscall_procfs_create_data(bool is_xact_fwd, bool is_xact_allow_refwd, const char *pathname, unsigned int mode, struct procfs_ops_cb ops, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_procfs_create_data;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct procfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct procfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_procfs_create_data(rpc_info, ___void_buf, pathname, mode, ops);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_procfs_create_data(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, const char *pathname, unsigned int mode, struct procfs_ops_cb ops, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_procfs_create_data;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct procfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct procfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_procfs_create_data(__rref, rpc_info, ___void_buf, pathname, mode, ops);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_procfs_create_data(const char *pathname, unsigned int mode, struct procfs_ops_cb ops, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_procfs_create_data(false, false, pathname, mode, ops, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_procfs_create_data(rref_t __rref, const char *pathname, unsigned int mode, struct procfs_ops_cb ops, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_procfs_create_data(false, false, __rref, pathname, mode, ops, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_procfs_delete_data(unsigned long long __rpc_info, void *__buf, const char *pathname);


extern int __actvcapcall_fscall_procfs_delete_data(rref_t __rref, unsigned long long __rpc_info, void *__buf, const char *pathname);


static inline int __attribute__((always_inline)) actvxactcall_fscall_procfs_delete_data(bool is_xact_fwd, bool is_xact_allow_refwd, const char *pathname)
{
	const unsigned long __callno = __fs_method_procfs_delete_data;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_procfs_delete_data(rpc_info, NULL, pathname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_procfs_delete_data(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, const char *pathname)
{
	const unsigned long __callno = __fs_method_procfs_delete_data;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_procfs_delete_data(__rref, rpc_info, NULL, pathname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_procfs_delete_data(const char *pathname)
{
	return actvxactcall_fscall_procfs_delete_data(false, false, pathname);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_procfs_delete_data(rref_t __rref, const char *pathname)
{
	return actvxactcapcall_fscall_procfs_delete_data(false, false, __rref, pathname);
}

extern int __actvcall_fscall_procfs_get_process_fds(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);


extern int __actvcapcall_fscall_procfs_get_process_fds(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);


static inline int __attribute__((always_inline)) actvxactcall_fscall_procfs_get_process_fds(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	const unsigned long __callno = __fs_method_procfs_get_process_fds;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long*), __arch_actv_rpc_stksz_alignment(unsigned long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_procfs_get_process_fds(rpc_info, NULL, cnode_idx, bitmap, max_files);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_procfs_get_process_fds(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	const unsigned long __callno = __fs_method_procfs_get_process_fds;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long*), __arch_actv_rpc_stksz_alignment(unsigned long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_procfs_get_process_fds(__rref, rpc_info, NULL, cnode_idx, bitmap, max_files);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_procfs_get_process_fds(unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	return actvxactcall_fscall_procfs_get_process_fds(false, false, cnode_idx, bitmap, max_files);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_procfs_get_process_fds(rref_t __rref, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	return actvxactcapcall_fscall_procfs_get_process_fds(false, false, __rref, cnode_idx, bitmap, max_files);
}

extern int __actvcall_fscall_procfs_get_fd_mode(unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx);


extern int __actvcapcall_fscall_procfs_get_fd_mode(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_procfs_get_fd_mode(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int cnode_idx, struct __actvret_fscall_procfs_get_fd_mode *__ret)
{
	const unsigned long __callno = __fs_method_procfs_get_fd_mode;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_procfs_get_fd_mode(rpc_info, __ret, fd, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_procfs_get_fd_mode(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int cnode_idx, struct __actvret_fscall_procfs_get_fd_mode *__ret)
{
	const unsigned long __callno = __fs_method_procfs_get_fd_mode;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_procfs_get_fd_mode(__rref, rpc_info, __ret, fd, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_procfs_get_fd_mode(int fd, unsigned int cnode_idx, struct __actvret_fscall_procfs_get_fd_mode *__ret)
{
	return actvxactcall_fscall_procfs_get_fd_mode(false, false, fd, cnode_idx, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_procfs_get_fd_mode(rref_t __rref, int fd, unsigned int cnode_idx, struct __actvret_fscall_procfs_get_fd_mode *__ret)
{
	return actvxactcapcall_fscall_procfs_get_fd_mode(false, false, __rref, fd, cnode_idx, __ret);
}

extern int __actvcall_fscall_sysfs_create_file(unsigned long long __rpc_info, void *__buf, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);


extern int __actvcapcall_fscall_sysfs_create_file(rref_t __rref, unsigned long long __rpc_info, void *__buf, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);


static inline int __attribute__((always_inline)) actvxactcall_fscall_sysfs_create_file(bool is_xact_fwd, bool is_xact_allow_refwd, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	const unsigned long __callno = __fs_method_sysfs_create_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct sysfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_sysfs_create_file(rpc_info, NULL, pathname, mode, ops);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_sysfs_create_file(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	const unsigned long __callno = __fs_method_sysfs_create_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct sysfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_sysfs_create_file(__rref, rpc_info, NULL, pathname, mode, ops);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_sysfs_create_file(const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	return actvxactcall_fscall_sysfs_create_file(false, false, pathname, mode, ops);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_sysfs_create_file(rref_t __rref, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	return actvxactcapcall_fscall_sysfs_create_file(false, false, __rref, pathname, mode, ops);
}

extern int __actvcall_fscall_sysfs_create_dir(unsigned long long __rpc_info, void *__buf, const char *pathname, unsigned int mode);


extern int __actvcapcall_fscall_sysfs_create_dir(rref_t __rref, unsigned long long __rpc_info, void *__buf, const char *pathname, unsigned int mode);


static inline int __attribute__((always_inline)) actvxactcall_fscall_sysfs_create_dir(bool is_xact_fwd, bool is_xact_allow_refwd, const char *pathname, unsigned int mode)
{
	const unsigned long __callno = __fs_method_sysfs_create_dir;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_sysfs_create_dir(rpc_info, NULL, pathname, mode);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_sysfs_create_dir(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, const char *pathname, unsigned int mode)
{
	const unsigned long __callno = __fs_method_sysfs_create_dir;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_sysfs_create_dir(__rref, rpc_info, NULL, pathname, mode);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_sysfs_create_dir(const char *pathname, unsigned int mode)
{
	return actvxactcall_fscall_sysfs_create_dir(false, false, pathname, mode);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_sysfs_create_dir(rref_t __rref, const char *pathname, unsigned int mode)
{
	return actvxactcapcall_fscall_sysfs_create_dir(false, false, __rref, pathname, mode);
}

extern int __actvcall_fscall_sysfs_create_symlink(unsigned long long __rpc_info, void *__buf, const char *pathname, unsigned int mode);


extern int __actvcapcall_fscall_sysfs_create_symlink(rref_t __rref, unsigned long long __rpc_info, void *__buf, const char *pathname, unsigned int mode);


static inline int __attribute__((always_inline)) actvxactcall_fscall_sysfs_create_symlink(bool is_xact_fwd, bool is_xact_allow_refwd, const char *pathname, unsigned int mode, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_sysfs_create_symlink;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_sysfs_create_symlink(rpc_info, ___void_buf, pathname, mode);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_sysfs_create_symlink(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, const char *pathname, unsigned int mode, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_sysfs_create_symlink;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_sysfs_create_symlink(__rref, rpc_info, ___void_buf, pathname, mode);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_sysfs_create_symlink(const char *pathname, unsigned int mode, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_sysfs_create_symlink(false, false, pathname, mode, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_sysfs_create_symlink(rref_t __rref, const char *pathname, unsigned int mode, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_sysfs_create_symlink(false, false, __rref, pathname, mode, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_sysfs_delete(unsigned long long __rpc_info, void *__buf, const char *pathname);


extern int __actvcapcall_fscall_sysfs_delete(rref_t __rref, unsigned long long __rpc_info, void *__buf, const char *pathname);


static inline int __attribute__((always_inline)) actvxactcall_fscall_sysfs_delete(bool is_xact_fwd, bool is_xact_allow_refwd, const char *pathname, struct __actvret_fscall_sysfs_delete *__ret)
{
	const unsigned long __callno = __fs_method_sysfs_delete;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_sysfs_delete(rpc_info, __ret, pathname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_sysfs_delete(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, const char *pathname, struct __actvret_fscall_sysfs_delete *__ret)
{
	const unsigned long __callno = __fs_method_sysfs_delete;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_sysfs_delete(__rref, rpc_info, __ret, pathname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_sysfs_delete(const char *pathname, struct __actvret_fscall_sysfs_delete *__ret)
{
	return actvxactcall_fscall_sysfs_delete(false, false, pathname, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_sysfs_delete(rref_t __rref, const char *pathname, struct __actvret_fscall_sysfs_delete *__ret)
{
	return actvxactcapcall_fscall_sysfs_delete(false, false, __rref, pathname, __ret);
}

extern int __actvcall_fscall_sysfs_notify(unsigned long long __rpc_info, void *__buf);


extern int __actvcapcall_fscall_sysfs_notify(rref_t __rref, unsigned long long __rpc_info, void *__buf);


static inline int __attribute__((always_inline)) actvxactcall_fscall_sysfs_notify(bool is_xact_fwd, bool is_xact_allow_refwd, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_sysfs_notify;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_sysfs_notify(rpc_info, ___void_buf);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_sysfs_notify(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_sysfs_notify;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_sysfs_notify(__rref, rpc_info, ___void_buf);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_sysfs_notify(void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_sysfs_notify(false, false, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_sysfs_notify(rref_t __rref, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_sysfs_notify(false, false, __rref, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_clock_settime(unsigned long long __rpc_info, void *__buf, int fd, unsigned long tp);


extern int __actvcapcall_fscall_clock_settime(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long tp);


static inline int __attribute__((always_inline)) actvxactcall_fscall_clock_settime(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long tp)
{
	const unsigned long __callno = __fs_method_clock_settime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_clock_settime(rpc_info, NULL, fd, tp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_clock_settime(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long tp)
{
	const unsigned long __callno = __fs_method_clock_settime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_clock_settime(__rref, rpc_info, NULL, fd, tp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_clock_settime(int fd, unsigned long tp)
{
	return actvxactcall_fscall_clock_settime(false, false, fd, tp);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_clock_settime(rref_t __rref, int fd, unsigned long tp)
{
	return actvxactcapcall_fscall_clock_settime(false, false, __rref, fd, tp);
}

extern int __actvcall_fscall_clock_gettime(unsigned long long __rpc_info, void *__buf, int fd, unsigned long tp);


extern int __actvcapcall_fscall_clock_gettime(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long tp);


static inline int __attribute__((always_inline)) actvxactcall_fscall_clock_gettime(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long tp)
{
	const unsigned long __callno = __fs_method_clock_gettime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_clock_gettime(rpc_info, NULL, fd, tp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_clock_gettime(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long tp)
{
	const unsigned long __callno = __fs_method_clock_gettime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_clock_gettime(__rref, rpc_info, NULL, fd, tp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_clock_gettime(int fd, unsigned long tp)
{
	return actvxactcall_fscall_clock_gettime(false, false, fd, tp);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_clock_gettime(rref_t __rref, int fd, unsigned long tp)
{
	return actvxactcapcall_fscall_clock_gettime(false, false, __rref, fd, tp);
}

extern int __actvcall_fscall_clock_getres(unsigned long long __rpc_info, void *__buf, int fd, unsigned long tp);


extern int __actvcapcall_fscall_clock_getres(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long tp);


static inline int __attribute__((always_inline)) actvxactcall_fscall_clock_getres(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long tp)
{
	const unsigned long __callno = __fs_method_clock_getres;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_clock_getres(rpc_info, NULL, fd, tp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_clock_getres(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long tp)
{
	const unsigned long __callno = __fs_method_clock_getres;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_clock_getres(__rref, rpc_info, NULL, fd, tp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_clock_getres(int fd, unsigned long tp)
{
	return actvxactcall_fscall_clock_getres(false, false, fd, tp);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_clock_getres(rref_t __rref, int fd, unsigned long tp)
{
	return actvxactcapcall_fscall_clock_getres(false, false, __rref, fd, tp);
}

extern int __actvcall_fscall_clock_adjtime(unsigned long long __rpc_info, void *__buf, int fd, unsigned long tx);


extern int __actvcapcall_fscall_clock_adjtime(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long tx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_clock_adjtime(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long tx)
{
	const unsigned long __callno = __fs_method_clock_adjtime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_clock_adjtime(rpc_info, NULL, fd, tx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_clock_adjtime(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long tx)
{
	const unsigned long __callno = __fs_method_clock_adjtime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_clock_adjtime(__rref, rpc_info, NULL, fd, tx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_clock_adjtime(int fd, unsigned long tx)
{
	return actvxactcall_fscall_clock_adjtime(false, false, fd, tx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_clock_adjtime(rref_t __rref, int fd, unsigned long tx)
{
	return actvxactcapcall_fscall_clock_adjtime(false, false, __rref, fd, tx);
}

extern int __actvcall_fscall_inotify_init1(unsigned long long __rpc_info, void *__buf, int fd, unsigned int flags);


extern int __actvcapcall_fscall_inotify_init1(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_inotify_init1(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int flags)
{
	const unsigned long __callno = __fs_method_inotify_init1;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_inotify_init1(rpc_info, NULL, fd, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_inotify_init1(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int flags)
{
	const unsigned long __callno = __fs_method_inotify_init1;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_inotify_init1(__rref, rpc_info, NULL, fd, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_inotify_init1(int fd, unsigned int flags)
{
	return actvxactcall_fscall_inotify_init1(false, false, fd, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_inotify_init1(rref_t __rref, int fd, unsigned int flags)
{
	return actvxactcapcall_fscall_inotify_init1(false, false, __rref, fd, flags);
}

extern int __actvcall_fscall_inotify_add_watch(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int fd, unsigned int mask, int me_idx);


extern int __actvcapcall_fscall_inotify_add_watch(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int fd, unsigned int mask, int me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_inotify_add_watch(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int mask, int me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_inotify_add_watch *__ret)
{
	const unsigned long __callno = __fs_method_inotify_add_watch;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_inotify_add_watch(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, fd, mask, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_inotify_add_watch(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int mask, int me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_inotify_add_watch *__ret)
{
	const unsigned long __callno = __fs_method_inotify_add_watch;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_inotify_add_watch(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, fd, mask, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_inotify_add_watch(int fd, unsigned int mask, int me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_inotify_add_watch *__ret)
{
	return actvxactcall_fscall_inotify_add_watch(false, false, fd, mask, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_inotify_add_watch(rref_t __rref, int fd, unsigned int mask, int me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_inotify_add_watch *__ret)
{
	return actvxactcapcall_fscall_inotify_add_watch(false, false, __rref, fd, mask, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_inotify_rm_watch(unsigned long long __rpc_info, void *__buf, int fd, int wd);


extern int __actvcapcall_fscall_inotify_rm_watch(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, int wd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_inotify_rm_watch(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, int wd)
{
	const unsigned long __callno = __fs_method_inotify_rm_watch;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_inotify_rm_watch(rpc_info, NULL, fd, wd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_inotify_rm_watch(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, int wd)
{
	const unsigned long __callno = __fs_method_inotify_rm_watch;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_inotify_rm_watch(__rref, rpc_info, NULL, fd, wd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_inotify_rm_watch(int fd, int wd)
{
	return actvxactcall_fscall_inotify_rm_watch(false, false, fd, wd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_inotify_rm_watch(rref_t __rref, int fd, int wd)
{
	return actvxactcapcall_fscall_inotify_rm_watch(false, false, __rref, fd, wd);
}

extern int __actvcall_fscall_inotify_add_watch_internal(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);


extern int __actvcapcall_fscall_inotify_add_watch_internal(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);


static inline int __attribute__((always_inline)) actvxactcall_fscall_inotify_add_watch_internal(bool is_xact_fwd, bool is_xact_allow_refwd, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_inotify_add_watch_internal *__ret)
{
	const unsigned long __callno = __fs_method_inotify_add_watch_internal;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_inotify_add_watch_internal(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, me_idx, cnode_idx, nsid, pars, new_path, srvname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_inotify_add_watch_internal(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_inotify_add_watch_internal *__ret)
{
	const unsigned long __callno = __fs_method_inotify_add_watch_internal;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_inotify_add_watch_internal(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, me_idx, cnode_idx, nsid, pars, new_path, srvname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_inotify_add_watch_internal(int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_inotify_add_watch_internal *__ret)
{
	return actvxactcall_fscall_inotify_add_watch_internal(false, false, me_idx, cnode_idx, nsid, pars, new_path, srvname, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_inotify_add_watch_internal(rref_t __rref, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_inotify_add_watch_internal *__ret)
{
	return actvxactcapcall_fscall_inotify_add_watch_internal(false, false, __rref, me_idx, cnode_idx, nsid, pars, new_path, srvname, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_inotify_rm_watch_internal(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);


extern int __actvcapcall_fscall_inotify_rm_watch_internal(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);


static inline int __attribute__((always_inline)) actvxactcall_fscall_inotify_rm_watch_internal(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	const unsigned long __callno = __fs_method_inotify_rm_watch_internal;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_inotify_rm_watch_internal(rpc_info, NULL, cnode_idx, inotify_fd, wd, nsid, index, dev_id);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_inotify_rm_watch_internal(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	const unsigned long __callno = __fs_method_inotify_rm_watch_internal;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_inotify_rm_watch_internal(__rref, rpc_info, NULL, cnode_idx, inotify_fd, wd, nsid, index, dev_id);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_inotify_rm_watch_internal(unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	return actvxactcall_fscall_inotify_rm_watch_internal(false, false, cnode_idx, inotify_fd, wd, nsid, index, dev_id);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_inotify_rm_watch_internal(rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	return actvxactcapcall_fscall_inotify_rm_watch_internal(false, false, __rref, cnode_idx, inotify_fd, wd, nsid, index, dev_id);
}

extern int __actvcall_fscall_inotify_notify(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);


extern int __actvcapcall_fscall_inotify_notify(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);


static inline int __attribute__((always_inline)) actvxactcall_fscall_inotify_notify(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_inotify_notify;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_inotify_notify(rpc_info, ___void_buf, cnode_idx, inotify_fd, wd, event, cookie, token);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_inotify_notify(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_inotify_notify;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_inotify_notify(__rref, rpc_info, ___void_buf, cnode_idx, inotify_fd, wd, event, cookie, token);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_inotify_notify(unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_inotify_notify(false, false, cnode_idx, inotify_fd, wd, event, cookie, token, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_inotify_notify(rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_inotify_notify(false, false, __rref, cnode_idx, inotify_fd, wd, event, cookie, token, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_inotify_inode_destroyed(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);


extern int __actvcapcall_fscall_inotify_inode_destroyed(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);


static inline int __attribute__((always_inline)) actvxactcall_fscall_inotify_inode_destroyed(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	const unsigned long __callno = __fs_method_inotify_inode_destroyed;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_inotify_inode_destroyed(rpc_info, NULL, cnode_idx, inotify_fd, wd, token);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_inotify_inode_destroyed(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	const unsigned long __callno = __fs_method_inotify_inode_destroyed;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_inotify_inode_destroyed(__rref, rpc_info, NULL, cnode_idx, inotify_fd, wd, token);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_inotify_inode_destroyed(unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	return actvxactcall_fscall_inotify_inode_destroyed(false, false, cnode_idx, inotify_fd, wd, token);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_inotify_inode_destroyed(rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	return actvxactcapcall_fscall_inotify_inode_destroyed(false, false, __rref, cnode_idx, inotify_fd, wd, token);
}

extern int __actvcall_fscall_fanotify_init(unsigned long long __rpc_info, void *__buf, int fd, unsigned int flags);


extern int __actvcapcall_fscall_fanotify_init(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_fanotify_init(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int flags)
{
	const unsigned long __callno = __fs_method_fanotify_init;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_fanotify_init(rpc_info, NULL, fd, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_fanotify_init(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int flags)
{
	const unsigned long __callno = __fs_method_fanotify_init;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_fanotify_init(__rref, rpc_info, NULL, fd, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_fanotify_init(int fd, unsigned int flags)
{
	return actvxactcall_fscall_fanotify_init(false, false, fd, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_fanotify_init(rref_t __rref, int fd, unsigned int flags)
{
	return actvxactcapcall_fscall_fanotify_init(false, false, __rref, fd, flags);
}

extern int __actvcall_fscall_fanotify_mark(unsigned long long __rpc_info, void *__buf, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);


extern int __actvcapcall_fscall_fanotify_mark(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_fanotify_mark(bool is_xact_fwd, bool is_xact_allow_refwd, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_fanotify_mark;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint64_t), __arch_actv_rpc_stksz_alignment(uint64_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_fanotify_mark(rpc_info, ___void_buf, fanotify_fd, flags, mask, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_fanotify_mark(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_fanotify_mark;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint64_t), __arch_actv_rpc_stksz_alignment(uint64_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_fanotify_mark(__rref, rpc_info, ___void_buf, fanotify_fd, flags, mask, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_fanotify_mark(int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_fanotify_mark(false, false, fanotify_fd, flags, mask, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_fanotify_mark(rref_t __rref, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_fanotify_mark(false, false, __rref, fanotify_fd, flags, mask, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_fanotify_mark_internal(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);


extern int __actvcapcall_fscall_fanotify_mark_internal(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);


static inline int __attribute__((always_inline)) actvxactcall_fscall_fanotify_mark_internal(bool is_xact_fwd, bool is_xact_allow_refwd, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_fanotify_mark_internal *__ret)
{
	const unsigned long __callno = __fs_method_fanotify_mark_internal;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_fanotify_mark_internal(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, me_idx, cnode_idx, nsid, pars, new_path, srvname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_fanotify_mark_internal(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_fanotify_mark_internal *__ret)
{
	const unsigned long __callno = __fs_method_fanotify_mark_internal;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_fanotify_mark_internal(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, me_idx, cnode_idx, nsid, pars, new_path, srvname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_fanotify_mark_internal(int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_fanotify_mark_internal *__ret)
{
	return actvxactcall_fscall_fanotify_mark_internal(false, false, me_idx, cnode_idx, nsid, pars, new_path, srvname, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_fanotify_mark_internal(rref_t __rref, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_fanotify_mark_internal *__ret)
{
	return actvxactcapcall_fscall_fanotify_mark_internal(false, false, __rref, me_idx, cnode_idx, nsid, pars, new_path, srvname, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_fanotify_rm_watch_internal(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);


extern int __actvcapcall_fscall_fanotify_rm_watch_internal(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);


static inline int __attribute__((always_inline)) actvxactcall_fscall_fanotify_rm_watch_internal(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	const unsigned long __callno = __fs_method_fanotify_rm_watch_internal;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_fanotify_rm_watch_internal(rpc_info, NULL, cnode_idx, fanotify_fd, wd, nsid, index, dev_id, obj_type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_fanotify_rm_watch_internal(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	const unsigned long __callno = __fs_method_fanotify_rm_watch_internal;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_fanotify_rm_watch_internal(__rref, rpc_info, NULL, cnode_idx, fanotify_fd, wd, nsid, index, dev_id, obj_type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_fanotify_rm_watch_internal(unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	return actvxactcall_fscall_fanotify_rm_watch_internal(false, false, cnode_idx, fanotify_fd, wd, nsid, index, dev_id, obj_type);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_fanotify_rm_watch_internal(rref_t __rref, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	return actvxactcapcall_fscall_fanotify_rm_watch_internal(false, false, __rref, cnode_idx, fanotify_fd, wd, nsid, index, dev_id, obj_type);
}

extern int __actvcall_fscall_fanotify_notify(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);


extern int __actvcapcall_fscall_fanotify_notify(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);


static inline int __attribute__((always_inline)) actvxactcall_fscall_fanotify_notify(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_fanotify_notify;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_fanotify_notify(rpc_info, ___void_buf, cnode_idx, inotify_fd, wd, event, cookie, token, pid);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_fanotify_notify(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_fanotify_notify;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_fanotify_notify(__rref, rpc_info, ___void_buf, cnode_idx, inotify_fd, wd, event, cookie, token, pid);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_fanotify_notify(unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_fanotify_notify(false, false, cnode_idx, inotify_fd, wd, event, cookie, token, pid, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_fanotify_notify(rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_fanotify_notify(false, false, __rref, cnode_idx, inotify_fd, wd, event, cookie, token, pid, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_fanotify_destroyed(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);


extern int __actvcapcall_fscall_fanotify_destroyed(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);


static inline int __attribute__((always_inline)) actvxactcall_fscall_fanotify_destroyed(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	const unsigned long __callno = __fs_method_fanotify_destroyed;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_fanotify_destroyed(rpc_info, NULL, cnode_idx, inotify_fd, wd, token);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_fanotify_destroyed(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	const unsigned long __callno = __fs_method_fanotify_destroyed;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_fanotify_destroyed(__rref, rpc_info, NULL, cnode_idx, inotify_fd, wd, token);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_fanotify_destroyed(unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	return actvxactcall_fscall_fanotify_destroyed(false, false, cnode_idx, inotify_fd, wd, token);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_fanotify_destroyed(rref_t __rref, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	return actvxactcapcall_fscall_fanotify_destroyed(false, false, __rref, cnode_idx, inotify_fd, wd, token);
}

extern int __actvcall_fscall_fanotify_open(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_fanotify_open(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_fanotify_open(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_fanotify_open *__ret)
{
	const unsigned long __callno = __fs_method_fanotify_open;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_fanotify_open(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, dfd, fd, flags, mode, cnode_idx, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_fanotify_open(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_fanotify_open *__ret)
{
	const unsigned long __callno = __fs_method_fanotify_open;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_fanotify_open(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, dfd, fd, flags, mode, cnode_idx, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_fanotify_open(int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_fanotify_open *__ret)
{
	return actvxactcall_fscall_fanotify_open(false, false, dfd, fd, flags, mode, cnode_idx, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_fanotify_open(rref_t __rref, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_fanotify_open *__ret)
{
	return actvxactcapcall_fscall_fanotify_open(false, false, __rref, dfd, fd, flags, mode, cnode_idx, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_endio_io_done(unsigned long long __rpc_info, void *__buf, unsigned long long dev_id);


extern int __actvcapcall_fscall_endio_io_done(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned long long dev_id);


static inline int __attribute__((always_inline)) actvxactcall_fscall_endio_io_done(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned long long dev_id)
{
	const unsigned long __callno = __fs_method_endio_io_done;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_endio_io_done(rpc_info, NULL, dev_id);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_endio_io_done(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned long long dev_id)
{
	const unsigned long __callno = __fs_method_endio_io_done;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_endio_io_done(__rref, rpc_info, NULL, dev_id);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_endio_io_done(unsigned long long dev_id)
{
	return actvxactcall_fscall_endio_io_done(false, false, dev_id);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_endio_io_done(rref_t __rref, unsigned long long dev_id)
{
	return actvxactcapcall_fscall_endio_io_done(false, false, __rref, dev_id);
}

extern int __actvcall_fscall_vfs_set_label(unsigned long long __rpc_info, void *__buf, int fd, unsigned long long label);


extern int __actvcapcall_fscall_vfs_set_label(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long long label);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_set_label(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long long label)
{
	const unsigned long __callno = __fs_method_vfs_set_label;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_set_label(rpc_info, NULL, fd, label);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_set_label(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long long label)
{
	const unsigned long __callno = __fs_method_vfs_set_label;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_set_label(__rref, rpc_info, NULL, fd, label);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_set_label(int fd, unsigned long long label)
{
	return actvxactcall_fscall_vfs_set_label(false, false, fd, label);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_set_label(rref_t __rref, int fd, unsigned long long label)
{
	return actvxactcapcall_fscall_vfs_set_label(false, false, __rref, fd, label);
}

extern int __actvcall_fscall_vfs_set_label_by_path(unsigned long long __rpc_info, void *__buf, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_set_label_by_path(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_set_label_by_path(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_set_label_by_path;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_set_label_by_path(rpc_info, ___void_buf, dfd, label, flag, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_set_label_by_path(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_set_label_by_path;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_set_label_by_path(__rref, rpc_info, ___void_buf, dfd, label, flag, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_set_label_by_path(int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_set_label_by_path(false, false, dfd, label, flag, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_set_label_by_path(rref_t __rref, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_set_label_by_path(false, false, __rref, dfd, label, flag, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_get_label(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_get_label(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_label(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, struct __actvret_fscall_vfs_get_label *__ret)
{
	const unsigned long __callno = __fs_method_vfs_get_label;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_label(rpc_info, __ret, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_label(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, struct __actvret_fscall_vfs_get_label *__ret)
{
	const unsigned long __callno = __fs_method_vfs_get_label;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_label(__rref, rpc_info, __ret, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_label(int fd, struct __actvret_fscall_vfs_get_label *__ret)
{
	return actvxactcall_fscall_vfs_get_label(false, false, fd, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_label(rref_t __rref, int fd, struct __actvret_fscall_vfs_get_label *__ret)
{
	return actvxactcapcall_fscall_vfs_get_label(false, false, __rref, fd, __ret);
}

extern int __actvcall_fscall_vfs_init_audit(unsigned long long __rpc_info, void *__buf);


extern int __actvcapcall_fscall_vfs_init_audit(rref_t __rref, unsigned long long __rpc_info, void *__buf);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_init_audit(bool is_xact_fwd, bool is_xact_allow_refwd)
{
	const unsigned long __callno = __fs_method_vfs_init_audit;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_init_audit(rpc_info, NULL);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_init_audit(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref)
{
	const unsigned long __callno = __fs_method_vfs_init_audit;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_init_audit(__rref, rpc_info, NULL);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_init_audit(void)
{
	return actvxactcall_fscall_vfs_init_audit(false, false);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_init_audit(rref_t __rref)
{
	return actvxactcapcall_fscall_vfs_init_audit(false, false, __rref);
}

extern int __actvcall_fscall_vfs_add_audit_rule(unsigned long long __rpc_info, void *__buf, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_add_audit_rule(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_add_audit_rule(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_add_audit_rule;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_add_audit_rule(rpc_info, ___void_buf, dfd, shm_rule_id, shm_rule_num, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_add_audit_rule(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_add_audit_rule;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_add_audit_rule(__rref, rpc_info, ___void_buf, dfd, shm_rule_id, shm_rule_num, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_add_audit_rule(int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_add_audit_rule(false, false, dfd, shm_rule_id, shm_rule_num, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_add_audit_rule(rref_t __rref, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_add_audit_rule(false, false, __rref, dfd, shm_rule_id, shm_rule_num, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_del_audit_rule(unsigned long long __rpc_info, void *__buf, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_del_audit_rule(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_del_audit_rule(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_del_audit_rule;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_del_audit_rule(rpc_info, ___void_buf, dfd, rule_id, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_del_audit_rule(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_del_audit_rule;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_del_audit_rule(__rref, rpc_info, ___void_buf, dfd, rule_id, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_del_audit_rule(int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_del_audit_rule(false, false, dfd, rule_id, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_del_audit_rule(rref_t __rref, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_del_audit_rule(false, false, __rref, dfd, rule_id, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_match_audit_watch_file(unsigned long long __rpc_info, void *__buf, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);


extern int __actvcapcall_fscall_vfs_match_audit_watch_file(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_match_audit_watch_file(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	const unsigned long __callno = __fs_method_vfs_match_audit_watch_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_match_audit_watch_file(rpc_info, NULL, rule_id, dev_id, index);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_match_audit_watch_file(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	const unsigned long __callno = __fs_method_vfs_match_audit_watch_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_match_audit_watch_file(__rref, rpc_info, NULL, rule_id, dev_id, index);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_match_audit_watch_file(unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	return actvxactcall_fscall_vfs_match_audit_watch_file(false, false, rule_id, dev_id, index);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_match_audit_watch_file(rref_t __rref, unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	return actvxactcapcall_fscall_vfs_match_audit_watch_file(false, false, __rref, rule_id, dev_id, index);
}

extern int __actvcall_fscall_vfs_match_audit_watch_dir(unsigned long long __rpc_info, void *__buf, unsigned long long rule_id, int audit_me_idx);


extern int __actvcapcall_fscall_vfs_match_audit_watch_dir(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned long long rule_id, int audit_me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_match_audit_watch_dir(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned long long rule_id, int audit_me_idx)
{
	const unsigned long __callno = __fs_method_vfs_match_audit_watch_dir;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_match_audit_watch_dir(rpc_info, NULL, rule_id, audit_me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_match_audit_watch_dir(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned long long rule_id, int audit_me_idx)
{
	const unsigned long __callno = __fs_method_vfs_match_audit_watch_dir;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_match_audit_watch_dir(__rref, rpc_info, NULL, rule_id, audit_me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_match_audit_watch_dir(unsigned long long rule_id, int audit_me_idx)
{
	return actvxactcall_fscall_vfs_match_audit_watch_dir(false, false, rule_id, audit_me_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_match_audit_watch_dir(rref_t __rref, unsigned long long rule_id, int audit_me_idx)
{
	return actvxactcapcall_fscall_vfs_match_audit_watch_dir(false, false, __rref, rule_id, audit_me_idx);
}

extern int __actvcall_fscall_vfs_client_init(unsigned long long __rpc_info, void *__buf, uref_t uref, char *root_srvname, int buflen);


extern int __actvcapcall_fscall_vfs_client_init(rref_t __rref, unsigned long long __rpc_info, void *__buf, uref_t uref, char *root_srvname, int buflen);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_client_init(bool is_xact_fwd, bool is_xact_allow_refwd, uref_t uref, char *root_srvname, int buflen)
{
	const unsigned long __callno = __fs_method_vfs_client_init;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_client_init(rpc_info, NULL, uref, root_srvname, buflen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_client_init(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, uref_t uref, char *root_srvname, int buflen)
{
	const unsigned long __callno = __fs_method_vfs_client_init;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_client_init(__rref, rpc_info, NULL, uref, root_srvname, buflen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_client_init(uref_t uref, char *root_srvname, int buflen)
{
	return actvxactcall_fscall_vfs_client_init(false, false, uref, root_srvname, buflen);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_client_init(rref_t __rref, uref_t uref, char *root_srvname, int buflen)
{
	return actvxactcapcall_fscall_vfs_client_init(false, false, __rref, uref, root_srvname, buflen);
}

extern int __actvcall_fscall_vfs_bind_update(unsigned long long __rpc_info, void *__buf, uref_t uref1, uref_t uref2);


extern int __actvcapcall_fscall_vfs_bind_update(rref_t __rref, unsigned long long __rpc_info, void *__buf, uref_t uref1, uref_t uref2);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_bind_update(bool is_xact_fwd, bool is_xact_allow_refwd, uref_t uref1, uref_t uref2)
{
	const unsigned long __callno = __fs_method_vfs_bind_update;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_bind_update(rpc_info, NULL, uref1, uref2);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_bind_update(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, uref_t uref1, uref_t uref2)
{
	const unsigned long __callno = __fs_method_vfs_bind_update;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_bind_update(__rref, rpc_info, NULL, uref1, uref2);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_bind_update(uref_t uref1, uref_t uref2)
{
	return actvxactcall_fscall_vfs_bind_update(false, false, uref1, uref2);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_bind_update(rref_t __rref, uref_t uref1, uref_t uref2)
{
	return actvxactcapcall_fscall_vfs_bind_update(false, false, __rref, uref1, uref2);
}

extern int __actvcall_fscall_vfs_clone(unsigned long long __rpc_info, void *__buf, int old_fd, int new_fd);


extern int __actvcapcall_fscall_vfs_clone(rref_t __rref, unsigned long long __rpc_info, void *__buf, int old_fd, int new_fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_clone(bool is_xact_fwd, bool is_xact_allow_refwd, int old_fd, int new_fd)
{
	const unsigned long __callno = __fs_method_vfs_clone;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_clone(rpc_info, NULL, old_fd, new_fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_clone(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int old_fd, int new_fd)
{
	const unsigned long __callno = __fs_method_vfs_clone;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_clone(__rref, rpc_info, NULL, old_fd, new_fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_clone(int old_fd, int new_fd)
{
	return actvxactcall_fscall_vfs_clone(false, false, old_fd, new_fd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_clone(rref_t __rref, int old_fd, int new_fd)
{
	return actvxactcapcall_fscall_vfs_clone(false, false, __rref, old_fd, new_fd);
}

extern int __actvcall_fscall_vfs_close(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_close(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_close(bool is_xact_fwd, bool is_xact_allow_refwd, int fd)
{
	const unsigned long __callno = __fs_method_vfs_close;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_close(rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_close(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd)
{
	const unsigned long __callno = __fs_method_vfs_close;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_close(__rref, rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_close(int fd)
{
	return actvxactcall_fscall_vfs_close(false, false, fd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_close(rref_t __rref, int fd)
{
	return actvxactcapcall_fscall_vfs_close(false, false, __rref, fd);
}

extern int __actvcall_fscall_vfs_mount(unsigned long long __rpc_info, void *__buf, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_mount(rref_t __rref, unsigned long long __rpc_info, void *__buf, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mount(bool is_xact_fwd, bool is_xact_allow_refwd, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_mount;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mount(rpc_info, ___void_buf, parent_fd, dev_id, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mount(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_mount;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mount(__rref, rpc_info, ___void_buf, parent_fd, dev_id, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mount(int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_mount(false, false, parent_fd, dev_id, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mount(rref_t __rref, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_mount(false, false, __rref, parent_fd, dev_id, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_clone_mount_entry(unsigned long long __rpc_info, void *__buf, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);


extern int __actvcapcall_fscall_vfs_clone_mount_entry(rref_t __rref, unsigned long long __rpc_info, void *__buf, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_clone_mount_entry(bool is_xact_fwd, bool is_xact_allow_refwd, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	const unsigned long __callno = __fs_method_vfs_clone_mount_entry;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_clone_mount_entry(rpc_info, NULL, dst, dst_len, flags, cnode_idx, child_me_idx, orig_me_idx, orig_fd, recurse);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_clone_mount_entry(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	const unsigned long __callno = __fs_method_vfs_clone_mount_entry;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_clone_mount_entry(__rref, rpc_info, NULL, dst, dst_len, flags, cnode_idx, child_me_idx, orig_me_idx, orig_fd, recurse);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_clone_mount_entry(const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	return actvxactcall_fscall_vfs_clone_mount_entry(false, false, dst, dst_len, flags, cnode_idx, child_me_idx, orig_me_idx, orig_fd, recurse);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_clone_mount_entry(rref_t __rref, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	return actvxactcapcall_fscall_vfs_clone_mount_entry(false, false, __rref, dst, dst_len, flags, cnode_idx, child_me_idx, orig_me_idx, orig_fd, recurse);
}

extern int __actvcall_fscall_vfs_clone_mount_entry_from_orig_parent(unsigned long long __rpc_info, void *__buf, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);


extern int __actvcapcall_fscall_vfs_clone_mount_entry_from_orig_parent(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_clone_mount_entry_from_orig_parent(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_clone_mount_entry_from_orig_parent;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_clone_mount_entry_from_orig_parent(rpc_info, ___void_buf, nsid, parent_me_idx, orig_me_idx, dev_id, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_clone_mount_entry_from_orig_parent(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_clone_mount_entry_from_orig_parent;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_clone_mount_entry_from_orig_parent(__rref, rpc_info, ___void_buf, nsid, parent_me_idx, orig_me_idx, dev_id, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_clone_mount_entry_from_orig_parent(unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_clone_mount_entry_from_orig_parent(false, false, nsid, parent_me_idx, orig_me_idx, dev_id, flags, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_clone_mount_entry_from_orig_parent(rref_t __rref, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_clone_mount_entry_from_orig_parent(false, false, __rref, nsid, parent_me_idx, orig_me_idx, dev_id, flags, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long __rpc_info, void *__buf, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);


extern int __actvcapcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	const unsigned long __callno = __fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(rpc_info, NULL, nsid, orig_parent_me_idx, child_me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	const unsigned long __callno = __fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(__rref, rpc_info, NULL, nsid, orig_parent_me_idx, child_me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	return actvxactcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(false, false, nsid, orig_parent_me_idx, child_me_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(rref_t __rref, unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	return actvxactcapcall_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent(false, false, __rref, nsid, orig_parent_me_idx, child_me_idx);
}

extern int __actvcall_fscall_vfs_destroy_cloned_mount_entry(unsigned long long __rpc_info, void *__buf, int me_idx);


extern int __actvcapcall_fscall_vfs_destroy_cloned_mount_entry(rref_t __rref, unsigned long long __rpc_info, void *__buf, int me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_destroy_cloned_mount_entry(bool is_xact_fwd, bool is_xact_allow_refwd, int me_idx)
{
	const unsigned long __callno = __fs_method_vfs_destroy_cloned_mount_entry;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_destroy_cloned_mount_entry(rpc_info, NULL, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_destroy_cloned_mount_entry(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int me_idx)
{
	const unsigned long __callno = __fs_method_vfs_destroy_cloned_mount_entry;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_destroy_cloned_mount_entry(__rref, rpc_info, NULL, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_destroy_cloned_mount_entry(int me_idx)
{
	return actvxactcall_fscall_vfs_destroy_cloned_mount_entry(false, false, me_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_destroy_cloned_mount_entry(rref_t __rref, int me_idx)
{
	return actvxactcapcall_fscall_vfs_destroy_cloned_mount_entry(false, false, __rref, me_idx);
}

extern int __actvcall_fscall_vfs_check_mount(unsigned long long __rpc_info, void *__buf, int me_idx, int fd, int is_dir);


extern int __actvcapcall_fscall_vfs_check_mount(rref_t __rref, unsigned long long __rpc_info, void *__buf, int me_idx, int fd, int is_dir);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_check_mount(bool is_xact_fwd, bool is_xact_allow_refwd, int me_idx, int fd, int is_dir)
{
	const unsigned long __callno = __fs_method_vfs_check_mount;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_check_mount(rpc_info, NULL, me_idx, fd, is_dir);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_check_mount(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int me_idx, int fd, int is_dir)
{
	const unsigned long __callno = __fs_method_vfs_check_mount;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_check_mount(__rref, rpc_info, NULL, me_idx, fd, is_dir);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_check_mount(int me_idx, int fd, int is_dir)
{
	return actvxactcall_fscall_vfs_check_mount(false, false, me_idx, fd, is_dir);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_check_mount(rref_t __rref, int me_idx, int fd, int is_dir)
{
	return actvxactcapcall_fscall_vfs_check_mount(false, false, __rref, me_idx, fd, is_dir);
}

extern int __actvcall_fscall_vfs_mountpoint_del_mount(unsigned long long __rpc_info, void *__buf, void *mp, int me_idx, unsigned int nsid);


extern int __actvcapcall_fscall_vfs_mountpoint_del_mount(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *mp, int me_idx, unsigned int nsid);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mountpoint_del_mount(bool is_xact_fwd, bool is_xact_allow_refwd, void *mp, int me_idx, unsigned int nsid)
{
	const unsigned long __callno = __fs_method_vfs_mountpoint_del_mount;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mountpoint_del_mount(rpc_info, NULL, mp, me_idx, nsid);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mountpoint_del_mount(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, void *mp, int me_idx, unsigned int nsid)
{
	const unsigned long __callno = __fs_method_vfs_mountpoint_del_mount;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mountpoint_del_mount(__rref, rpc_info, NULL, mp, me_idx, nsid);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mountpoint_del_mount(void *mp, int me_idx, unsigned int nsid)
{
	return actvxactcall_fscall_vfs_mountpoint_del_mount(false, false, mp, me_idx, nsid);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mountpoint_del_mount(rref_t __rref, void *mp, int me_idx, unsigned int nsid)
{
	return actvxactcapcall_fscall_vfs_mountpoint_del_mount(false, false, __rref, mp, me_idx, nsid);
}

extern int __actvcall_fscall_vfs_open(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_open(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_open(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_open *__ret)
{
	const unsigned long __callno = __fs_method_vfs_open;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_open(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, cnode_idx, dfd, fd, flags, mode, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_open(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_open *__ret)
{
	const unsigned long __callno = __fs_method_vfs_open;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_open(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, cnode_idx, dfd, fd, flags, mode, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_open(unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_open *__ret)
{
	return actvxactcall_fscall_vfs_open(false, false, cnode_idx, dfd, fd, flags, mode, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_open(rref_t __rref, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_open *__ret)
{
	return actvxactcapcall_fscall_vfs_open(false, false, __rref, cnode_idx, dfd, fd, flags, mode, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_vfs_ftruncate(unsigned long long __rpc_info, void *__buf, int fd, unsigned long long length);


extern int __actvcapcall_fscall_vfs_ftruncate(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long long length);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_ftruncate(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long long length)
{
	const unsigned long __callno = __fs_method_vfs_ftruncate;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_ftruncate(rpc_info, NULL, fd, length);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_ftruncate(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long long length)
{
	const unsigned long __callno = __fs_method_vfs_ftruncate;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_ftruncate(__rref, rpc_info, NULL, fd, length);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_ftruncate(int fd, unsigned long long length)
{
	return actvxactcall_fscall_vfs_ftruncate(false, false, fd, length);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_ftruncate(rref_t __rref, int fd, unsigned long long length)
{
	return actvxactcapcall_fscall_vfs_ftruncate(false, false, __rref, fd, length);
}

extern int __actvcall_fscall_vfs_fstat(unsigned long long __rpc_info, void *__buf, int fd, void *st);


extern int __actvcapcall_fscall_vfs_fstat(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, void *st);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fstat(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, void *st)
{
	const unsigned long __callno = __fs_method_vfs_fstat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fstat(rpc_info, NULL, fd, st);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fstat(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, void *st)
{
	const unsigned long __callno = __fs_method_vfs_fstat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fstat(__rref, rpc_info, NULL, fd, st);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fstat(int fd, void *st)
{
	return actvxactcall_fscall_vfs_fstat(false, false, fd, st);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fstat(rref_t __rref, int fd, void *st)
{
	return actvxactcapcall_fscall_vfs_fstat(false, false, __rref, fd, st);
}

extern int __actvcall_fscall_vfs_stat(unsigned long long __rpc_info, void *__buf, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_stat(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_stat(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_stat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_stat(rpc_info, ___void_buf, dfd, flag, st, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_stat(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_stat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_stat(__rref, rpc_info, ___void_buf, dfd, flag, st, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_stat(int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_stat(false, false, dfd, flag, st, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_stat(rref_t __rref, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_stat(false, false, __rref, dfd, flag, st, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_statfs(unsigned long long __rpc_info, void *__buf, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_statfs(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_statfs(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_statfs;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_statfs(rpc_info, ___void_buf, dfd, stfs, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_statfs(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_statfs;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_statfs(__rref, rpc_info, ___void_buf, dfd, stfs, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_statfs(int dfd, void *stfs, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_statfs(false, false, dfd, stfs, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_statfs(rref_t __rref, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_statfs(false, false, __rref, dfd, stfs, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_fstatfs(unsigned long long __rpc_info, void *__buf, int fd, void *msg);


extern int __actvcapcall_fscall_vfs_fstatfs(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, void *msg);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fstatfs(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, void *msg)
{
	const unsigned long __callno = __fs_method_vfs_fstatfs;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fstatfs(rpc_info, NULL, fd, msg);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fstatfs(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, void *msg)
{
	const unsigned long __callno = __fs_method_vfs_fstatfs;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fstatfs(__rref, rpc_info, NULL, fd, msg);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fstatfs(int fd, void *msg)
{
	return actvxactcall_fscall_vfs_fstatfs(false, false, fd, msg);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fstatfs(rref_t __rref, int fd, void *msg)
{
	return actvxactcapcall_fscall_vfs_fstatfs(false, false, __rref, fd, msg);
}

extern int __actvcall_fscall_vfs_fsync(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_fsync(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fsync(bool is_xact_fwd, bool is_xact_allow_refwd, int fd)
{
	const unsigned long __callno = __fs_method_vfs_fsync;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fsync(rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fsync(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd)
{
	const unsigned long __callno = __fs_method_vfs_fsync;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fsync(__rref, rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fsync(int fd)
{
	return actvxactcall_fscall_vfs_fsync(false, false, fd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fsync(rref_t __rref, int fd)
{
	return actvxactcapcall_fscall_vfs_fsync(false, false, __rref, fd);
}

extern int __actvcall_fscall_vfs_unmount(unsigned long long __rpc_info, void *__buf, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_unmount(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_unmount(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_unmount;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_unmount(rpc_info, ___void_buf, fd, flags, msg, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_unmount(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_unmount;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_unmount(__rref, rpc_info, ___void_buf, fd, flags, msg, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_unmount(int fd, unsigned int flags, char *msg, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_unmount(false, false, fd, flags, msg, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_unmount(rref_t __rref, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_unmount(false, false, __rref, fd, flags, msg, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_unmount_from_server(unsigned long long __rpc_info, void *__buf, int me_idx, uint32_t nsid, unsigned int flags);


extern int __actvcapcall_fscall_vfs_unmount_from_server(rref_t __rref, unsigned long long __rpc_info, void *__buf, int me_idx, uint32_t nsid, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_unmount_from_server(bool is_xact_fwd, bool is_xact_allow_refwd, int me_idx, uint32_t nsid, unsigned int flags)
{
	const unsigned long __callno = __fs_method_vfs_unmount_from_server;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_unmount_from_server(rpc_info, NULL, me_idx, nsid, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_unmount_from_server(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int me_idx, uint32_t nsid, unsigned int flags)
{
	const unsigned long __callno = __fs_method_vfs_unmount_from_server;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_unmount_from_server(__rref, rpc_info, NULL, me_idx, nsid, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_unmount_from_server(int me_idx, uint32_t nsid, unsigned int flags)
{
	return actvxactcall_fscall_vfs_unmount_from_server(false, false, me_idx, nsid, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_unmount_from_server(rref_t __rref, int me_idx, uint32_t nsid, unsigned int flags)
{
	return actvxactcapcall_fscall_vfs_unmount_from_server(false, false, __rref, me_idx, nsid, flags);
}

extern int __actvcall_fscall_vfs_unmount_child(unsigned long long __rpc_info, void *__buf, int me_idx, uint32_t nsid, unsigned int flags);


extern int __actvcapcall_fscall_vfs_unmount_child(rref_t __rref, unsigned long long __rpc_info, void *__buf, int me_idx, uint32_t nsid, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_unmount_child(bool is_xact_fwd, bool is_xact_allow_refwd, int me_idx, uint32_t nsid, unsigned int flags)
{
	const unsigned long __callno = __fs_method_vfs_unmount_child;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_unmount_child(rpc_info, NULL, me_idx, nsid, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_unmount_child(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int me_idx, uint32_t nsid, unsigned int flags)
{
	const unsigned long __callno = __fs_method_vfs_unmount_child;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_unmount_child(__rref, rpc_info, NULL, me_idx, nsid, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_unmount_child(int me_idx, uint32_t nsid, unsigned int flags)
{
	return actvxactcall_fscall_vfs_unmount_child(false, false, me_idx, nsid, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_unmount_child(rref_t __rref, int me_idx, uint32_t nsid, unsigned int flags)
{
	return actvxactcapcall_fscall_vfs_unmount_child(false, false, __rref, me_idx, nsid, flags);
}

extern int __actvcall_fscall_vfs_truncate(unsigned long long __rpc_info, void *__buf, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_truncate(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_truncate(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_truncate;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_truncate(rpc_info, ___void_buf, dfd, length, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_truncate(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_truncate;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_truncate(__rref, rpc_info, ___void_buf, dfd, length, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_truncate(int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_truncate(false, false, dfd, length, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_truncate(rref_t __rref, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_truncate(false, false, __rref, dfd, length, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_fs_fork(unsigned long long __rpc_info, void *__buf, int fd, unsigned int idx_src, unsigned int idx_dst);


extern int __actvcapcall_fscall_vfs_fs_fork(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int idx_src, unsigned int idx_dst);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fs_fork(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int idx_src, unsigned int idx_dst)
{
	const unsigned long __callno = __fs_method_vfs_fs_fork;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fs_fork(rpc_info, NULL, fd, idx_src, idx_dst);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fs_fork(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int idx_src, unsigned int idx_dst)
{
	const unsigned long __callno = __fs_method_vfs_fs_fork;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fs_fork(__rref, rpc_info, NULL, fd, idx_src, idx_dst);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fs_fork(int fd, unsigned int idx_src, unsigned int idx_dst)
{
	return actvxactcall_fscall_vfs_fs_fork(false, false, fd, idx_src, idx_dst);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fs_fork(rref_t __rref, int fd, unsigned int idx_src, unsigned int idx_dst)
{
	return actvxactcapcall_fscall_vfs_fs_fork(false, false, __rref, fd, idx_src, idx_dst);
}

extern int __actvcall_fscall_vfs_query_info(unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_query_info(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_query_info(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int cnode_idx, struct __actvret_fscall_vfs_query_info *__ret)
{
	const unsigned long __callno = __fs_method_vfs_query_info;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_query_info(rpc_info, __ret, fd, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_query_info(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int cnode_idx, struct __actvret_fscall_vfs_query_info *__ret)
{
	const unsigned long __callno = __fs_method_vfs_query_info;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_query_info(__rref, rpc_info, __ret, fd, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_query_info(int fd, unsigned int cnode_idx, struct __actvret_fscall_vfs_query_info *__ret)
{
	return actvxactcall_fscall_vfs_query_info(false, false, fd, cnode_idx, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_query_info(rref_t __rref, int fd, unsigned int cnode_idx, struct __actvret_fscall_vfs_query_info *__ret)
{
	return actvxactcapcall_fscall_vfs_query_info(false, false, __rref, fd, cnode_idx, __ret);
}

extern int __actvcall_fscall_vfs_lseek(unsigned long long __rpc_info, void *__buf, int fd, long long offset, int whence);


extern int __actvcapcall_fscall_vfs_lseek(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, long long offset, int whence);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_lseek(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, long long offset, int whence, struct __actvret_fscall_vfs_lseek *__ret)
{
	const unsigned long __callno = __fs_method_vfs_lseek;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_lseek(rpc_info, __ret, fd, offset, whence);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_lseek(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, long long offset, int whence, struct __actvret_fscall_vfs_lseek *__ret)
{
	const unsigned long __callno = __fs_method_vfs_lseek;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_lseek(__rref, rpc_info, __ret, fd, offset, whence);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_lseek(int fd, long long offset, int whence, struct __actvret_fscall_vfs_lseek *__ret)
{
	return actvxactcall_fscall_vfs_lseek(false, false, fd, offset, whence, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_lseek(rref_t __rref, int fd, long long offset, int whence, struct __actvret_fscall_vfs_lseek *__ret)
{
	return actvxactcapcall_fscall_vfs_lseek(false, false, __rref, fd, offset, whence, __ret);
}

extern int __actvcall_fscall_vfs_trans(unsigned long long __rpc_info, void *__buf, int fd, const char *data, int pos, size_t nbyte);


extern int __actvcapcall_fscall_vfs_trans(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const char *data, int pos, size_t nbyte);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_trans(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const char *data, int pos, size_t nbyte)
{
	const unsigned long __callno = __fs_method_vfs_trans;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_trans(rpc_info, NULL, fd, data, pos, nbyte);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_trans(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const char *data, int pos, size_t nbyte)
{
	const unsigned long __callno = __fs_method_vfs_trans;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_trans(__rref, rpc_info, NULL, fd, data, pos, nbyte);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_trans(int fd, const char *data, int pos, size_t nbyte)
{
	return actvxactcall_fscall_vfs_trans(false, false, fd, data, pos, nbyte);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_trans(rref_t __rref, int fd, const char *data, int pos, size_t nbyte)
{
	return actvxactcapcall_fscall_vfs_trans(false, false, __rref, fd, data, pos, nbyte);
}

extern int __actvcall_fscall_vfs_pipe2(unsigned long long __rpc_info, void *__buf, int read_fd, int write_fd, int flags);


extern int __actvcapcall_fscall_vfs_pipe2(rref_t __rref, unsigned long long __rpc_info, void *__buf, int read_fd, int write_fd, int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_pipe2(bool is_xact_fwd, bool is_xact_allow_refwd, int read_fd, int write_fd, int flags, struct __actvret_fscall_vfs_pipe2 *__ret)
{
	const unsigned long __callno = __fs_method_vfs_pipe2;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_pipe2(rpc_info, __ret, read_fd, write_fd, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_pipe2(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int read_fd, int write_fd, int flags, struct __actvret_fscall_vfs_pipe2 *__ret)
{
	const unsigned long __callno = __fs_method_vfs_pipe2;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_pipe2(__rref, rpc_info, __ret, read_fd, write_fd, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_pipe2(int read_fd, int write_fd, int flags, struct __actvret_fscall_vfs_pipe2 *__ret)
{
	return actvxactcall_fscall_vfs_pipe2(false, false, read_fd, write_fd, flags, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_pipe2(rref_t __rref, int read_fd, int write_fd, int flags, struct __actvret_fscall_vfs_pipe2 *__ret)
{
	return actvxactcapcall_fscall_vfs_pipe2(false, false, __rref, read_fd, write_fd, flags, __ret);
}

extern int __actvcall_fscall_vfs_tee(unsigned long long __rpc_info, void *__buf, int fd_in, int fd_out, unsigned int len, unsigned int flags);


extern int __actvcapcall_fscall_vfs_tee(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd_in, int fd_out, unsigned int len, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_tee(bool is_xact_fwd, bool is_xact_allow_refwd, int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	const unsigned long __callno = __fs_method_vfs_tee;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_tee(rpc_info, NULL, fd_in, fd_out, len, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_tee(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	const unsigned long __callno = __fs_method_vfs_tee;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_tee(__rref, rpc_info, NULL, fd_in, fd_out, len, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_tee(int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	return actvxactcall_fscall_vfs_tee(false, false, fd_in, fd_out, len, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_tee(rref_t __rref, int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	return actvxactcapcall_fscall_vfs_tee(false, false, __rref, fd_in, fd_out, len, flags);
}

extern int __actvcall_fscall_vfs_splice(unsigned long long __rpc_info, void *__buf, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);


extern int __actvcapcall_fscall_vfs_splice(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_splice(bool is_xact_fwd, bool is_xact_allow_refwd, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags, struct __actvret_fscall_vfs_splice *__ret)
{
	const unsigned long __callno = __fs_method_vfs_splice;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_splice(rpc_info, __ret, fd_in, offset_in, fd_out, pathname, multi_srvs, offset_out, len, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_splice(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags, struct __actvret_fscall_vfs_splice *__ret)
{
	const unsigned long __callno = __fs_method_vfs_splice;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_splice(__rref, rpc_info, __ret, fd_in, offset_in, fd_out, pathname, multi_srvs, offset_out, len, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_splice(int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags, struct __actvret_fscall_vfs_splice *__ret)
{
	return actvxactcall_fscall_vfs_splice(false, false, fd_in, offset_in, fd_out, pathname, multi_srvs, offset_out, len, flags, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_splice(rref_t __rref, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags, struct __actvret_fscall_vfs_splice *__ret)
{
	return actvxactcapcall_fscall_vfs_splice(false, false, __rref, fd_in, offset_in, fd_out, pathname, multi_srvs, offset_out, len, flags, __ret);
}

extern int __actvcall_fscall_vfs_do_splice_srvs(unsigned long long __rpc_info, void *__buf, int fd, long long pos, const char *buf, unsigned long len);


extern int __actvcapcall_fscall_vfs_do_splice_srvs(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, long long pos, const char *buf, unsigned long len);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_do_splice_srvs(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, long long pos, const char *buf, unsigned long len, struct __actvret_fscall_vfs_do_splice_srvs *__ret)
{
	const unsigned long __callno = __fs_method_vfs_do_splice_srvs;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_do_splice_srvs(rpc_info, __ret, fd, pos, buf, len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_do_splice_srvs(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, long long pos, const char *buf, unsigned long len, struct __actvret_fscall_vfs_do_splice_srvs *__ret)
{
	const unsigned long __callno = __fs_method_vfs_do_splice_srvs;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_do_splice_srvs(__rref, rpc_info, __ret, fd, pos, buf, len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_do_splice_srvs(int fd, long long pos, const char *buf, unsigned long len, struct __actvret_fscall_vfs_do_splice_srvs *__ret)
{
	return actvxactcall_fscall_vfs_do_splice_srvs(false, false, fd, pos, buf, len, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_do_splice_srvs(rref_t __rref, int fd, long long pos, const char *buf, unsigned long len, struct __actvret_fscall_vfs_do_splice_srvs *__ret)
{
	return actvxactcapcall_fscall_vfs_do_splice_srvs(false, false, __rref, fd, pos, buf, len, __ret);
}

extern int __actvcall_fscall_vfs_revoke_process(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_revoke_process(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_revoke_process(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_revoke_process;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_revoke_process(rpc_info, NULL, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_revoke_process(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_revoke_process;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_revoke_process(__rref, rpc_info, NULL, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_revoke_process(unsigned int cnode_idx)
{
	return actvxactcall_fscall_vfs_revoke_process(false, false, cnode_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_revoke_process(rref_t __rref, unsigned int cnode_idx)
{
	return actvxactcapcall_fscall_vfs_revoke_process(false, false, __rref, cnode_idx);
}

extern int __actvcall_fscall_vfs_setrlimit(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);


extern int __actvcapcall_fscall_vfs_setrlimit(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_setrlimit(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	const unsigned long __callno = __fs_method_vfs_setrlimit;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_setrlimit(rpc_info, NULL, cnode_idx, rlim_cur, rlim_max, type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_setrlimit(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	const unsigned long __callno = __fs_method_vfs_setrlimit;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_setrlimit(__rref, rpc_info, NULL, cnode_idx, rlim_cur, rlim_max, type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_setrlimit(unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	return actvxactcall_fscall_vfs_setrlimit(false, false, cnode_idx, rlim_cur, rlim_max, type);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_setrlimit(rref_t __rref, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	return actvxactcapcall_fscall_vfs_setrlimit(false, false, __rref, cnode_idx, rlim_cur, rlim_max, type);
}

extern int __actvcall_fscall_vfs_get_ns(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);


extern int __actvcapcall_fscall_vfs_get_ns(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_ns(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags, struct __actvret_fscall_vfs_get_ns *__ret)
{
	const unsigned long __callno = __fs_method_vfs_get_ns;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_ns(rpc_info, __ret, cnode_idx, oldid, newid, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_ns(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags, struct __actvret_fscall_vfs_get_ns *__ret)
{
	const unsigned long __callno = __fs_method_vfs_get_ns;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_ns(__rref, rpc_info, __ret, cnode_idx, oldid, newid, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_ns(unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags, struct __actvret_fscall_vfs_get_ns *__ret)
{
	return actvxactcall_fscall_vfs_get_ns(false, false, cnode_idx, oldid, newid, flags, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_ns(rref_t __rref, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags, struct __actvret_fscall_vfs_get_ns *__ret)
{
	return actvxactcapcall_fscall_vfs_get_ns(false, false, __rref, cnode_idx, oldid, newid, flags, __ret);
}

extern int __actvcall_fscall_vfs_put_ns(unsigned long long __rpc_info, void *__buf, unsigned int nsid, int me_idx, int flags);


extern int __actvcapcall_fscall_vfs_put_ns(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int nsid, int me_idx, int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_put_ns(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int nsid, int me_idx, int flags)
{
	const unsigned long __callno = __fs_method_vfs_put_ns;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_put_ns(rpc_info, NULL, nsid, me_idx, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_put_ns(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int nsid, int me_idx, int flags)
{
	const unsigned long __callno = __fs_method_vfs_put_ns;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_put_ns(__rref, rpc_info, NULL, nsid, me_idx, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_put_ns(unsigned int nsid, int me_idx, int flags)
{
	return actvxactcall_fscall_vfs_put_ns(false, false, nsid, me_idx, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_put_ns(rref_t __rref, unsigned int nsid, int me_idx, int flags)
{
	return actvxactcapcall_fscall_vfs_put_ns(false, false, __rref, nsid, me_idx, flags);
}

extern int __actvcall_fscall_vfs_init_eventfd(unsigned long long __rpc_info, void *__buf, int fd, unsigned int count, int flags);


extern int __actvcapcall_fscall_vfs_init_eventfd(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int count, int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_init_eventfd(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int count, int flags)
{
	const unsigned long __callno = __fs_method_vfs_init_eventfd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_init_eventfd(rpc_info, NULL, fd, count, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_init_eventfd(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int count, int flags)
{
	const unsigned long __callno = __fs_method_vfs_init_eventfd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_init_eventfd(__rref, rpc_info, NULL, fd, count, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_init_eventfd(int fd, unsigned int count, int flags)
{
	return actvxactcall_fscall_vfs_init_eventfd(false, false, fd, count, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_init_eventfd(rref_t __rref, int fd, unsigned int count, int flags)
{
	return actvxactcapcall_fscall_vfs_init_eventfd(false, false, __rref, fd, count, flags);
}

extern int __actvcall_fscall_vfs_write_eventfd(unsigned long long __rpc_info, void *__buf, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_write_eventfd(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_write_eventfd(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_write_eventfd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_write_eventfd(rpc_info, NULL, fd, buf, buf_len, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_write_eventfd(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_write_eventfd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_write_eventfd(__rref, rpc_info, NULL, fd, buf, buf_len, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_write_eventfd(int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	return actvxactcall_fscall_vfs_write_eventfd(false, false, fd, buf, buf_len, cnode_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_write_eventfd(rref_t __rref, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	return actvxactcapcall_fscall_vfs_write_eventfd(false, false, __rref, fd, buf, buf_len, cnode_idx);
}

extern int __actvcall_fscall_vfs_timerfd_create(unsigned long long __rpc_info, void *__buf, int fd, int clockid, int flags);


extern int __actvcapcall_fscall_vfs_timerfd_create(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, int clockid, int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_timerfd_create(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, int clockid, int flags)
{
	const unsigned long __callno = __fs_method_vfs_timerfd_create;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_timerfd_create(rpc_info, NULL, fd, clockid, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_timerfd_create(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, int clockid, int flags)
{
	const unsigned long __callno = __fs_method_vfs_timerfd_create;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_timerfd_create(__rref, rpc_info, NULL, fd, clockid, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_timerfd_create(int fd, int clockid, int flags)
{
	return actvxactcall_fscall_vfs_timerfd_create(false, false, fd, clockid, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_timerfd_create(rref_t __rref, int fd, int clockid, int flags)
{
	return actvxactcapcall_fscall_vfs_timerfd_create(false, false, __rref, fd, clockid, flags);
}

extern int __actvcall_fscall_vfs_timerfd_settime(unsigned long long __rpc_info, void *__buf, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);


extern int __actvcapcall_fscall_vfs_timerfd_settime(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_timerfd_settime(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec, struct __actvret_fscall_vfs_timerfd_settime *__ret)
{
	const unsigned long __callno = __fs_method_vfs_timerfd_settime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_timerfd_settime(rpc_info, __ret, fd, flags, it_inval_sec, it_inval_nsec, it_val_sec, it_val_nsec);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_timerfd_settime(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec, struct __actvret_fscall_vfs_timerfd_settime *__ret)
{
	const unsigned long __callno = __fs_method_vfs_timerfd_settime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_timerfd_settime(__rref, rpc_info, __ret, fd, flags, it_inval_sec, it_inval_nsec, it_val_sec, it_val_nsec);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_timerfd_settime(int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec, struct __actvret_fscall_vfs_timerfd_settime *__ret)
{
	return actvxactcall_fscall_vfs_timerfd_settime(false, false, fd, flags, it_inval_sec, it_inval_nsec, it_val_sec, it_val_nsec, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_timerfd_settime(rref_t __rref, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec, struct __actvret_fscall_vfs_timerfd_settime *__ret)
{
	return actvxactcapcall_fscall_vfs_timerfd_settime(false, false, __rref, fd, flags, it_inval_sec, it_inval_nsec, it_val_sec, it_val_nsec, __ret);
}

extern int __actvcall_fscall_vfs_timerfd_gettime(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_timerfd_gettime(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_timerfd_gettime(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, struct __actvret_fscall_vfs_timerfd_gettime *__ret)
{
	const unsigned long __callno = __fs_method_vfs_timerfd_gettime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_timerfd_gettime(rpc_info, __ret, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_timerfd_gettime(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, struct __actvret_fscall_vfs_timerfd_gettime *__ret)
{
	const unsigned long __callno = __fs_method_vfs_timerfd_gettime;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_timerfd_gettime(__rref, rpc_info, __ret, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_timerfd_gettime(int fd, struct __actvret_fscall_vfs_timerfd_gettime *__ret)
{
	return actvxactcall_fscall_vfs_timerfd_gettime(false, false, fd, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_timerfd_gettime(rref_t __rref, int fd, struct __actvret_fscall_vfs_timerfd_gettime *__ret)
{
	return actvxactcapcall_fscall_vfs_timerfd_gettime(false, false, __rref, fd, __ret);
}

extern int __actvcall_fscall_vfs_open_exec(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_open_exec(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_open_exec(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_open_exec *__ret)
{
	const unsigned long __callno = __fs_method_vfs_open_exec;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_open_exec(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, dfd, sys_fd, flags, pcnode_idx, cnode_idx, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_open_exec(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_open_exec *__ret)
{
	const unsigned long __callno = __fs_method_vfs_open_exec;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_open_exec(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, dfd, sys_fd, flags, pcnode_idx, cnode_idx, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_open_exec(int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_open_exec *__ret)
{
	return actvxactcall_fscall_vfs_open_exec(false, false, dfd, sys_fd, flags, pcnode_idx, cnode_idx, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_open_exec(rref_t __rref, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_open_exec *__ret)
{
	return actvxactcapcall_fscall_vfs_open_exec(false, false, __rref, dfd, sys_fd, flags, pcnode_idx, cnode_idx, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_vfs_close_exec(unsigned long long __rpc_info, void *__buf, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);


extern int __actvcapcall_fscall_vfs_close_exec(rref_t __rref, unsigned long long __rpc_info, void *__buf, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_close_exec(bool is_xact_fwd, bool is_xact_allow_refwd, int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	const unsigned long __callno = __fs_method_vfs_close_exec;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_close_exec(rpc_info, NULL, sys_rfd, cnode_idx, uapp_rfd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_close_exec(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	const unsigned long __callno = __fs_method_vfs_close_exec;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_close_exec(__rref, rpc_info, NULL, sys_rfd, cnode_idx, uapp_rfd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_close_exec(int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	return actvxactcall_fscall_vfs_close_exec(false, false, sys_rfd, cnode_idx, uapp_rfd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_close_exec(rref_t __rref, int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	return actvxactcapcall_fscall_vfs_close_exec(false, false, __rref, sys_rfd, cnode_idx, uapp_rfd);
}

extern int __actvcall_fscall_vfs_set_elf_file(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int sys_rfd);


extern int __actvcapcall_fscall_vfs_set_elf_file(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int sys_rfd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_set_elf_file(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int sys_rfd)
{
	const unsigned long __callno = __fs_method_vfs_set_elf_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_set_elf_file(rpc_info, NULL, cnode_idx, sys_rfd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_set_elf_file(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int sys_rfd)
{
	const unsigned long __callno = __fs_method_vfs_set_elf_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_set_elf_file(__rref, rpc_info, NULL, cnode_idx, sys_rfd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_set_elf_file(unsigned int cnode_idx, int sys_rfd)
{
	return actvxactcall_fscall_vfs_set_elf_file(false, false, cnode_idx, sys_rfd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_set_elf_file(rref_t __rref, unsigned int cnode_idx, int sys_rfd)
{
	return actvxactcapcall_fscall_vfs_set_elf_file(false, false, __rref, cnode_idx, sys_rfd);
}

extern int __actvcall_fscall_vfs_ioctl(unsigned long long __rpc_info, void *__buf, int fd, unsigned int cmd, unsigned long arg);


extern int __actvcapcall_fscall_vfs_ioctl(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int cmd, unsigned long arg);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_ioctl(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int cmd, unsigned long arg)
{
	const unsigned long __callno = __fs_method_vfs_ioctl;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_ioctl(rpc_info, NULL, fd, cmd, arg);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_ioctl(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int cmd, unsigned long arg)
{
	const unsigned long __callno = __fs_method_vfs_ioctl;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_ioctl(__rref, rpc_info, NULL, fd, cmd, arg);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_ioctl(int fd, unsigned int cmd, unsigned long arg)
{
	return actvxactcall_fscall_vfs_ioctl(false, false, fd, cmd, arg);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_ioctl(rref_t __rref, int fd, unsigned int cmd, unsigned long arg)
{
	return actvxactcapcall_fscall_vfs_ioctl(false, false, __rref, fd, cmd, arg);
}

extern int __actvcall_fscall_vfs_read(unsigned long long __rpc_info, void *__buf, int fd, long long pos, size_t msg_len, void *buf);


extern int __actvcapcall_fscall_vfs_read(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, long long pos, size_t msg_len, void *buf);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_read(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, long long pos, size_t msg_len, void *buf, struct __actvret_fscall_vfs_read *__ret)
{
	const unsigned long __callno = __fs_method_vfs_read;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_read(rpc_info, __ret, fd, pos, msg_len, buf);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_read(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, long long pos, size_t msg_len, void *buf, struct __actvret_fscall_vfs_read *__ret)
{
	const unsigned long __callno = __fs_method_vfs_read;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_read(__rref, rpc_info, __ret, fd, pos, msg_len, buf);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_read(int fd, long long pos, size_t msg_len, void *buf, struct __actvret_fscall_vfs_read *__ret)
{
	return actvxactcall_fscall_vfs_read(false, false, fd, pos, msg_len, buf, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_read(rref_t __rref, int fd, long long pos, size_t msg_len, void *buf, struct __actvret_fscall_vfs_read *__ret)
{
	return actvxactcapcall_fscall_vfs_read(false, false, __rref, fd, pos, msg_len, buf, __ret);
}

extern int __actvcall_fscall_vfs_readv(unsigned long long __rpc_info, void *__buf, int fd, const void *vec, int vlen, long long pos);


extern int __actvcapcall_fscall_vfs_readv(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const void *vec, int vlen, long long pos);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_readv(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const void *vec, int vlen, long long pos, struct __actvret_fscall_vfs_readv *__ret)
{
	const unsigned long __callno = __fs_method_vfs_readv;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_readv(rpc_info, __ret, fd, vec, vlen, pos);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_readv(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const void *vec, int vlen, long long pos, struct __actvret_fscall_vfs_readv *__ret)
{
	const unsigned long __callno = __fs_method_vfs_readv;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_readv(__rref, rpc_info, __ret, fd, vec, vlen, pos);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_readv(int fd, const void *vec, int vlen, long long pos, struct __actvret_fscall_vfs_readv *__ret)
{
	return actvxactcall_fscall_vfs_readv(false, false, fd, vec, vlen, pos, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_readv(rref_t __rref, int fd, const void *vec, int vlen, long long pos, struct __actvret_fscall_vfs_readv *__ret)
{
	return actvxactcapcall_fscall_vfs_readv(false, false, __rref, fd, vec, vlen, pos, __ret);
}

extern int __actvcall_fscall_vfs_getcwd(unsigned long long __rpc_info, void *__buf, char *buf, size_t size);


extern int __actvcapcall_fscall_vfs_getcwd(rref_t __rref, unsigned long long __rpc_info, void *__buf, char *buf, size_t size);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_getcwd(bool is_xact_fwd, bool is_xact_allow_refwd, char *buf, size_t size)
{
	const unsigned long __callno = __fs_method_vfs_getcwd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_getcwd(rpc_info, NULL, buf, size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_getcwd(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, char *buf, size_t size)
{
	const unsigned long __callno = __fs_method_vfs_getcwd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_getcwd(__rref, rpc_info, NULL, buf, size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_getcwd(char *buf, size_t size)
{
	return actvxactcall_fscall_vfs_getcwd(false, false, buf, size);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_getcwd(rref_t __rref, char *buf, size_t size)
{
	return actvxactcapcall_fscall_vfs_getcwd(false, false, __rref, buf, size);
}

extern int __actvcall_fscall_vfs_get_process_cwdrootexe(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);


extern int __actvcapcall_fscall_vfs_get_process_cwdrootexe(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_process_cwdrootexe(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	const unsigned long __callno = __fs_method_vfs_get_process_cwdrootexe;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_process_cwdrootexe(rpc_info, NULL, cnode_idx, root_cnode, type, buf);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_process_cwdrootexe(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	const unsigned long __callno = __fs_method_vfs_get_process_cwdrootexe;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_process_cwdrootexe(__rref, rpc_info, NULL, cnode_idx, root_cnode, type, buf);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_process_cwdrootexe(unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	return actvxactcall_fscall_vfs_get_process_cwdrootexe(false, false, cnode_idx, root_cnode, type, buf);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_process_cwdrootexe(rref_t __rref, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	return actvxactcapcall_fscall_vfs_get_process_cwdrootexe(false, false, __rref, cnode_idx, root_cnode, type, buf);
}

extern int __actvcall_fscall_vfs_readdir(unsigned long long __rpc_info, void *__buf, int fd, void *buf, size_t size);


extern int __actvcapcall_fscall_vfs_readdir(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, void *buf, size_t size);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_readdir(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, void *buf, size_t size)
{
	const unsigned long __callno = __fs_method_vfs_readdir;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_readdir(rpc_info, NULL, fd, buf, size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_readdir(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, void *buf, size_t size)
{
	const unsigned long __callno = __fs_method_vfs_readdir;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_readdir(__rref, rpc_info, NULL, fd, buf, size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_readdir(int fd, void *buf, size_t size)
{
	return actvxactcall_fscall_vfs_readdir(false, false, fd, buf, size);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_readdir(rref_t __rref, int fd, void *buf, size_t size)
{
	return actvxactcapcall_fscall_vfs_readdir(false, false, __rref, fd, buf, size);
}

extern int __actvcall_fscall_vfs_write(unsigned long long __rpc_info, void *__buf, int fd, long long pos, const void *buf, size_t buf_len);


extern int __actvcapcall_fscall_vfs_write(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, long long pos, const void *buf, size_t buf_len);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_write(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, long long pos, const void *buf, size_t buf_len, struct __actvret_fscall_vfs_write *__ret)
{
	const unsigned long __callno = __fs_method_vfs_write;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_write(rpc_info, __ret, fd, pos, buf, buf_len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_write(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, long long pos, const void *buf, size_t buf_len, struct __actvret_fscall_vfs_write *__ret)
{
	const unsigned long __callno = __fs_method_vfs_write;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_write(__rref, rpc_info, __ret, fd, pos, buf, buf_len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_write(int fd, long long pos, const void *buf, size_t buf_len, struct __actvret_fscall_vfs_write *__ret)
{
	return actvxactcall_fscall_vfs_write(false, false, fd, pos, buf, buf_len, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_write(rref_t __rref, int fd, long long pos, const void *buf, size_t buf_len, struct __actvret_fscall_vfs_write *__ret)
{
	return actvxactcapcall_fscall_vfs_write(false, false, __rref, fd, pos, buf, buf_len, __ret);
}

extern int __actvcall_fscall_vfs_writev(unsigned long long __rpc_info, void *__buf, int fd, const void *vec, int vlen, long long pos);


extern int __actvcapcall_fscall_vfs_writev(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const void *vec, int vlen, long long pos);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_writev(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const void *vec, int vlen, long long pos, struct __actvret_fscall_vfs_writev *__ret)
{
	const unsigned long __callno = __fs_method_vfs_writev;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_writev(rpc_info, __ret, fd, vec, vlen, pos);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_writev(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const void *vec, int vlen, long long pos, struct __actvret_fscall_vfs_writev *__ret)
{
	const unsigned long __callno = __fs_method_vfs_writev;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_writev(__rref, rpc_info, __ret, fd, vec, vlen, pos);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_writev(int fd, const void *vec, int vlen, long long pos, struct __actvret_fscall_vfs_writev *__ret)
{
	return actvxactcall_fscall_vfs_writev(false, false, fd, vec, vlen, pos, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_writev(rref_t __rref, int fd, const void *vec, int vlen, long long pos, struct __actvret_fscall_vfs_writev *__ret)
{
	return actvxactcapcall_fscall_vfs_writev(false, false, __rref, fd, vec, vlen, pos, __ret);
}

extern int __actvcall_fscall_vfs_sync(unsigned long long __rpc_info, void *__buf);


extern int __actvcapcall_fscall_vfs_sync(rref_t __rref, unsigned long long __rpc_info, void *__buf);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_sync(bool is_xact_fwd, bool is_xact_allow_refwd)
{
	const unsigned long __callno = __fs_method_vfs_sync;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_sync(rpc_info, NULL);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_sync(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref)
{
	const unsigned long __callno = __fs_method_vfs_sync;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_sync(__rref, rpc_info, NULL);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_sync(void)
{
	return actvxactcall_fscall_vfs_sync(false, false);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_sync(rref_t __rref)
{
	return actvxactcapcall_fscall_vfs_sync(false, false, __rref);
}

extern int __actvcall_fscall_vfs_do_sync(unsigned long long __rpc_info, void *__buf, int me_idx);


extern int __actvcapcall_fscall_vfs_do_sync(rref_t __rref, unsigned long long __rpc_info, void *__buf, int me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_do_sync(bool is_xact_fwd, bool is_xact_allow_refwd, int me_idx)
{
	const unsigned long __callno = __fs_method_vfs_do_sync;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_do_sync(rpc_info, NULL, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_do_sync(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int me_idx)
{
	const unsigned long __callno = __fs_method_vfs_do_sync;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_do_sync(__rref, rpc_info, NULL, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_do_sync(int me_idx)
{
	return actvxactcall_fscall_vfs_do_sync(false, false, me_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_do_sync(rref_t __rref, int me_idx)
{
	return actvxactcapcall_fscall_vfs_do_sync(false, false, __rref, me_idx);
}

extern int __actvcall_fscall_vfs_utimensat(unsigned long long __rpc_info, void *__buf, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_utimensat(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_utimensat(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_utimensat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_utimensat(rpc_info, ___void_buf, dfd, tsp, flag, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_utimensat(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_utimensat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_utimensat(__rref, rpc_info, ___void_buf, dfd, tsp, flag, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_utimensat(int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_utimensat(false, false, dfd, tsp, flag, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_utimensat(rref_t __rref, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_utimensat(false, false, __rref, dfd, tsp, flag, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_futimens(unsigned long long __rpc_info, void *__buf, int fd, const void *tsp);


extern int __actvcapcall_fscall_vfs_futimens(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const void *tsp);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_futimens(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const void *tsp)
{
	const unsigned long __callno = __fs_method_vfs_futimens;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_futimens(rpc_info, NULL, fd, tsp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_futimens(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const void *tsp)
{
	const unsigned long __callno = __fs_method_vfs_futimens;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_futimens(__rref, rpc_info, NULL, fd, tsp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_futimens(int fd, const void *tsp)
{
	return actvxactcall_fscall_vfs_futimens(false, false, fd, tsp);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_futimens(rref_t __rref, int fd, const void *tsp)
{
	return actvxactcapcall_fscall_vfs_futimens(false, false, __rref, fd, tsp);
}

extern int __actvcall_fscall_vfs_fchmodat(unsigned long long __rpc_info, void *__buf, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_fchmodat(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fchmodat(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_fchmodat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fchmodat(rpc_info, ___void_buf, dfd, mode, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fchmodat(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_fchmodat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fchmodat(__rref, rpc_info, ___void_buf, dfd, mode, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fchmodat(int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_fchmodat(false, false, dfd, mode, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fchmodat(rref_t __rref, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_fchmodat(false, false, __rref, dfd, mode, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_fchmod(unsigned long long __rpc_info, void *__buf, int fd, mode_t mode);


extern int __actvcapcall_fscall_vfs_fchmod(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, mode_t mode);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fchmod(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, mode_t mode)
{
	const unsigned long __callno = __fs_method_vfs_fchmod;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fchmod(rpc_info, NULL, fd, mode);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fchmod(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, mode_t mode)
{
	const unsigned long __callno = __fs_method_vfs_fchmod;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fchmod(__rref, rpc_info, NULL, fd, mode);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fchmod(int fd, mode_t mode)
{
	return actvxactcall_fscall_vfs_fchmod(false, false, fd, mode);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fchmod(rref_t __rref, int fd, mode_t mode)
{
	return actvxactcapcall_fscall_vfs_fchmod(false, false, __rref, fd, mode);
}

extern int __actvcall_fscall_vfs_drop_caches(unsigned long long __rpc_info, void *__buf, unsigned int mode, int max, int reason);


extern int __actvcapcall_fscall_vfs_drop_caches(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int mode, int max, int reason);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_drop_caches(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int mode, int max, int reason)
{
	const unsigned long __callno = __fs_method_vfs_drop_caches;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_drop_caches(rpc_info, NULL, mode, max, reason);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_drop_caches(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int mode, int max, int reason)
{
	const unsigned long __callno = __fs_method_vfs_drop_caches;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_drop_caches(__rref, rpc_info, NULL, mode, max, reason);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_drop_caches(unsigned int mode, int max, int reason)
{
	return actvxactcall_fscall_vfs_drop_caches(false, false, mode, max, reason);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_drop_caches(rref_t __rref, unsigned int mode, int max, int reason)
{
	return actvxactcapcall_fscall_vfs_drop_caches(false, false, __rref, mode, max, reason);
}

extern int __actvcall_fscall_vfs_do_drop_caches(unsigned long long __rpc_info, void *__buf, unsigned int mode, int max, int reason);


extern int __actvcapcall_fscall_vfs_do_drop_caches(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int mode, int max, int reason);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_do_drop_caches(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int mode, int max, int reason)
{
	const unsigned long __callno = __fs_method_vfs_do_drop_caches;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_do_drop_caches(rpc_info, NULL, mode, max, reason);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_do_drop_caches(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int mode, int max, int reason)
{
	const unsigned long __callno = __fs_method_vfs_do_drop_caches;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_do_drop_caches(__rref, rpc_info, NULL, mode, max, reason);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_do_drop_caches(unsigned int mode, int max, int reason)
{
	return actvxactcall_fscall_vfs_do_drop_caches(false, false, mode, max, reason);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_do_drop_caches(rref_t __rref, unsigned int mode, int max, int reason)
{
	return actvxactcapcall_fscall_vfs_do_drop_caches(false, false, __rref, mode, max, reason);
}

extern int __actvcall_fscall_vfs_fadvise(unsigned long long __rpc_info, void *__buf, int fd, long long offset, long long len, int advice);


extern int __actvcapcall_fscall_vfs_fadvise(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, long long offset, long long len, int advice);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fadvise(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, long long offset, long long len, int advice)
{
	const unsigned long __callno = __fs_method_vfs_fadvise;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fadvise(rpc_info, NULL, fd, offset, len, advice);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fadvise(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, long long offset, long long len, int advice)
{
	const unsigned long __callno = __fs_method_vfs_fadvise;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fadvise(__rref, rpc_info, NULL, fd, offset, len, advice);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fadvise(int fd, long long offset, long long len, int advice)
{
	return actvxactcall_fscall_vfs_fadvise(false, false, fd, offset, len, advice);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fadvise(rref_t __rref, int fd, long long offset, long long len, int advice)
{
	return actvxactcapcall_fscall_vfs_fadvise(false, false, __rref, fd, offset, len, advice);
}

extern int __actvcall_fscall_vfs_readahead(unsigned long long __rpc_info, void *__buf, int fd, long long offset, size_t count);


extern int __actvcapcall_fscall_vfs_readahead(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, long long offset, size_t count);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_readahead(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, long long offset, size_t count)
{
	const unsigned long __callno = __fs_method_vfs_readahead;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_readahead(rpc_info, NULL, fd, offset, count);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_readahead(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, long long offset, size_t count)
{
	const unsigned long __callno = __fs_method_vfs_readahead;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_readahead(__rref, rpc_info, NULL, fd, offset, count);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_readahead(int fd, long long offset, size_t count)
{
	return actvxactcall_fscall_vfs_readahead(false, false, fd, offset, count);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_readahead(rref_t __rref, int fd, long long offset, size_t count)
{
	return actvxactcapcall_fscall_vfs_readahead(false, false, __rref, fd, offset, count);
}

extern int __actvcall_fscall_vfs_get_fd_path(unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx, char *path, int pathlen);


extern int __actvcapcall_fscall_vfs_get_fd_path(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx, char *path, int pathlen);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_fd_path(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	const unsigned long __callno = __fs_method_vfs_get_fd_path;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_fd_path(rpc_info, NULL, fd, cnode_idx, path, pathlen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_fd_path(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	const unsigned long __callno = __fs_method_vfs_get_fd_path;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_fd_path(__rref, rpc_info, NULL, fd, cnode_idx, path, pathlen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_fd_path(int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	return actvxactcall_fscall_vfs_get_fd_path(false, false, fd, cnode_idx, path, pathlen);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_fd_path(rref_t __rref, int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	return actvxactcapcall_fscall_vfs_get_fd_path(false, false, __rref, fd, cnode_idx, path, pathlen);
}

extern int __actvcall_fscall_vfs_sysmgr_get_fd_path(unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx, char *path);


extern int __actvcapcall_fscall_vfs_sysmgr_get_fd_path(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx, char *path);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_sysmgr_get_fd_path(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int cnode_idx, char *path)
{
	const unsigned long __callno = __fs_method_vfs_sysmgr_get_fd_path;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_sysmgr_get_fd_path(rpc_info, NULL, fd, cnode_idx, path);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_sysmgr_get_fd_path(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int cnode_idx, char *path)
{
	const unsigned long __callno = __fs_method_vfs_sysmgr_get_fd_path;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_sysmgr_get_fd_path(__rref, rpc_info, NULL, fd, cnode_idx, path);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_sysmgr_get_fd_path(int fd, unsigned int cnode_idx, char *path)
{
	return actvxactcall_fscall_vfs_sysmgr_get_fd_path(false, false, fd, cnode_idx, path);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_sysmgr_get_fd_path(rref_t __rref, int fd, unsigned int cnode_idx, char *path)
{
	return actvxactcapcall_fscall_vfs_sysmgr_get_fd_path(false, false, __rref, fd, cnode_idx, path);
}

extern int __actvcall_fscall_vfs_fcntl(unsigned long long __rpc_info, void *__buf, int fd, int cmd, unsigned long arg);


extern int __actvcapcall_fscall_vfs_fcntl(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, int cmd, unsigned long arg);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fcntl(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, int cmd, unsigned long arg)
{
	const unsigned long __callno = __fs_method_vfs_fcntl;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fcntl(rpc_info, NULL, fd, cmd, arg);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fcntl(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, int cmd, unsigned long arg)
{
	const unsigned long __callno = __fs_method_vfs_fcntl;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fcntl(__rref, rpc_info, NULL, fd, cmd, arg);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fcntl(int fd, int cmd, unsigned long arg)
{
	return actvxactcall_fscall_vfs_fcntl(false, false, fd, cmd, arg);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fcntl(rref_t __rref, int fd, int cmd, unsigned long arg)
{
	return actvxactcapcall_fscall_vfs_fcntl(false, false, __rref, fd, cmd, arg);
}

extern int __actvcall_fscall_vfs_device_mounted(unsigned long long __rpc_info, void *__buf, const char *special, unsigned long long len, char *srvname, int srvlen);


extern int __actvcapcall_fscall_vfs_device_mounted(rref_t __rref, unsigned long long __rpc_info, void *__buf, const char *special, unsigned long long len, char *srvname, int srvlen);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_device_mounted(bool is_xact_fwd, bool is_xact_allow_refwd, const char *special, unsigned long long len, char *srvname, int srvlen)
{
	const unsigned long __callno = __fs_method_vfs_device_mounted;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_device_mounted(rpc_info, NULL, special, len, srvname, srvlen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_device_mounted(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, const char *special, unsigned long long len, char *srvname, int srvlen)
{
	const unsigned long __callno = __fs_method_vfs_device_mounted;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_device_mounted(__rref, rpc_info, NULL, special, len, srvname, srvlen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_device_mounted(const char *special, unsigned long long len, char *srvname, int srvlen)
{
	return actvxactcall_fscall_vfs_device_mounted(false, false, special, len, srvname, srvlen);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_device_mounted(rref_t __rref, const char *special, unsigned long long len, char *srvname, int srvlen)
{
	return actvxactcapcall_fscall_vfs_device_mounted(false, false, __rref, special, len, srvname, srvlen);
}

extern int __actvcall_fscall_vfs_quotactl(unsigned long long __rpc_info, void *__buf, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);


extern int __actvcapcall_fscall_vfs_quotactl(rref_t __rref, unsigned long long __rpc_info, void *__buf, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_quotactl(bool is_xact_fwd, bool is_xact_allow_refwd, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	const unsigned long __callno = __fs_method_vfs_quotactl;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_quotactl(rpc_info, NULL, cmd, type, id, buffer, buffer_size, fs_handle);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_quotactl(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	const unsigned long __callno = __fs_method_vfs_quotactl;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_quotactl(__rref, rpc_info, NULL, cmd, type, id, buffer, buffer_size, fs_handle);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_quotactl(int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	return actvxactcall_fscall_vfs_quotactl(false, false, cmd, type, id, buffer, buffer_size, fs_handle);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_quotactl(rref_t __rref, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	return actvxactcapcall_fscall_vfs_quotactl(false, false, __rref, cmd, type, id, buffer, buffer_size, fs_handle);
}

extern int __actvcall_fscall_vfs_copy_file_range(unsigned long long __rpc_info, void *__buf, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);


extern int __actvcapcall_fscall_vfs_copy_file_range(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_copy_file_range(bool is_xact_fwd, bool is_xact_allow_refwd, int fd_in, long long off_in, int fd_out, long long off_out, size_t len, struct __actvret_fscall_vfs_copy_file_range *__ret)
{
	const unsigned long __callno = __fs_method_vfs_copy_file_range;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_copy_file_range(rpc_info, __ret, fd_in, off_in, fd_out, off_out, len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_copy_file_range(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd_in, long long off_in, int fd_out, long long off_out, size_t len, struct __actvret_fscall_vfs_copy_file_range *__ret)
{
	const unsigned long __callno = __fs_method_vfs_copy_file_range;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_copy_file_range(__rref, rpc_info, __ret, fd_in, off_in, fd_out, off_out, len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_copy_file_range(int fd_in, long long off_in, int fd_out, long long off_out, size_t len, struct __actvret_fscall_vfs_copy_file_range *__ret)
{
	return actvxactcall_fscall_vfs_copy_file_range(false, false, fd_in, off_in, fd_out, off_out, len, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_copy_file_range(rref_t __rref, int fd_in, long long off_in, int fd_out, long long off_out, size_t len, struct __actvret_fscall_vfs_copy_file_range *__ret)
{
	return actvxactcapcall_fscall_vfs_copy_file_range(false, false, __rref, fd_in, off_in, fd_out, off_out, len, __ret);
}

extern int __actvcall_fscall_vfs_same_file(unsigned long long __rpc_info, void *__buf, int fd1, int fd2);


extern int __actvcapcall_fscall_vfs_same_file(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd1, int fd2);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_same_file(bool is_xact_fwd, bool is_xact_allow_refwd, int fd1, int fd2)
{
	const unsigned long __callno = __fs_method_vfs_same_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_same_file(rpc_info, NULL, fd1, fd2);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_same_file(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd1, int fd2)
{
	const unsigned long __callno = __fs_method_vfs_same_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_same_file(__rref, rpc_info, NULL, fd1, fd2);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_same_file(int fd1, int fd2)
{
	return actvxactcall_fscall_vfs_same_file(false, false, fd1, fd2);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_same_file(rref_t __rref, int fd1, int fd2)
{
	return actvxactcapcall_fscall_vfs_same_file(false, false, __rref, fd1, fd2);
}

extern int __actvcall_fscall_vfs_access(unsigned long long __rpc_info, void *__buf, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_access(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_access(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_access;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_access(rpc_info, ___void_buf, dfd, mode, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_access(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_access;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_access(__rref, rpc_info, ___void_buf, dfd, mode, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_access(int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_access(false, false, dfd, mode, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_access(rref_t __rref, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_access(false, false, __rref, dfd, mode, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_flock(unsigned long long __rpc_info, void *__buf, int fd, unsigned int cmd);


extern int __actvcapcall_fscall_vfs_flock(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int cmd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_flock(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int cmd)
{
	const unsigned long __callno = __fs_method_vfs_flock;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_flock(rpc_info, NULL, fd, cmd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_flock(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int cmd)
{
	const unsigned long __callno = __fs_method_vfs_flock;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_flock(__rref, rpc_info, NULL, fd, cmd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_flock(int fd, unsigned int cmd)
{
	return actvxactcall_fscall_vfs_flock(false, false, fd, cmd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_flock(rref_t __rref, int fd, unsigned int cmd)
{
	return actvxactcapcall_fscall_vfs_flock(false, false, __rref, fd, cmd);
}

extern int __actvcall_fscall_vfs_fchownat(unsigned long long __rpc_info, void *__buf, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_fchownat(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fchownat(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_fchownat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fchownat(rpc_info, ___void_buf, dfd, uid, gid, flag, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fchownat(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_fchownat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fchownat(__rref, rpc_info, ___void_buf, dfd, uid, gid, flag, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fchownat(int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_fchownat(false, false, dfd, uid, gid, flag, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fchownat(rref_t __rref, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_fchownat(false, false, __rref, dfd, uid, gid, flag, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_fchown(unsigned long long __rpc_info, void *__buf, int fd, uid_t uid, gid_t gid);


extern int __actvcapcall_fscall_vfs_fchown(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, uid_t uid, gid_t gid);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fchown(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, uid_t uid, gid_t gid)
{
	const unsigned long __callno = __fs_method_vfs_fchown;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fchown(rpc_info, NULL, fd, uid, gid);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fchown(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, uid_t uid, gid_t gid)
{
	const unsigned long __callno = __fs_method_vfs_fchown;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fchown(__rref, rpc_info, NULL, fd, uid, gid);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fchown(int fd, uid_t uid, gid_t gid)
{
	return actvxactcall_fscall_vfs_fchown(false, false, fd, uid, gid);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fchown(rref_t __rref, int fd, uid_t uid, gid_t gid)
{
	return actvxactcapcall_fscall_vfs_fchown(false, false, __rref, fd, uid, gid);
}

extern int __actvcall_fscall_vfs_binderfs_mmap(unsigned long long __rpc_info, void *__buf, void *addr, size_t len, int fd, unsigned long long shm_key);


extern int __actvcapcall_fscall_vfs_binderfs_mmap(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *addr, size_t len, int fd, unsigned long long shm_key);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_binderfs_mmap(bool is_xact_fwd, bool is_xact_allow_refwd, void *addr, size_t len, int fd, unsigned long long shm_key)
{
	const unsigned long __callno = __fs_method_vfs_binderfs_mmap;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_binderfs_mmap(rpc_info, NULL, addr, len, fd, shm_key);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_binderfs_mmap(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, void *addr, size_t len, int fd, unsigned long long shm_key)
{
	const unsigned long __callno = __fs_method_vfs_binderfs_mmap;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_binderfs_mmap(__rref, rpc_info, NULL, addr, len, fd, shm_key);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_binderfs_mmap(void *addr, size_t len, int fd, unsigned long long shm_key)
{
	return actvxactcall_fscall_vfs_binderfs_mmap(false, false, addr, len, fd, shm_key);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_binderfs_mmap(rref_t __rref, void *addr, size_t len, int fd, unsigned long long shm_key)
{
	return actvxactcapcall_fscall_vfs_binderfs_mmap(false, false, __rref, addr, len, fd, shm_key);
}

extern int __actvcall_fscall_vfs_init_signalfd(unsigned long long __rpc_info, void *__buf, int fd, unsigned long long sigmask, int flags);


extern int __actvcapcall_fscall_vfs_init_signalfd(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long long sigmask, int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_init_signalfd(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long long sigmask, int flags)
{
	const unsigned long __callno = __fs_method_vfs_init_signalfd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_init_signalfd(rpc_info, NULL, fd, sigmask, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_init_signalfd(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long long sigmask, int flags)
{
	const unsigned long __callno = __fs_method_vfs_init_signalfd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_init_signalfd(__rref, rpc_info, NULL, fd, sigmask, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_init_signalfd(int fd, unsigned long long sigmask, int flags)
{
	return actvxactcall_fscall_vfs_init_signalfd(false, false, fd, sigmask, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_init_signalfd(rref_t __rref, int fd, unsigned long long sigmask, int flags)
{
	return actvxactcapcall_fscall_vfs_init_signalfd(false, false, __rref, fd, sigmask, flags);
}

extern int __actvcall_fscall_vfs_epoll_ctl(unsigned long long __rpc_info, void *__buf, int fd, int op, int is_epoll, const void *epoll_reg_info);


extern int __actvcapcall_fscall_vfs_epoll_ctl(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, int op, int is_epoll, const void *epoll_reg_info);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_epoll_ctl(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	const unsigned long __callno = __fs_method_vfs_epoll_ctl;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_epoll_ctl(rpc_info, NULL, fd, op, is_epoll, epoll_reg_info);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_epoll_ctl(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	const unsigned long __callno = __fs_method_vfs_epoll_ctl;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_epoll_ctl(__rref, rpc_info, NULL, fd, op, is_epoll, epoll_reg_info);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_epoll_ctl(int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	return actvxactcall_fscall_vfs_epoll_ctl(false, false, fd, op, is_epoll, epoll_reg_info);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_epoll_ctl(rref_t __rref, int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	return actvxactcapcall_fscall_vfs_epoll_ctl(false, false, __rref, fd, op, is_epoll, epoll_reg_info);
}

extern int __actvcall_fscall_vfs_epoll_et_revents(unsigned long long __rpc_info, void *__buf, int fd, const void *epoll_pre_reg_info);


extern int __actvcapcall_fscall_vfs_epoll_et_revents(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const void *epoll_pre_reg_info);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_epoll_et_revents(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const void *epoll_pre_reg_info, struct __actvret_fscall_vfs_epoll_et_revents *__ret)
{
	const unsigned long __callno = __fs_method_vfs_epoll_et_revents;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_epoll_et_revents(rpc_info, __ret, fd, epoll_pre_reg_info);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_epoll_et_revents(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const void *epoll_pre_reg_info, struct __actvret_fscall_vfs_epoll_et_revents *__ret)
{
	const unsigned long __callno = __fs_method_vfs_epoll_et_revents;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_epoll_et_revents(__rref, rpc_info, __ret, fd, epoll_pre_reg_info);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_epoll_et_revents(int fd, const void *epoll_pre_reg_info, struct __actvret_fscall_vfs_epoll_et_revents *__ret)
{
	return actvxactcall_fscall_vfs_epoll_et_revents(false, false, fd, epoll_pre_reg_info, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_epoll_et_revents(rref_t __rref, int fd, const void *epoll_pre_reg_info, struct __actvret_fscall_vfs_epoll_et_revents *__ret)
{
	return actvxactcapcall_fscall_vfs_epoll_et_revents(false, false, __rref, fd, epoll_pre_reg_info, __ret);
}

extern int __actvcall_fscall_vfs_epoll_reinit(unsigned long long __rpc_info, void *__buf, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);


extern int __actvcapcall_fscall_vfs_epoll_reinit(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_epoll_reinit(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	const unsigned long __callno = __fs_method_vfs_epoll_reinit;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_epoll_reinit(rpc_info, NULL, fd, epoll_pre_reg_info, epoll_reg_info);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_epoll_reinit(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	const unsigned long __callno = __fs_method_vfs_epoll_reinit;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_epoll_reinit(__rref, rpc_info, NULL, fd, epoll_pre_reg_info, epoll_reg_info);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_epoll_reinit(int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	return actvxactcall_fscall_vfs_epoll_reinit(false, false, fd, epoll_pre_reg_info, epoll_reg_info);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_epoll_reinit(rref_t __rref, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	return actvxactcapcall_fscall_vfs_epoll_reinit(false, false, __rref, fd, epoll_pre_reg_info, epoll_reg_info);
}

extern int __actvcall_fscall_vfs_signalfd_notify(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, const void *buf, int fdcnt);


extern int __actvcapcall_fscall_vfs_signalfd_notify(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, const void *buf, int fdcnt);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_signalfd_notify(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, const void *buf, int fdcnt)
{
	const unsigned long __callno = __fs_method_vfs_signalfd_notify;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_signalfd_notify(rpc_info, NULL, cnode_idx, buf, fdcnt);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_signalfd_notify(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, const void *buf, int fdcnt)
{
	const unsigned long __callno = __fs_method_vfs_signalfd_notify;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_signalfd_notify(__rref, rpc_info, NULL, cnode_idx, buf, fdcnt);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_signalfd_notify(unsigned int cnode_idx, const void *buf, int fdcnt)
{
	return actvxactcall_fscall_vfs_signalfd_notify(false, false, cnode_idx, buf, fdcnt);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_signalfd_notify(rref_t __rref, unsigned int cnode_idx, const void *buf, int fdcnt)
{
	return actvxactcapcall_fscall_vfs_signalfd_notify(false, false, __rref, cnode_idx, buf, fdcnt);
}

extern int __actvcall_fscall_vfs_pid_io_stats(unsigned long long __rpc_info, void *__buf, unsigned int pid);


extern int __actvcapcall_fscall_vfs_pid_io_stats(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int pid);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_pid_io_stats(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int pid, struct __actvret_fscall_vfs_pid_io_stats *__ret)
{
	const unsigned long __callno = __fs_method_vfs_pid_io_stats;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_pid_io_stats(rpc_info, __ret, pid);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_pid_io_stats(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int pid, struct __actvret_fscall_vfs_pid_io_stats *__ret)
{
	const unsigned long __callno = __fs_method_vfs_pid_io_stats;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_pid_io_stats(__rref, rpc_info, __ret, pid);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_pid_io_stats(unsigned int pid, struct __actvret_fscall_vfs_pid_io_stats *__ret)
{
	return actvxactcall_fscall_vfs_pid_io_stats(false, false, pid, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_pid_io_stats(rref_t __rref, unsigned int pid, struct __actvret_fscall_vfs_pid_io_stats *__ret)
{
	return actvxactcapcall_fscall_vfs_pid_io_stats(false, false, __rref, pid, __ret);
}

extern int __actvcall_fscall_vfs_fallocate(unsigned long long __rpc_info, void *__buf, int fd, unsigned long long offset, unsigned long long len, int mode);


extern int __actvcapcall_fscall_vfs_fallocate(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long long offset, unsigned long long len, int mode);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fallocate(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long long offset, unsigned long long len, int mode)
{
	const unsigned long __callno = __fs_method_vfs_fallocate;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fallocate(rpc_info, NULL, fd, offset, len, mode);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fallocate(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long long offset, unsigned long long len, int mode)
{
	const unsigned long __callno = __fs_method_vfs_fallocate;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fallocate(__rref, rpc_info, NULL, fd, offset, len, mode);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fallocate(int fd, unsigned long long offset, unsigned long long len, int mode)
{
	return actvxactcall_fscall_vfs_fallocate(false, false, fd, offset, len, mode);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fallocate(rref_t __rref, int fd, unsigned long long offset, unsigned long long len, int mode)
{
	return actvxactcapcall_fscall_vfs_fallocate(false, false, __rref, fd, offset, len, mode);
}

extern int __actvcall_fscall_vfs_set_cwdroot(unsigned long long __rpc_info, void *__buf, int dfd, int type, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_set_cwdroot(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, int type, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_set_cwdroot(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, int type, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_set_cwdroot;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_set_cwdroot(rpc_info, ___void_buf, dfd, type, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_set_cwdroot(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, int type, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_set_cwdroot;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_set_cwdroot(__rref, rpc_info, ___void_buf, dfd, type, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_set_cwdroot(int dfd, int type, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_set_cwdroot(false, false, dfd, type, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_set_cwdroot(rref_t __rref, int dfd, int type, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_set_cwdroot(false, false, __rref, dfd, type, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_fchdir(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_fchdir(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fchdir(bool is_xact_fwd, bool is_xact_allow_refwd, int fd)
{
	const unsigned long __callno = __fs_method_vfs_fchdir;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fchdir(rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fchdir(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd)
{
	const unsigned long __callno = __fs_method_vfs_fchdir;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fchdir(__rref, rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fchdir(int fd)
{
	return actvxactcall_fscall_vfs_fchdir(false, false, fd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fchdir(rref_t __rref, int fd)
{
	return actvxactcapcall_fscall_vfs_fchdir(false, false, __rref, fd);
}

extern int __actvcall_fscall_vfs_disable_cwdroot(unsigned long long __rpc_info, void *__buf, int type);


extern int __actvcapcall_fscall_vfs_disable_cwdroot(rref_t __rref, unsigned long long __rpc_info, void *__buf, int type);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_disable_cwdroot(bool is_xact_fwd, bool is_xact_allow_refwd, int type, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_disable_cwdroot;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_disable_cwdroot(rpc_info, ___void_buf, type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_disable_cwdroot(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int type, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_disable_cwdroot;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_disable_cwdroot(__rref, rpc_info, ___void_buf, type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_disable_cwdroot(int type, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_disable_cwdroot(false, false, type, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_disable_cwdroot(rref_t __rref, int type, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_disable_cwdroot(false, false, __rref, type, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_update_cwdroot(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int type);


extern int __actvcapcall_fscall_vfs_update_cwdroot(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, int type);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_update_cwdroot(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, int type, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_update_cwdroot;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_update_cwdroot(rpc_info, ___void_buf, cnode_idx, type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_update_cwdroot(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, int type, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_update_cwdroot;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_update_cwdroot(__rref, rpc_info, ___void_buf, cnode_idx, type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_update_cwdroot(unsigned int cnode_idx, int type, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_update_cwdroot(false, false, cnode_idx, type, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_update_cwdroot(rref_t __rref, unsigned int cnode_idx, int type, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_update_cwdroot(false, false, __rref, cnode_idx, type, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_handle_global_locks(unsigned long long __rpc_info, void *__buf, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);


extern int __actvcapcall_fscall_vfs_handle_global_locks(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_handle_global_locks(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id, struct __actvret_fscall_vfs_handle_global_locks *__ret)
{
	const unsigned long __callno = __fs_method_vfs_handle_global_locks;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_handle_global_locks(rpc_info, __ret, cmd, cnode_idx, lock_id);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_handle_global_locks(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id, struct __actvret_fscall_vfs_handle_global_locks *__ret)
{
	const unsigned long __callno = __fs_method_vfs_handle_global_locks;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_handle_global_locks(__rref, rpc_info, __ret, cmd, cnode_idx, lock_id);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_handle_global_locks(unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id, struct __actvret_fscall_vfs_handle_global_locks *__ret)
{
	return actvxactcall_fscall_vfs_handle_global_locks(false, false, cmd, cnode_idx, lock_id, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_handle_global_locks(rref_t __rref, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id, struct __actvret_fscall_vfs_handle_global_locks *__ret)
{
	return actvxactcapcall_fscall_vfs_handle_global_locks(false, false, __rref, cmd, cnode_idx, lock_id, __ret);
}

extern int __actvcall_fscall_vfs_send_fd(unsigned long long __rpc_info, void *__buf, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);


extern int __actvcapcall_fscall_vfs_send_fd(rref_t __rref, unsigned long long __rpc_info, void *__buf, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_send_fd(bool is_xact_fwd, bool is_xact_allow_refwd, int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	const unsigned long __callno = __fs_method_vfs_send_fd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_send_fd(rpc_info, NULL, send_fd, send_cidx, recv_cidx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_send_fd(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	const unsigned long __callno = __fs_method_vfs_send_fd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_send_fd(__rref, rpc_info, NULL, send_fd, send_cidx, recv_cidx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_send_fd(int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	return actvxactcall_fscall_vfs_send_fd(false, false, send_fd, send_cidx, recv_cidx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_send_fd(rref_t __rref, int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	return actvxactcapcall_fscall_vfs_send_fd(false, false, __rref, send_fd, send_cidx, recv_cidx);
}

extern int __actvcall_fscall_vfs_recv_fd(unsigned long long __rpc_info, void *__buf, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);


extern int __actvcapcall_fscall_vfs_recv_fd(rref_t __rref, unsigned long long __rpc_info, void *__buf, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_recv_fd(bool is_xact_fwd, bool is_xact_allow_refwd, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx, struct __actvret_fscall_vfs_recv_fd *__ret)
{
	const unsigned long __callno = __fs_method_vfs_recv_fd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_recv_fd(rpc_info, __ret, sfiles_idx, send_cidx, recv_fd, recv_cidx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_recv_fd(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx, struct __actvret_fscall_vfs_recv_fd *__ret)
{
	const unsigned long __callno = __fs_method_vfs_recv_fd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_recv_fd(__rref, rpc_info, __ret, sfiles_idx, send_cidx, recv_fd, recv_cidx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_recv_fd(int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx, struct __actvret_fscall_vfs_recv_fd *__ret)
{
	return actvxactcall_fscall_vfs_recv_fd(false, false, sfiles_idx, send_cidx, recv_fd, recv_cidx, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_recv_fd(rref_t __rref, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx, struct __actvret_fscall_vfs_recv_fd *__ret)
{
	return actvxactcapcall_fscall_vfs_recv_fd(false, false, __rref, sfiles_idx, send_cidx, recv_fd, recv_cidx, __ret);
}

extern int __actvcall_fscall_vfs_get_buffer_wrapper(unsigned long long __rpc_info, void *__buf, int fd, unsigned long long ptr);


extern int __actvcapcall_fscall_vfs_get_buffer_wrapper(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long long ptr);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_buffer_wrapper(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long long ptr, struct __actvret_fscall_vfs_get_buffer_wrapper *__ret)
{
	const unsigned long __callno = __fs_method_vfs_get_buffer_wrapper;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_buffer_wrapper(rpc_info, __ret, fd, ptr);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_buffer_wrapper(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long long ptr, struct __actvret_fscall_vfs_get_buffer_wrapper *__ret)
{
	const unsigned long __callno = __fs_method_vfs_get_buffer_wrapper;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_buffer_wrapper(__rref, rpc_info, __ret, fd, ptr);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_buffer_wrapper(int fd, unsigned long long ptr, struct __actvret_fscall_vfs_get_buffer_wrapper *__ret)
{
	return actvxactcall_fscall_vfs_get_buffer_wrapper(false, false, fd, ptr, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_buffer_wrapper(rref_t __rref, int fd, unsigned long long ptr, struct __actvret_fscall_vfs_get_buffer_wrapper *__ret)
{
	return actvxactcapcall_fscall_vfs_get_buffer_wrapper(false, false, __rref, fd, ptr, __ret);
}

extern int __actvcall_fscall_vfs_get_pathname_by_me_idx(unsigned long long __rpc_info, void *__buf, int fd, int me_idx, uintptr_t pathname);


extern int __actvcapcall_fscall_vfs_get_pathname_by_me_idx(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, int me_idx, uintptr_t pathname);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_pathname_by_me_idx(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, int me_idx, uintptr_t pathname)
{
	const unsigned long __callno = __fs_method_vfs_get_pathname_by_me_idx;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_pathname_by_me_idx(rpc_info, NULL, fd, me_idx, pathname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_pathname_by_me_idx(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, int me_idx, uintptr_t pathname)
{
	const unsigned long __callno = __fs_method_vfs_get_pathname_by_me_idx;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_pathname_by_me_idx(__rref, rpc_info, NULL, fd, me_idx, pathname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_pathname_by_me_idx(int fd, int me_idx, uintptr_t pathname)
{
	return actvxactcall_fscall_vfs_get_pathname_by_me_idx(false, false, fd, me_idx, pathname);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_pathname_by_me_idx(rref_t __rref, int fd, int me_idx, uintptr_t pathname)
{
	return actvxactcapcall_fscall_vfs_get_pathname_by_me_idx(false, false, __rref, fd, me_idx, pathname);
}

extern int __actvcall_fscall_vfs_sfile_put(unsigned long long __rpc_info, void *__buf, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);


extern int __actvcapcall_fscall_vfs_sfile_put(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_sfile_put(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	const unsigned long __callno = __fs_method_vfs_sfile_put;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_sfile_put(rpc_info, NULL, send_cidx, recv_cidx, sfiles_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_sfile_put(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	const unsigned long __callno = __fs_method_vfs_sfile_put;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_sfile_put(__rref, rpc_info, NULL, send_cidx, recv_cidx, sfiles_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_sfile_put(unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	return actvxactcall_fscall_vfs_sfile_put(false, false, send_cidx, recv_cidx, sfiles_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_sfile_put(rref_t __rref, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	return actvxactcapcall_fscall_vfs_sfile_put(false, false, __rref, send_cidx, recv_cidx, sfiles_idx);
}

extern int __actvcall_fscall_vfs_readlinkat(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_readlinkat(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_readlinkat(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_readlinkat *__ret)
{
	const unsigned long __callno = __fs_method_vfs_readlinkat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_readlinkat(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, dfd, buf, bufsize, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_readlinkat(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_readlinkat *__ret)
{
	const unsigned long __callno = __fs_method_vfs_readlinkat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_readlinkat(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, dfd, buf, bufsize, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_readlinkat(int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_readlinkat *__ret)
{
	return actvxactcall_fscall_vfs_readlinkat(false, false, dfd, buf, bufsize, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_readlinkat(rref_t __rref, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_readlinkat *__ret)
{
	return actvxactcapcall_fscall_vfs_readlinkat(false, false, __rref, dfd, buf, bufsize, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_vfs_get_slabinfo(unsigned long long __rpc_info, void *__buf, char *msg, unsigned int msg_len);


extern int __actvcapcall_fscall_vfs_get_slabinfo(rref_t __rref, unsigned long long __rpc_info, void *__buf, char *msg, unsigned int msg_len);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_slabinfo(bool is_xact_fwd, bool is_xact_allow_refwd, char *msg, unsigned int msg_len)
{
	const unsigned long __callno = __fs_method_vfs_get_slabinfo;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_slabinfo(rpc_info, NULL, msg, msg_len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_slabinfo(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, char *msg, unsigned int msg_len)
{
	const unsigned long __callno = __fs_method_vfs_get_slabinfo;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_slabinfo(__rref, rpc_info, NULL, msg, msg_len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_slabinfo(char *msg, unsigned int msg_len)
{
	return actvxactcall_fscall_vfs_get_slabinfo(false, false, msg, msg_len);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_slabinfo(rref_t __rref, char *msg, unsigned int msg_len)
{
	return actvxactcapcall_fscall_vfs_get_slabinfo(false, false, __rref, msg, msg_len);
}

extern int __actvcall_fscall_vfs_do_get_slabinfo(unsigned long long __rpc_info, void *__buf, char *msg, unsigned int msg_len);


extern int __actvcapcall_fscall_vfs_do_get_slabinfo(rref_t __rref, unsigned long long __rpc_info, void *__buf, char *msg, unsigned int msg_len);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_do_get_slabinfo(bool is_xact_fwd, bool is_xact_allow_refwd, char *msg, unsigned int msg_len)
{
	const unsigned long __callno = __fs_method_vfs_do_get_slabinfo;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_do_get_slabinfo(rpc_info, NULL, msg, msg_len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_do_get_slabinfo(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, char *msg, unsigned int msg_len)
{
	const unsigned long __callno = __fs_method_vfs_do_get_slabinfo;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_do_get_slabinfo(__rref, rpc_info, NULL, msg, msg_len);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_do_get_slabinfo(char *msg, unsigned int msg_len)
{
	return actvxactcall_fscall_vfs_do_get_slabinfo(false, false, msg, msg_len);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_do_get_slabinfo(rref_t __rref, char *msg, unsigned int msg_len)
{
	return actvxactcapcall_fscall_vfs_do_get_slabinfo(false, false, __rref, msg, msg_len);
}

extern int __actvcall_fscall_vfs_fscache_print_info(unsigned long long __rpc_info, void *__buf, int count);


extern int __actvcapcall_fscall_vfs_fscache_print_info(rref_t __rref, unsigned long long __rpc_info, void *__buf, int count);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fscache_print_info(bool is_xact_fwd, bool is_xact_allow_refwd, int count)
{
	const unsigned long __callno = __fs_method_vfs_fscache_print_info;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fscache_print_info(rpc_info, NULL, count);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fscache_print_info(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int count)
{
	const unsigned long __callno = __fs_method_vfs_fscache_print_info;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fscache_print_info(__rref, rpc_info, NULL, count);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fscache_print_info(int count)
{
	return actvxactcall_fscall_vfs_fscache_print_info(false, false, count);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fscache_print_info(rref_t __rref, int count)
{
	return actvxactcapcall_fscall_vfs_fscache_print_info(false, false, __rref, count);
}

extern int __actvcall_fscall_vfs_alloc_fs_handle_for_same_device(unsigned long long __rpc_info, void *__buf, int me_idx, int new_me_idx, unsigned long flags);


extern int __actvcapcall_fscall_vfs_alloc_fs_handle_for_same_device(rref_t __rref, unsigned long long __rpc_info, void *__buf, int me_idx, int new_me_idx, unsigned long flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_alloc_fs_handle_for_same_device(bool is_xact_fwd, bool is_xact_allow_refwd, int me_idx, int new_me_idx, unsigned long flags, struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device *__ret)
{
	const unsigned long __callno = __fs_method_vfs_alloc_fs_handle_for_same_device;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_alloc_fs_handle_for_same_device(rpc_info, __ret, me_idx, new_me_idx, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_alloc_fs_handle_for_same_device(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int me_idx, int new_me_idx, unsigned long flags, struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device *__ret)
{
	const unsigned long __callno = __fs_method_vfs_alloc_fs_handle_for_same_device;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_alloc_fs_handle_for_same_device(__rref, rpc_info, __ret, me_idx, new_me_idx, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_alloc_fs_handle_for_same_device(int me_idx, int new_me_idx, unsigned long flags, struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device *__ret)
{
	return actvxactcall_fscall_vfs_alloc_fs_handle_for_same_device(false, false, me_idx, new_me_idx, flags, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_alloc_fs_handle_for_same_device(rref_t __rref, int me_idx, int new_me_idx, unsigned long flags, struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device *__ret)
{
	return actvxactcapcall_fscall_vfs_alloc_fs_handle_for_same_device(false, false, __rref, me_idx, new_me_idx, flags, __ret);
}

extern int __actvcall_fscall_vfs_free_fs_handle_for_same_device(unsigned long long __rpc_info, void *__buf, int me_idx, unsigned int fs_handle);


extern int __actvcapcall_fscall_vfs_free_fs_handle_for_same_device(rref_t __rref, unsigned long long __rpc_info, void *__buf, int me_idx, unsigned int fs_handle);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_free_fs_handle_for_same_device(bool is_xact_fwd, bool is_xact_allow_refwd, int me_idx, unsigned int fs_handle)
{
	const unsigned long __callno = __fs_method_vfs_free_fs_handle_for_same_device;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_free_fs_handle_for_same_device(rpc_info, NULL, me_idx, fs_handle);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_free_fs_handle_for_same_device(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int me_idx, unsigned int fs_handle)
{
	const unsigned long __callno = __fs_method_vfs_free_fs_handle_for_same_device;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_free_fs_handle_for_same_device(__rref, rpc_info, NULL, me_idx, fs_handle);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_free_fs_handle_for_same_device(int me_idx, unsigned int fs_handle)
{
	return actvxactcall_fscall_vfs_free_fs_handle_for_same_device(false, false, me_idx, fs_handle);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_free_fs_handle_for_same_device(rref_t __rref, int me_idx, unsigned int fs_handle)
{
	return actvxactcapcall_fscall_vfs_free_fs_handle_for_same_device(false, false, __rref, me_idx, fs_handle);
}

extern int __actvcall_fscall_vfs_memfd_create(unsigned long long __rpc_info, void *__buf, int fd, unsigned int flags);


extern int __actvcapcall_fscall_vfs_memfd_create(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_memfd_create(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int flags, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_memfd_create;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_memfd_create(rpc_info, ___void_buf, fd, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_memfd_create(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int flags, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_memfd_create;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_memfd_create(__rref, rpc_info, ___void_buf, fd, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_memfd_create(int fd, unsigned int flags, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_memfd_create(false, false, fd, flags, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_memfd_create(rref_t __rref, int fd, unsigned int flags, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_memfd_create(false, false, __rref, fd, flags, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_mknod(unsigned long long __rpc_info, void *__buf, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_mknod(rref_t __rref, unsigned long long __rpc_info, void *__buf, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mknod(bool is_xact_fwd, bool is_xact_allow_refwd, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_mknod;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mknod(rpc_info, ___void_buf, parent_fd, devno, mode, msg, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mknod(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_mknod;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mknod(__rref, rpc_info, ___void_buf, parent_fd, devno, mode, msg, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mknod(int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_mknod(false, false, parent_fd, devno, mode, msg, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mknod(rref_t __rref, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_mknod(false, false, __rref, parent_fd, devno, mode, msg, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_rename(unsigned long long __rpc_info, void *__buf, int old_pfd, int new_pfd);


extern int __actvcapcall_fscall_vfs_rename(rref_t __rref, unsigned long long __rpc_info, void *__buf, int old_pfd, int new_pfd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_rename(bool is_xact_fwd, bool is_xact_allow_refwd, int old_pfd, int new_pfd, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_rename;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_rename(rpc_info, ___void_buf, old_pfd, new_pfd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_rename(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int old_pfd, int new_pfd, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_rename;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_rename(__rref, rpc_info, ___void_buf, old_pfd, new_pfd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_rename(int old_pfd, int new_pfd, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_rename(false, false, old_pfd, new_pfd, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_rename(rref_t __rref, int old_pfd, int new_pfd, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_rename(false, false, __rref, old_pfd, new_pfd, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_mkdirat(unsigned long long __rpc_info, void *__buf, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_mkdirat(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mkdirat(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_mkdirat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mkdirat(rpc_info, ___void_buf, dfd, mode, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mkdirat(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_mkdirat;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mkdirat(__rref, rpc_info, ___void_buf, dfd, mode, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mkdirat(int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_mkdirat(false, false, dfd, mode, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mkdirat(rref_t __rref, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_mkdirat(false, false, __rref, dfd, mode, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_link(unsigned long long __rpc_info, void *__buf, int old_pfd, int new_pfd);


extern int __actvcapcall_fscall_vfs_link(rref_t __rref, unsigned long long __rpc_info, void *__buf, int old_pfd, int new_pfd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_link(bool is_xact_fwd, bool is_xact_allow_refwd, int old_pfd, int new_pfd, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_link;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_link(rpc_info, ___void_buf, old_pfd, new_pfd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_link(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int old_pfd, int new_pfd, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_link;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_link(__rref, rpc_info, ___void_buf, old_pfd, new_pfd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_link(int old_pfd, int new_pfd, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_link(false, false, old_pfd, new_pfd, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_link(rref_t __rref, int old_pfd, int new_pfd, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_link(false, false, __rref, old_pfd, new_pfd, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_unlink(unsigned long long __rpc_info, void *__buf, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_unlink(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_unlink(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_unlink;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_unlink(rpc_info, ___void_buf, dfd, flag, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_unlink(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_unlink;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_unlink(__rref, rpc_info, ___void_buf, dfd, flag, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_unlink(int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_unlink(false, false, dfd, flag, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_unlink(rref_t __rref, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_unlink(false, false, __rref, dfd, flag, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_symlink(unsigned long long __rpc_info, void *__buf, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_symlink(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_symlink(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_symlink;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_symlink(rpc_info, ___void_buf, dfd, target, tarlen, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_symlink(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_symlink;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_symlink(__rref, rpc_info, ___void_buf, dfd, target, tarlen, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_symlink(int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_symlink(false, false, dfd, target, tarlen, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_symlink(rref_t __rref, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_symlink(false, false, __rref, dfd, target, tarlen, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_getxattr(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_getxattr(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_getxattr(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_getxattr *__ret)
{
	const unsigned long __callno = __fs_method_vfs_getxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysif_getxattr_args), __arch_actv_rpc_stksz_alignment(struct sysif_getxattr_args));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_getxattr(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, pcnode_idx, cnode_idx, dfd, sga, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_getxattr(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_getxattr *__ret)
{
	const unsigned long __callno = __fs_method_vfs_getxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysif_getxattr_args), __arch_actv_rpc_stksz_alignment(struct sysif_getxattr_args));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_getxattr(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, pcnode_idx, cnode_idx, dfd, sga, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_getxattr(unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_getxattr *__ret)
{
	return actvxactcall_fscall_vfs_getxattr(false, false, pcnode_idx, cnode_idx, dfd, sga, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_getxattr(rref_t __rref, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_getxattr *__ret)
{
	return actvxactcapcall_fscall_vfs_getxattr(false, false, __rref, pcnode_idx, cnode_idx, dfd, sga, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_vfs_fgetxattr(unsigned long long __rpc_info, void *__buf, int fd, const char *name, size_t namelen, void *value, size_t size);


extern int __actvcapcall_fscall_vfs_fgetxattr(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const char *name, size_t namelen, void *value, size_t size);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fgetxattr(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const char *name, size_t namelen, void *value, size_t size, struct __actvret_fscall_vfs_fgetxattr *__ret)
{
	const unsigned long __callno = __fs_method_vfs_fgetxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fgetxattr(rpc_info, __ret, fd, name, namelen, value, size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fgetxattr(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const char *name, size_t namelen, void *value, size_t size, struct __actvret_fscall_vfs_fgetxattr *__ret)
{
	const unsigned long __callno = __fs_method_vfs_fgetxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fgetxattr(__rref, rpc_info, __ret, fd, name, namelen, value, size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fgetxattr(int fd, const char *name, size_t namelen, void *value, size_t size, struct __actvret_fscall_vfs_fgetxattr *__ret)
{
	return actvxactcall_fscall_vfs_fgetxattr(false, false, fd, name, namelen, value, size, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fgetxattr(rref_t __rref, int fd, const char *name, size_t namelen, void *value, size_t size, struct __actvret_fscall_vfs_fgetxattr *__ret)
{
	return actvxactcapcall_fscall_vfs_fgetxattr(false, false, __rref, fd, name, namelen, value, size, __ret);
}

extern int __actvcall_fscall_vfs_setxattr(unsigned long long __rpc_info, void *__buf, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_setxattr(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_setxattr(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_setxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_setxattr(rpc_info, ___void_buf, dfd, name, namelen, value, size, flags, walk_flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_setxattr(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_setxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_setxattr(__rref, rpc_info, ___void_buf, dfd, name, namelen, value, size, flags, walk_flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_setxattr(int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_setxattr(false, false, dfd, name, namelen, value, size, flags, walk_flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_setxattr(rref_t __rref, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_setxattr(false, false, __rref, dfd, name, namelen, value, size, flags, walk_flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_fsetxattr(unsigned long long __rpc_info, void *__buf, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);


extern int __actvcapcall_fscall_vfs_fsetxattr(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fsetxattr(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	const unsigned long __callno = __fs_method_vfs_fsetxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fsetxattr(rpc_info, NULL, fd, name, namelen, value, size, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fsetxattr(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	const unsigned long __callno = __fs_method_vfs_fsetxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fsetxattr(__rref, rpc_info, NULL, fd, name, namelen, value, size, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fsetxattr(int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	return actvxactcall_fscall_vfs_fsetxattr(false, false, fd, name, namelen, value, size, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fsetxattr(rref_t __rref, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	return actvxactcapcall_fscall_vfs_fsetxattr(false, false, __rref, fd, name, namelen, value, size, flags);
}

extern int __actvcall_fscall_vfs_listxattr(unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_listxattr(rref_t __rref, unsigned long long __rpc_info, void *__buf, void *__rply_buf, unsigned long rply_buf_sz, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_listxattr(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_listxattr *__ret)
{
	const unsigned long __callno = __fs_method_vfs_listxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_listxattr(rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, dfd, list, size, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_listxattr(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_listxattr *__ret)
{
	const unsigned long __callno = __fs_method_vfs_listxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_listxattr(__rref, rpc_info, ___void_buf, ptr_to_void(__ret), sizeof*__ret, dfd, list, size, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_listxattr(int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_listxattr *__ret)
{
	return actvxactcall_fscall_vfs_listxattr(false, false, dfd, list, size, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_listxattr(rref_t __rref, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz, struct __actvret_fscall_vfs_listxattr *__ret)
{
	return actvxactcapcall_fscall_vfs_listxattr(false, false, __rref, dfd, list, size, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz, __ret);
}

extern int __actvcall_fscall_vfs_flistxattr(unsigned long long __rpc_info, void *__buf, int fd, char *list, size_t size);


extern int __actvcapcall_fscall_vfs_flistxattr(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, char *list, size_t size);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_flistxattr(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, char *list, size_t size, struct __actvret_fscall_vfs_flistxattr *__ret)
{
	const unsigned long __callno = __fs_method_vfs_flistxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_flistxattr(rpc_info, __ret, fd, list, size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_flistxattr(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, char *list, size_t size, struct __actvret_fscall_vfs_flistxattr *__ret)
{
	const unsigned long __callno = __fs_method_vfs_flistxattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_flistxattr(__rref, rpc_info, __ret, fd, list, size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_flistxattr(int fd, char *list, size_t size, struct __actvret_fscall_vfs_flistxattr *__ret)
{
	return actvxactcall_fscall_vfs_flistxattr(false, false, fd, list, size, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_flistxattr(rref_t __rref, int fd, char *list, size_t size, struct __actvret_fscall_vfs_flistxattr *__ret)
{
	return actvxactcapcall_fscall_vfs_flistxattr(false, false, __rref, fd, list, size, __ret);
}

extern int __actvcall_fscall_vfs_removexattr(unsigned long long __rpc_info, void *__buf, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvcapcall_fscall_vfs_removexattr(rref_t __rref, unsigned long long __rpc_info, void *__buf, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_removexattr(bool is_xact_fwd, bool is_xact_allow_refwd, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_removexattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_removexattr(rpc_info, ___void_buf, dfd, name, namelen, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_removexattr(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_removexattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_removexattr(__rref, rpc_info, ___void_buf, dfd, name, namelen, flags, newpath, new_server, me_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_removexattr(int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_removexattr(false, false, dfd, name, namelen, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_removexattr(rref_t __rref, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_removexattr(false, false, __rref, dfd, name, namelen, flags, newpath, new_server, me_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_fremovexattr(unsigned long long __rpc_info, void *__buf, int fd, const char *name, size_t namelen);


extern int __actvcapcall_fscall_vfs_fremovexattr(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, const char *name, size_t namelen);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fremovexattr(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, const char *name, size_t namelen)
{
	const unsigned long __callno = __fs_method_vfs_fremovexattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fremovexattr(rpc_info, NULL, fd, name, namelen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fremovexattr(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, const char *name, size_t namelen)
{
	const unsigned long __callno = __fs_method_vfs_fremovexattr;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fremovexattr(__rref, rpc_info, NULL, fd, name, namelen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fremovexattr(int fd, const char *name, size_t namelen)
{
	return actvxactcall_fscall_vfs_fremovexattr(false, false, fd, name, namelen);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fremovexattr(rref_t __rref, int fd, const char *name, size_t namelen)
{
	return actvxactcapcall_fscall_vfs_fremovexattr(false, false, __rref, fd, name, namelen);
}

extern int __actvcall_fscall_vfs_iommap(unsigned long long __rpc_info, void *__buf, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);


extern int __actvcapcall_fscall_vfs_iommap(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_iommap(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset, struct __actvret_fscall_vfs_iommap *__ret)
{
	const unsigned long __callno = __fs_method_vfs_iommap;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(rref_t), __arch_actv_rpc_stksz_alignment(rref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_iommap(rpc_info, __ret, fd, vs_rref, vs_cnode_idx, vaddr, aligned_len, prot, flags, offset);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_iommap(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset, struct __actvret_fscall_vfs_iommap *__ret)
{
	const unsigned long __callno = __fs_method_vfs_iommap;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(rref_t), __arch_actv_rpc_stksz_alignment(rref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_iommap(__rref, rpc_info, __ret, fd, vs_rref, vs_cnode_idx, vaddr, aligned_len, prot, flags, offset);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_iommap(int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset, struct __actvret_fscall_vfs_iommap *__ret)
{
	return actvxactcall_fscall_vfs_iommap(false, false, fd, vs_rref, vs_cnode_idx, vaddr, aligned_len, prot, flags, offset, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_iommap(rref_t __rref, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset, struct __actvret_fscall_vfs_iommap *__ret)
{
	return actvxactcapcall_fscall_vfs_iommap(false, false, __rref, fd, vs_rref, vs_cnode_idx, vaddr, aligned_len, prot, flags, offset, __ret);
}

extern int __actvcall_fscall_vfs_mmap_create(unsigned long long __rpc_info, void *__buf, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);


extern int __actvcapcall_fscall_vfs_mmap_create(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mmap_create(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags, struct __actvret_fscall_vfs_mmap_create *__ret)
{
	const unsigned long __callno = __fs_method_vfs_mmap_create;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mmap_create(rpc_info, __ret, fd, offset, len, cnode_idx, prot, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mmap_create(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags, struct __actvret_fscall_vfs_mmap_create *__ret)
{
	const unsigned long __callno = __fs_method_vfs_mmap_create;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mmap_create(__rref, rpc_info, __ret, fd, offset, len, cnode_idx, prot, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mmap_create(int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags, struct __actvret_fscall_vfs_mmap_create *__ret)
{
	return actvxactcall_fscall_vfs_mmap_create(false, false, fd, offset, len, cnode_idx, prot, flags, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mmap_create(rref_t __rref, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags, struct __actvret_fscall_vfs_mmap_create *__ret)
{
	return actvxactcapcall_fscall_vfs_mmap_create(false, false, __rref, fd, offset, len, cnode_idx, prot, flags, __ret);
}

extern int __actvcall_fscall_vfs_mmap_release_file(unsigned long long __rpc_info, void *__buf, int fid, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_mmap_release_file(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fid, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mmap_release_file(bool is_xact_fwd, bool is_xact_allow_refwd, int fid, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_mmap_release_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mmap_release_file(rpc_info, NULL, fid, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mmap_release_file(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fid, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_mmap_release_file;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mmap_release_file(__rref, rpc_info, NULL, fid, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mmap_release_file(int fid, unsigned int cnode_idx)
{
	return actvxactcall_fscall_vfs_mmap_release_file(false, false, fid, cnode_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mmap_release_file(rref_t __rref, int fid, unsigned int cnode_idx)
{
	return actvxactcapcall_fscall_vfs_mmap_release_file(false, false, __rref, fid, cnode_idx);
}

extern int __actvcall_fscall_vfs_mmap_change(unsigned long long __rpc_info, void *__buf, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);


extern int __actvcapcall_fscall_vfs_mmap_change(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mmap_change(bool is_xact_fwd, bool is_xact_allow_refwd, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	const unsigned long __callno = __fs_method_vfs_mmap_change;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mmap_change(rpc_info, NULL, fid, offset, len, cnode_idx, prot);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mmap_change(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	const unsigned long __callno = __fs_method_vfs_mmap_change;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mmap_change(__rref, rpc_info, NULL, fid, offset, len, cnode_idx, prot);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mmap_change(int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	return actvxactcall_fscall_vfs_mmap_change(false, false, fid, offset, len, cnode_idx, prot);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mmap_change(rref_t __rref, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	return actvxactcapcall_fscall_vfs_mmap_change(false, false, __rref, fid, offset, len, cnode_idx, prot);
}

extern int __actvcall_fscall_vfs_mmap_fill_page(unsigned long long __rpc_info, void *__buf, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);


extern int __actvcapcall_fscall_vfs_mmap_fill_page(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mmap_fill_page(bool is_xact_fwd, bool is_xact_allow_refwd, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags, struct __actvret_fscall_vfs_mmap_fill_page *__ret)
{
	const unsigned long __callno = __fs_method_vfs_mmap_fill_page;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mmap_fill_page(rpc_info, __ret, fid, node_page_idx, cnode_idx, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mmap_fill_page(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags, struct __actvret_fscall_vfs_mmap_fill_page *__ret)
{
	const unsigned long __callno = __fs_method_vfs_mmap_fill_page;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mmap_fill_page(__rref, rpc_info, __ret, fid, node_page_idx, cnode_idx, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mmap_fill_page(int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags, struct __actvret_fscall_vfs_mmap_fill_page *__ret)
{
	return actvxactcall_fscall_vfs_mmap_fill_page(false, false, fid, node_page_idx, cnode_idx, flags, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mmap_fill_page(rref_t __rref, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags, struct __actvret_fscall_vfs_mmap_fill_page *__ret)
{
	return actvxactcapcall_fscall_vfs_mmap_fill_page(false, false, __rref, fid, node_page_idx, cnode_idx, flags, __ret);
}

extern int __actvcall_fscall_vfs_mmap_fetch_page(unsigned long long __rpc_info, void *__buf, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_mmap_fetch_page(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mmap_fetch_page(bool is_xact_fwd, bool is_xact_allow_refwd, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, struct __actvret_fscall_vfs_mmap_fetch_page *__ret)
{
	const unsigned long __callno = __fs_method_vfs_mmap_fetch_page;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mmap_fetch_page(rpc_info, __ret, fid, node_page_idx, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mmap_fetch_page(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, struct __actvret_fscall_vfs_mmap_fetch_page *__ret)
{
	const unsigned long __callno = __fs_method_vfs_mmap_fetch_page;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mmap_fetch_page(__rref, rpc_info, __ret, fid, node_page_idx, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mmap_fetch_page(int fid, unsigned long long node_page_idx, unsigned int cnode_idx, struct __actvret_fscall_vfs_mmap_fetch_page *__ret)
{
	return actvxactcall_fscall_vfs_mmap_fetch_page(false, false, fid, node_page_idx, cnode_idx, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mmap_fetch_page(rref_t __rref, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, struct __actvret_fscall_vfs_mmap_fetch_page *__ret)
{
	return actvxactcapcall_fscall_vfs_mmap_fetch_page(false, false, __rref, fid, node_page_idx, cnode_idx, __ret);
}

extern int __actvcall_fscall_vfs_mmap_change_page(unsigned long long __rpc_info, void *__buf, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);


extern int __actvcapcall_fscall_vfs_mmap_change_page(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mmap_change_page(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	const unsigned long __callno = __fs_method_vfs_mmap_change_page;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mmap_change_page(rpc_info, NULL, index, dev_id, node_page_idx, flag);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mmap_change_page(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	const unsigned long __callno = __fs_method_vfs_mmap_change_page;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mmap_change_page(__rref, rpc_info, NULL, index, dev_id, node_page_idx, flag);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mmap_change_page(unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	return actvxactcall_fscall_vfs_mmap_change_page(false, false, index, dev_id, node_page_idx, flag);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mmap_change_page(rref_t __rref, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	return actvxactcapcall_fscall_vfs_mmap_change_page(false, false, __rref, index, dev_id, node_page_idx, flag);
}

extern int __actvcall_fscall_vfs_mmap_fallocate(unsigned long long __rpc_info, void *__buf, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_mmap_fallocate(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_mmap_fallocate(bool is_xact_fwd, bool is_xact_allow_refwd, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_mmap_fallocate;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_mmap_fallocate(rpc_info, NULL, fid, offset, length, mode, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_mmap_fallocate(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_mmap_fallocate;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_mmap_fallocate(__rref, rpc_info, NULL, fid, offset, length, mode, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_mmap_fallocate(int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	return actvxactcall_fscall_vfs_mmap_fallocate(false, false, fid, offset, length, mode, cnode_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_mmap_fallocate(rref_t __rref, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	return actvxactcapcall_fscall_vfs_mmap_fallocate(false, false, __rref, fid, offset, length, mode, cnode_idx);
}

extern int __actvcall_fscall_vfs_gfd_table_update(unsigned long long __rpc_info, void *__buf, int fd, int remote_index, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_gfd_table_update(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, int remote_index, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_gfd_table_update(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, int remote_index, unsigned int cnode_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_update;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_gfd_table_update(rpc_info, ___void_buf, fd, remote_index, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_gfd_table_update(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, int remote_index, unsigned int cnode_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_update;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, ___void_buf_sz, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_gfd_table_update(__rref, rpc_info, ___void_buf, fd, remote_index, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_gfd_table_update(int fd, int remote_index, unsigned int cnode_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcall_fscall_vfs_gfd_table_update(false, false, fd, remote_index, cnode_idx, ___void_buf, ___void_buf_sz);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_gfd_table_update(rref_t __rref, int fd, int remote_index, unsigned int cnode_idx, void *___void_buf, unsigned long ___void_buf_sz)
{
	return actvxactcapcall_fscall_vfs_gfd_table_update(false, false, __rref, fd, remote_index, cnode_idx, ___void_buf, ___void_buf_sz);
}

extern int __actvcall_fscall_vfs_gfd_table_remove(unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_gfd_table_remove(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_gfd_table_remove(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_remove;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_gfd_table_remove(rpc_info, NULL, fd, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_gfd_table_remove(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_remove;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_gfd_table_remove(__rref, rpc_info, NULL, fd, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_gfd_table_remove(int fd, unsigned int cnode_idx)
{
	return actvxactcall_fscall_vfs_gfd_table_remove(false, false, fd, cnode_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_gfd_table_remove(rref_t __rref, int fd, unsigned int cnode_idx)
{
	return actvxactcapcall_fscall_vfs_gfd_table_remove(false, false, __rref, fd, cnode_idx);
}

extern int __actvcall_fscall_vfs_gfd_table_expand(unsigned long long __rpc_info, void *__buf, unsigned int new_size);


extern int __actvcapcall_fscall_vfs_gfd_table_expand(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int new_size);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_gfd_table_expand(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int new_size)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_expand;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_gfd_table_expand(rpc_info, NULL, new_size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_gfd_table_expand(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int new_size)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_expand;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_gfd_table_expand(__rref, rpc_info, NULL, new_size);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_gfd_table_expand(unsigned int new_size)
{
	return actvxactcall_fscall_vfs_gfd_table_expand(false, false, new_size);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_gfd_table_expand(rref_t __rref, unsigned int new_size)
{
	return actvxactcapcall_fscall_vfs_gfd_table_expand(false, false, __rref, new_size);
}

extern int __actvcall_fscall_vfs_gfd_table_acquire(unsigned long long __rpc_info, void *__buf, int start, int type, unsigned int cnode_idx);


extern int __actvcapcall_fscall_vfs_gfd_table_acquire(rref_t __rref, unsigned long long __rpc_info, void *__buf, int start, int type, unsigned int cnode_idx);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_gfd_table_acquire(bool is_xact_fwd, bool is_xact_allow_refwd, int start, int type, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_acquire;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_gfd_table_acquire(rpc_info, NULL, start, type, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_gfd_table_acquire(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int start, int type, unsigned int cnode_idx)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_acquire;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_gfd_table_acquire(__rref, rpc_info, NULL, start, type, cnode_idx);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_gfd_table_acquire(int start, int type, unsigned int cnode_idx)
{
	return actvxactcall_fscall_vfs_gfd_table_acquire(false, false, start, type, cnode_idx);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_gfd_table_acquire(rref_t __rref, int start, int type, unsigned int cnode_idx)
{
	return actvxactcapcall_fscall_vfs_gfd_table_acquire(false, false, __rref, start, type, cnode_idx);
}

extern int __actvcall_fscall_vfs_gfd_table_release(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_gfd_table_release(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_gfd_table_release(bool is_xact_fwd, bool is_xact_allow_refwd, int fd)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_release;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_gfd_table_release(rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_gfd_table_release(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_release;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_gfd_table_release(__rref, rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_gfd_table_release(int fd)
{
	return actvxactcall_fscall_vfs_gfd_table_release(false, false, fd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_gfd_table_release(rref_t __rref, int fd)
{
	return actvxactcapcall_fscall_vfs_gfd_table_release(false, false, __rref, fd);
}

extern int __actvcall_fscall_vfs_gfd_table_replace(unsigned long long __rpc_info, void *__buf, int fd, int type);


extern int __actvcapcall_fscall_vfs_gfd_table_replace(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, int type);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_gfd_table_replace(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, int type)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_replace;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_gfd_table_replace(rpc_info, NULL, fd, type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_gfd_table_replace(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, int type)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_replace;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_gfd_table_replace(__rref, rpc_info, NULL, fd, type);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_gfd_table_replace(int fd, int type)
{
	return actvxactcall_fscall_vfs_gfd_table_replace(false, false, fd, type);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_gfd_table_replace(rref_t __rref, int fd, int type)
{
	return actvxactcapcall_fscall_vfs_gfd_table_replace(false, false, __rref, fd, type);
}

extern int __actvcall_fscall_vfs_gfd_table_fault(unsigned long long __rpc_info, void *__buf, int fd, char *pathname, int pathlen);


extern int __actvcapcall_fscall_vfs_gfd_table_fault(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, char *pathname, int pathlen);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_gfd_table_fault(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, char *pathname, int pathlen)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_fault;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_gfd_table_fault(rpc_info, NULL, fd, pathname, pathlen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_gfd_table_fault(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, char *pathname, int pathlen)
{
	const unsigned long __callno = __fs_method_vfs_gfd_table_fault;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_gfd_table_fault(__rref, rpc_info, NULL, fd, pathname, pathlen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_gfd_table_fault(int fd, char *pathname, int pathlen)
{
	return actvxactcall_fscall_vfs_gfd_table_fault(false, false, fd, pathname, pathlen);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_gfd_table_fault(rref_t __rref, int fd, char *pathname, int pathlen)
{
	return actvxactcapcall_fscall_vfs_gfd_table_fault(false, false, __rref, fd, pathname, pathlen);
}

extern int __actvcall_fscall_vfs_anon_register_devhost(unsigned long long __rpc_info, void *__buf, uref_t dh_ap_uref);


extern int __actvcapcall_fscall_vfs_anon_register_devhost(rref_t __rref, unsigned long long __rpc_info, void *__buf, uref_t dh_ap_uref);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_anon_register_devhost(bool is_xact_fwd, bool is_xact_allow_refwd, uref_t dh_ap_uref)
{
	const unsigned long __callno = __fs_method_vfs_anon_register_devhost;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_anon_register_devhost(rpc_info, NULL, dh_ap_uref);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_anon_register_devhost(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, uref_t dh_ap_uref)
{
	const unsigned long __callno = __fs_method_vfs_anon_register_devhost;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_anon_register_devhost(__rref, rpc_info, NULL, dh_ap_uref);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_anon_register_devhost(uref_t dh_ap_uref)
{
	return actvxactcall_fscall_vfs_anon_register_devhost(false, false, dh_ap_uref);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_anon_register_devhost(rref_t __rref, uref_t dh_ap_uref)
{
	return actvxactcapcall_fscall_vfs_anon_register_devhost(false, false, __rref, dh_ap_uref);
}

extern int __actvcall_fscall_vfs_get_unused_fd(unsigned long long __rpc_info, void *__buf, unsigned int flags);


extern int __actvcapcall_fscall_vfs_get_unused_fd(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int flags);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_unused_fd(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int flags)
{
	const unsigned long __callno = __fs_method_vfs_get_unused_fd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_unused_fd(rpc_info, NULL, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_unused_fd(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int flags)
{
	const unsigned long __callno = __fs_method_vfs_get_unused_fd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_unused_fd(__rref, rpc_info, NULL, flags);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_unused_fd(unsigned int flags)
{
	return actvxactcall_fscall_vfs_get_unused_fd(false, false, flags);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_unused_fd(rref_t __rref, unsigned int flags)
{
	return actvxactcapcall_fscall_vfs_get_unused_fd(false, false, __rref, flags);
}

extern int __actvcall_fscall_vfs_put_unused_fd(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_put_unused_fd(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_put_unused_fd(bool is_xact_fwd, bool is_xact_allow_refwd, int fd)
{
	const unsigned long __callno = __fs_method_vfs_put_unused_fd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_put_unused_fd(rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_put_unused_fd(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd)
{
	const unsigned long __callno = __fs_method_vfs_put_unused_fd;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_put_unused_fd(__rref, rpc_info, NULL, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_put_unused_fd(int fd)
{
	return actvxactcall_fscall_vfs_put_unused_fd(false, false, fd);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_put_unused_fd(rref_t __rref, int fd)
{
	return actvxactcapcall_fscall_vfs_put_unused_fd(false, false, __rref, fd);
}

extern int __actvcall_fscall_vfs_fd_info_update(unsigned long long __rpc_info, void *__buf, int fd, unsigned long long file_id);


extern int __actvcapcall_fscall_vfs_fd_info_update(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd, unsigned long long file_id);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_fd_info_update(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, unsigned long long file_id)
{
	const unsigned long __callno = __fs_method_vfs_fd_info_update;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_fd_info_update(rpc_info, NULL, fd, file_id);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_fd_info_update(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, unsigned long long file_id)
{
	const unsigned long __callno = __fs_method_vfs_fd_info_update;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_fd_info_update(__rref, rpc_info, NULL, fd, file_id);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_fd_info_update(int fd, unsigned long long file_id)
{
	return actvxactcall_fscall_vfs_fd_info_update(false, false, fd, file_id);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_fd_info_update(rref_t __rref, int fd, unsigned long long file_id)
{
	return actvxactcapcall_fscall_vfs_fd_info_update(false, false, __rref, fd, file_id);
}

extern int __actvcall_fscall_vfs_get_root_path(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, char *buf, int buflen);


extern int __actvcapcall_fscall_vfs_get_root_path(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, char *buf, int buflen);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_get_root_path(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, char *buf, int buflen)
{
	const unsigned long __callno = __fs_method_vfs_get_root_path;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_get_root_path(rpc_info, NULL, cnode_idx, buf, buflen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_get_root_path(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, char *buf, int buflen)
{
	const unsigned long __callno = __fs_method_vfs_get_root_path;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_get_root_path(__rref, rpc_info, NULL, cnode_idx, buf, buflen);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_get_root_path(unsigned int cnode_idx, char *buf, int buflen)
{
	return actvxactcall_fscall_vfs_get_root_path(false, false, cnode_idx, buf, buflen);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_get_root_path(rref_t __rref, unsigned int cnode_idx, char *buf, int buflen)
{
	return actvxactcapcall_fscall_vfs_get_root_path(false, false, __rref, cnode_idx, buf, buflen);
}

extern int __actvcall_fscall_vfs_transfs_fget(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_transfs_fget(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_transfs_fget(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, struct __actvret_fscall_vfs_transfs_fget *__ret)
{
	const unsigned long __callno = __fs_method_vfs_transfs_fget;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_transfs_fget(rpc_info, __ret, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_transfs_fget(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, struct __actvret_fscall_vfs_transfs_fget *__ret)
{
	const unsigned long __callno = __fs_method_vfs_transfs_fget;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_transfs_fget(__rref, rpc_info, __ret, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_transfs_fget(int fd, struct __actvret_fscall_vfs_transfs_fget *__ret)
{
	return actvxactcall_fscall_vfs_transfs_fget(false, false, fd, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_transfs_fget(rref_t __rref, int fd, struct __actvret_fscall_vfs_transfs_fget *__ret)
{
	return actvxactcapcall_fscall_vfs_transfs_fget(false, false, __rref, fd, __ret);
}

extern int __actvcall_fscall_vfs_do_trans_fget(unsigned long long __rpc_info, void *__buf, int fd);


extern int __actvcapcall_fscall_vfs_do_trans_fget(rref_t __rref, unsigned long long __rpc_info, void *__buf, int fd);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_do_trans_fget(bool is_xact_fwd, bool is_xact_allow_refwd, int fd, struct __actvret_fscall_vfs_do_trans_fget *__ret)
{
	const unsigned long __callno = __fs_method_vfs_do_trans_fget;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_do_trans_fget(rpc_info, __ret, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_do_trans_fget(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, int fd, struct __actvret_fscall_vfs_do_trans_fget *__ret)
{
	const unsigned long __callno = __fs_method_vfs_do_trans_fget;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_do_trans_fget(__rref, rpc_info, __ret, fd);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_do_trans_fget(int fd, struct __actvret_fscall_vfs_do_trans_fget *__ret)
{
	return actvxactcall_fscall_vfs_do_trans_fget(false, false, fd, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_do_trans_fget(rref_t __rref, int fd, struct __actvret_fscall_vfs_do_trans_fget *__ret)
{
	return actvxactcapcall_fscall_vfs_do_trans_fget(false, false, __rref, fd, __ret);
}

extern int __actvcall_fscall_vfs_transfs_fput(unsigned long long __rpc_info, void *__buf, unsigned int me_index, unsigned long long hm_filp);


extern int __actvcapcall_fscall_vfs_transfs_fput(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int me_index, unsigned long long hm_filp);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_transfs_fput(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int me_index, unsigned long long hm_filp)
{
	const unsigned long __callno = __fs_method_vfs_transfs_fput;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_transfs_fput(rpc_info, NULL, me_index, hm_filp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_transfs_fput(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int me_index, unsigned long long hm_filp)
{
	const unsigned long __callno = __fs_method_vfs_transfs_fput;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_transfs_fput(__rref, rpc_info, NULL, me_index, hm_filp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_transfs_fput(unsigned int me_index, unsigned long long hm_filp)
{
	return actvxactcall_fscall_vfs_transfs_fput(false, false, me_index, hm_filp);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_transfs_fput(rref_t __rref, unsigned int me_index, unsigned long long hm_filp)
{
	return actvxactcapcall_fscall_vfs_transfs_fput(false, false, __rref, me_index, hm_filp);
}

extern int __actvcall_fscall_vfs_do_trans_fput(unsigned long long __rpc_info, void *__buf, unsigned long long hm_filp);


extern int __actvcapcall_fscall_vfs_do_trans_fput(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned long long hm_filp);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_do_trans_fput(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned long long hm_filp)
{
	const unsigned long __callno = __fs_method_vfs_do_trans_fput;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_do_trans_fput(rpc_info, NULL, hm_filp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_do_trans_fput(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned long long hm_filp)
{
	const unsigned long __callno = __fs_method_vfs_do_trans_fput;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, 0UL, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_do_trans_fput(__rref, rpc_info, NULL, hm_filp);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_do_trans_fput(unsigned long long hm_filp)
{
	return actvxactcall_fscall_vfs_do_trans_fput(false, false, hm_filp);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_do_trans_fput(rref_t __rref, unsigned long long hm_filp)
{
	return actvxactcapcall_fscall_vfs_do_trans_fput(false, false, __rref, hm_filp);
}

extern int __actvcall_fscall_vfs_read_mounts(unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);


extern int __actvcapcall_fscall_vfs_read_mounts(rref_t __rref, unsigned long long __rpc_info, void *__buf, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);


static inline int __attribute__((always_inline)) actvxactcall_fscall_vfs_read_mounts(bool is_xact_fwd, bool is_xact_allow_refwd, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname, struct __actvret_fscall_vfs_read_mounts *__ret)
{
	const unsigned long __callno = __fs_method_vfs_read_mounts;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcall_fscall_vfs_read_mounts(rpc_info, __ret, cnode_idx, buf, buflen, srvname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvxactcapcall_fscall_vfs_read_mounts(bool is_xact_fwd, bool is_xact_allow_refwd, rref_t __rref, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname, struct __actvret_fscall_vfs_read_mounts *__ret)
{
	const unsigned long __callno = __fs_method_vfs_read_mounts;
	int __res;
	unsigned long __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	do {
		unsigned long long rpc_info = __arch_actv_xact_rpc_info_gen(is_xact_fwd, is_xact_allow_refwd, __callno, sizeof*__ret, __stacksz / sizeof(unsigned long));
		__res = __actvcapcall_fscall_vfs_read_mounts(__rref, rpc_info, __ret, cnode_idx, buf, buflen, srvname);
	} while (__res == (int)E_HM_ACTIVATION_RPC_RETRY);
	return __res;
}

static inline int __attribute__((always_inline)) actvcall_fscall_vfs_read_mounts(unsigned int cnode_idx, char *buf, size_t buflen, char *srvname, struct __actvret_fscall_vfs_read_mounts *__ret)
{
	return actvxactcall_fscall_vfs_read_mounts(false, false, cnode_idx, buf, buflen, srvname, __ret);
}

static inline int __attribute__((always_inline)) actvcapcall_fscall_vfs_read_mounts(rref_t __rref, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname, struct __actvret_fscall_vfs_read_mounts *__ret)
{
	return actvxactcapcall_fscall_vfs_read_mounts(false, false, __rref, cnode_idx, buf, buflen, srvname, __ret);
}

#endif
#ifdef __sysif_server_fs_no_compat32_handlers__
# define __fs_method_MAX __fs_method_MAX_NOCOMPAT
#else
# define __fs_method_MAX __fs_method_MAX_COMPAT
#endif
#include <libsysif/utils.h>
#include <asm/actv_rpc.h>
#include <asm/types.h>
#ifndef __ARCH_RPC_REQUIRE_BRIDGE_HDLR
extern int actvhdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);


extern int actvhdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, const char *pathname);


extern int actvhdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);


extern int actvhdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);


extern int actvhdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);


extern int actvhdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);


extern int actvhdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);


extern int actvhdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, const char *pathname);


extern int actvhdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential);


extern int actvhdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);


extern int actvhdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);


extern int actvhdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);


extern int actvhdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, int fd, unsigned long tx);


extern int actvhdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);


extern int actvhdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, int fd, unsigned int mask, int me_idx);


extern int actvhdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, int fd, int wd);


extern int actvhdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);


extern int actvhdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);


extern int actvhdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);


extern int actvhdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);


extern int actvhdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);


extern int actvhdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);


extern int actvhdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);


extern int actvhdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);


extern int actvhdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);


extern int actvhdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);


extern int actvhdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, unsigned long long dev_id);


extern int actvhdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, int fd, unsigned long long label);


extern int actvhdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential);


extern int actvhdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);


extern int actvhdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx);


extern int actvhdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen);


extern int actvhdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2);


extern int actvhdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, int old_fd, int new_fd);


extern int actvhdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);


extern int actvhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);


extern int actvhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);


extern int actvhdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, int me_idx);


extern int actvhdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir);


extern int actvhdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid);


extern int actvhdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, int fd, unsigned long long length);


extern int actvhdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, int fd, void *st);


extern int actvhdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, int fd, void *msg);


extern int actvhdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);


extern int actvhdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);


extern int actvhdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst);


extern int actvhdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence);


extern int actvhdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte);


extern int actvhdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags);


extern int actvhdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags);


extern int actvhdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);


extern int actvhdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len);


extern int actvhdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);


extern int actvhdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);


extern int actvhdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags);


extern int actvhdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags);


extern int actvhdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags);


extern int actvhdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);


extern int actvhdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);


extern int actvhdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd);


extern int actvhdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg);


extern int actvhdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf);


extern int actvhdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);


extern int actvhdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, char *buf, size_t size);


extern int actvhdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);


extern int actvhdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size);


extern int actvhdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len);


extern int actvhdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);


extern int actvhdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential);


extern int actvhdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, int me_idx);


extern int actvhdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, int fd, const void *tsp);


extern int actvhdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, int fd, mode_t mode);


extern int actvhdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);


extern int actvhdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);


extern int actvhdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice);


extern int actvhdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count);


extern int actvhdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen);


extern int actvhdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path);


extern int actvhdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg);


extern int actvhdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen);


extern int actvhdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);


extern int actvhdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);


extern int actvhdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, int fd1, int fd2);


extern int actvhdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd);


extern int actvhdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid);


extern int actvhdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key);


extern int actvhdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags);


extern int actvhdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info);


extern int actvhdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info);


extern int actvhdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);


extern int actvhdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt);


extern int actvhdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, unsigned int pid);


extern int actvhdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode);


extern int actvhdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, int type);


extern int actvhdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type);


extern int actvhdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);


extern int actvhdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);


extern int actvhdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);


extern int actvhdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr);


extern int actvhdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname);


extern int actvhdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);


extern int actvhdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);


extern int actvhdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);


extern int actvhdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, int count);


extern int actvhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags);


extern int actvhdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle);


extern int actvhdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);


extern int actvhdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);


extern int actvhdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);


extern int actvhdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size);


extern int actvhdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);


extern int actvhdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size);


extern int actvhdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int actvhdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen);


extern int actvhdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);


extern int actvhdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);


extern int actvhdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);


extern int actvhdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);


extern int actvhdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);


extern int actvhdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, unsigned int new_size);


extern int actvhdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx);


extern int actvhdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, int fd, int type);


extern int actvhdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen);


extern int actvhdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref);


extern int actvhdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, unsigned int flags);


extern int actvhdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id);


extern int actvhdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen);


extern int actvhdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, int fd);


extern int actvhdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp);


extern int actvhdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, unsigned long long hm_filp);


extern int actvhdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);


#else
extern int actvhdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);


extern int __actvshadowhdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, const char *pathname);


extern int __actvshadowhdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);


extern int __actvshadowhdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);


extern int __actvshadowhdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);


extern int __actvshadowhdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);


extern int __actvshadowhdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, const char *pathname);


extern int __actvshadowhdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential);


extern int __actvshadowhdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);


extern int __actvshadowhdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);


extern int __actvshadowhdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);


extern int __actvshadowhdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, int fd, unsigned long tx);


extern int __actvshadowhdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);


extern int __actvshadowhdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, int fd, unsigned int mask, int me_idx);


extern int __actvshadowhdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, int fd, int wd);


extern int __actvshadowhdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);


extern int __actvshadowhdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);


extern int __actvshadowhdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);


extern int __actvshadowhdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);


extern int __actvshadowhdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);


extern int __actvshadowhdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);


extern int __actvshadowhdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);


extern int __actvshadowhdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);


extern int __actvshadowhdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);


extern int __actvshadowhdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);


extern int __actvshadowhdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, unsigned long long dev_id);


extern int __actvshadowhdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, int fd, unsigned long long label);


extern int __actvshadowhdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential);


extern int __actvshadowhdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);


extern int __actvshadowhdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx);


extern int __actvshadowhdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen);


extern int __actvshadowhdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2);


extern int __actvshadowhdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, int old_fd, int new_fd);


extern int __actvshadowhdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);


extern int __actvshadowhdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);


extern int __actvshadowhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);


extern int __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, int me_idx);


extern int __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir);


extern int __actvshadowhdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid);


extern int __actvshadowhdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, int fd, unsigned long long length);


extern int __actvshadowhdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, int fd, void *st);


extern int __actvshadowhdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, int fd, void *msg);


extern int __actvshadowhdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);


extern int __actvshadowhdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);


extern int __actvshadowhdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst);


extern int __actvshadowhdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence);


extern int __actvshadowhdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte);


extern int __actvshadowhdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags);


extern int __actvshadowhdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags);


extern int __actvshadowhdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);


extern int __actvshadowhdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len);


extern int __actvshadowhdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);


extern int __actvshadowhdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);


extern int __actvshadowhdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags);


extern int __actvshadowhdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags);


extern int __actvshadowhdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags);


extern int __actvshadowhdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);


extern int __actvshadowhdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);


extern int __actvshadowhdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd);


extern int __actvshadowhdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg);


extern int __actvshadowhdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf);


extern int __actvshadowhdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);


extern int __actvshadowhdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, char *buf, size_t size);


extern int __actvshadowhdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);


extern int __actvshadowhdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size);


extern int __actvshadowhdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len);


extern int __actvshadowhdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);


extern int __actvshadowhdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential);


extern int __actvshadowhdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, int me_idx);


extern int __actvshadowhdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, int fd, const void *tsp);


extern int __actvshadowhdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, int fd, mode_t mode);


extern int __actvshadowhdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);


extern int __actvshadowhdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);


extern int __actvshadowhdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice);


extern int __actvshadowhdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count);


extern int __actvshadowhdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen);


extern int __actvshadowhdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path);


extern int __actvshadowhdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg);


extern int __actvshadowhdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen);


extern int __actvshadowhdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);


extern int __actvshadowhdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);


extern int __actvshadowhdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, int fd1, int fd2);


extern int __actvshadowhdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd);


extern int __actvshadowhdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid);


extern int __actvshadowhdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key);


extern int __actvshadowhdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags);


extern int __actvshadowhdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info);


extern int __actvshadowhdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info);


extern int __actvshadowhdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);


extern int __actvshadowhdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt);


extern int __actvshadowhdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, unsigned int pid);


extern int __actvshadowhdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode);


extern int __actvshadowhdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, int type);


extern int __actvshadowhdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type);


extern int __actvshadowhdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);


extern int __actvshadowhdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);


extern int __actvshadowhdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);


extern int __actvshadowhdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr);


extern int __actvshadowhdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname);


extern int __actvshadowhdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);


extern int __actvshadowhdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);


extern int __actvshadowhdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);


extern int __actvshadowhdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, int count);


extern int __actvshadowhdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags);


extern int __actvshadowhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle);


extern int __actvshadowhdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);


extern int __actvshadowhdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);


extern int __actvshadowhdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);


extern int __actvshadowhdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size);


extern int __actvshadowhdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);


extern int __actvshadowhdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size);


extern int __actvshadowhdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);


extern int __actvshadowhdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen);


extern int __actvshadowhdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);


extern int __actvshadowhdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);


extern int __actvshadowhdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);


extern int __actvshadowhdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);


extern int __actvshadowhdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);


extern int __actvshadowhdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, unsigned int new_size);


extern int __actvshadowhdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx);


extern int __actvshadowhdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, int fd, int type);


extern int __actvshadowhdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen);


extern int __actvshadowhdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref);


extern int __actvshadowhdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, unsigned int flags);


extern int __actvshadowhdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id);


extern int __actvshadowhdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen);


extern int __actvshadowhdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, int fd);


extern int __actvshadowhdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp);


extern int __actvshadowhdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, unsigned long long hm_filp);


extern int __actvshadowhdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, ...);


extern int actvhdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);


extern int __actvshadowhdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, ...);


#endif
static inline struct __actvret_fscall_procfs_create_data* actvhdlr_fshandler_procfs_create_data_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_procfs_create_data));
	return (struct __actvret_fscall_procfs_create_data*)__ret;
}

static inline struct __actvret_fscall_procfs_delete_data* actvhdlr_fshandler_procfs_delete_data_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_procfs_delete_data));
	return (struct __actvret_fscall_procfs_delete_data*)__ret;
}

static inline struct __actvret_fscall_procfs_get_process_fds* actvhdlr_fshandler_procfs_get_process_fds_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_procfs_get_process_fds));
	return (struct __actvret_fscall_procfs_get_process_fds*)__ret;
}

static inline struct __actvret_fscall_procfs_get_fd_mode* actvhdlr_fshandler_procfs_get_fd_mode_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_procfs_get_fd_mode));
	return (struct __actvret_fscall_procfs_get_fd_mode*)__ret;
}

static inline struct __actvret_fscall_sysfs_create_file* actvhdlr_fshandler_sysfs_create_file_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_sysfs_create_file));
	return (struct __actvret_fscall_sysfs_create_file*)__ret;
}

static inline struct __actvret_fscall_sysfs_create_dir* actvhdlr_fshandler_sysfs_create_dir_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_sysfs_create_dir));
	return (struct __actvret_fscall_sysfs_create_dir*)__ret;
}

static inline struct __actvret_fscall_sysfs_create_symlink* actvhdlr_fshandler_sysfs_create_symlink_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_sysfs_create_symlink));
	return (struct __actvret_fscall_sysfs_create_symlink*)__ret;
}

static inline struct __actvret_fscall_sysfs_delete* actvhdlr_fshandler_sysfs_delete_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_sysfs_delete));
	return (struct __actvret_fscall_sysfs_delete*)__ret;
}

static inline struct __actvret_fscall_sysfs_notify* actvhdlr_fshandler_sysfs_notify_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_sysfs_notify));
	return (struct __actvret_fscall_sysfs_notify*)__ret;
}

static inline struct __actvret_fscall_clock_settime* actvhdlr_fshandler_clock_settime_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_clock_settime));
	return (struct __actvret_fscall_clock_settime*)__ret;
}

static inline struct __actvret_fscall_clock_gettime* actvhdlr_fshandler_clock_gettime_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_clock_gettime));
	return (struct __actvret_fscall_clock_gettime*)__ret;
}

static inline struct __actvret_fscall_clock_getres* actvhdlr_fshandler_clock_getres_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_clock_getres));
	return (struct __actvret_fscall_clock_getres*)__ret;
}

static inline struct __actvret_fscall_clock_adjtime* actvhdlr_fshandler_clock_adjtime_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_clock_adjtime));
	return (struct __actvret_fscall_clock_adjtime*)__ret;
}

static inline struct __actvret_fscall_inotify_init1* actvhdlr_fshandler_inotify_init1_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_inotify_init1));
	return (struct __actvret_fscall_inotify_init1*)__ret;
}

static inline struct __actvret_fscall_inotify_add_watch* actvhdlr_fshandler_inotify_add_watch_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_inotify_add_watch));
	return (struct __actvret_fscall_inotify_add_watch*)__ret;
}

static inline struct __actvret_fscall_inotify_rm_watch* actvhdlr_fshandler_inotify_rm_watch_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_inotify_rm_watch));
	return (struct __actvret_fscall_inotify_rm_watch*)__ret;
}

static inline struct __actvret_fscall_inotify_add_watch_internal* actvhdlr_fshandler_inotify_add_watch_internal_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_inotify_add_watch_internal));
	return (struct __actvret_fscall_inotify_add_watch_internal*)__ret;
}

static inline struct __actvret_fscall_inotify_rm_watch_internal* actvhdlr_fshandler_inotify_rm_watch_internal_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_inotify_rm_watch_internal));
	return (struct __actvret_fscall_inotify_rm_watch_internal*)__ret;
}

static inline struct __actvret_fscall_inotify_notify* actvhdlr_fshandler_inotify_notify_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_inotify_notify));
	return (struct __actvret_fscall_inotify_notify*)__ret;
}

static inline struct __actvret_fscall_inotify_inode_destroyed* actvhdlr_fshandler_inotify_inode_destroyed_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_inotify_inode_destroyed));
	return (struct __actvret_fscall_inotify_inode_destroyed*)__ret;
}

static inline struct __actvret_fscall_fanotify_init* actvhdlr_fshandler_fanotify_init_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_fanotify_init));
	return (struct __actvret_fscall_fanotify_init*)__ret;
}

static inline struct __actvret_fscall_fanotify_mark* actvhdlr_fshandler_fanotify_mark_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_fanotify_mark));
	return (struct __actvret_fscall_fanotify_mark*)__ret;
}

static inline struct __actvret_fscall_fanotify_mark_internal* actvhdlr_fshandler_fanotify_mark_internal_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_fanotify_mark_internal));
	return (struct __actvret_fscall_fanotify_mark_internal*)__ret;
}

static inline struct __actvret_fscall_fanotify_rm_watch_internal* actvhdlr_fshandler_fanotify_rm_watch_internal_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_fanotify_rm_watch_internal));
	return (struct __actvret_fscall_fanotify_rm_watch_internal*)__ret;
}

static inline struct __actvret_fscall_fanotify_notify* actvhdlr_fshandler_fanotify_notify_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_fanotify_notify));
	return (struct __actvret_fscall_fanotify_notify*)__ret;
}

static inline struct __actvret_fscall_fanotify_destroyed* actvhdlr_fshandler_fanotify_destroyed_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_fanotify_destroyed));
	return (struct __actvret_fscall_fanotify_destroyed*)__ret;
}

static inline struct __actvret_fscall_fanotify_open* actvhdlr_fshandler_fanotify_open_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_fanotify_open));
	return (struct __actvret_fscall_fanotify_open*)__ret;
}

static inline struct __actvret_fscall_endio_io_done* actvhdlr_fshandler_endio_io_done_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_endio_io_done));
	return (struct __actvret_fscall_endio_io_done*)__ret;
}

static inline struct __actvret_fscall_vfs_set_label* actvhdlr_fshandler_vfs_set_label_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_set_label));
	return (struct __actvret_fscall_vfs_set_label*)__ret;
}

static inline struct __actvret_fscall_vfs_set_label_by_path* actvhdlr_fshandler_vfs_set_label_by_path_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_set_label_by_path));
	return (struct __actvret_fscall_vfs_set_label_by_path*)__ret;
}

static inline struct __actvret_fscall_vfs_get_label* actvhdlr_fshandler_vfs_get_label_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_label));
	return (struct __actvret_fscall_vfs_get_label*)__ret;
}

static inline struct __actvret_fscall_vfs_init_audit* actvhdlr_fshandler_vfs_init_audit_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_init_audit));
	return (struct __actvret_fscall_vfs_init_audit*)__ret;
}

static inline struct __actvret_fscall_vfs_add_audit_rule* actvhdlr_fshandler_vfs_add_audit_rule_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_add_audit_rule));
	return (struct __actvret_fscall_vfs_add_audit_rule*)__ret;
}

static inline struct __actvret_fscall_vfs_del_audit_rule* actvhdlr_fshandler_vfs_del_audit_rule_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_del_audit_rule));
	return (struct __actvret_fscall_vfs_del_audit_rule*)__ret;
}

static inline struct __actvret_fscall_vfs_match_audit_watch_file* actvhdlr_fshandler_vfs_match_audit_watch_file_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_match_audit_watch_file));
	return (struct __actvret_fscall_vfs_match_audit_watch_file*)__ret;
}

static inline struct __actvret_fscall_vfs_match_audit_watch_dir* actvhdlr_fshandler_vfs_match_audit_watch_dir_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_match_audit_watch_dir));
	return (struct __actvret_fscall_vfs_match_audit_watch_dir*)__ret;
}

static inline struct __actvret_fscall_vfs_client_init* actvhdlr_fshandler_vfs_client_init_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_client_init));
	return (struct __actvret_fscall_vfs_client_init*)__ret;
}

static inline struct __actvret_fscall_vfs_bind_update* actvhdlr_fshandler_vfs_bind_update_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_bind_update));
	return (struct __actvret_fscall_vfs_bind_update*)__ret;
}

static inline struct __actvret_fscall_vfs_clone* actvhdlr_fshandler_vfs_clone_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_clone));
	return (struct __actvret_fscall_vfs_clone*)__ret;
}

static inline struct __actvret_fscall_vfs_close* actvhdlr_fshandler_vfs_close_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_close));
	return (struct __actvret_fscall_vfs_close*)__ret;
}

static inline struct __actvret_fscall_vfs_mount* actvhdlr_fshandler_vfs_mount_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mount));
	return (struct __actvret_fscall_vfs_mount*)__ret;
}

static inline struct __actvret_fscall_vfs_clone_mount_entry* actvhdlr_fshandler_vfs_clone_mount_entry_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_clone_mount_entry));
	return (struct __actvret_fscall_vfs_clone_mount_entry*)__ret;
}

static inline struct __actvret_fscall_vfs_clone_mount_entry_from_orig_parent* actvhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_clone_mount_entry_from_orig_parent));
	return (struct __actvret_fscall_vfs_clone_mount_entry_from_orig_parent*)__ret;
}

static inline struct __actvret_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent* actvhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent));
	return (struct __actvret_fscall_vfs_destroy_cloned_mount_entry_from_orig_parent*)__ret;
}

static inline struct __actvret_fscall_vfs_destroy_cloned_mount_entry* actvhdlr_fshandler_vfs_destroy_cloned_mount_entry_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_destroy_cloned_mount_entry));
	return (struct __actvret_fscall_vfs_destroy_cloned_mount_entry*)__ret;
}

static inline struct __actvret_fscall_vfs_check_mount* actvhdlr_fshandler_vfs_check_mount_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_check_mount));
	return (struct __actvret_fscall_vfs_check_mount*)__ret;
}

static inline struct __actvret_fscall_vfs_mountpoint_del_mount* actvhdlr_fshandler_vfs_mountpoint_del_mount_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mountpoint_del_mount));
	return (struct __actvret_fscall_vfs_mountpoint_del_mount*)__ret;
}

static inline struct __actvret_fscall_vfs_open* actvhdlr_fshandler_vfs_open_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_open));
	return (struct __actvret_fscall_vfs_open*)__ret;
}

static inline struct __actvret_fscall_vfs_ftruncate* actvhdlr_fshandler_vfs_ftruncate_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_ftruncate));
	return (struct __actvret_fscall_vfs_ftruncate*)__ret;
}

static inline struct __actvret_fscall_vfs_fstat* actvhdlr_fshandler_vfs_fstat_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fstat));
	return (struct __actvret_fscall_vfs_fstat*)__ret;
}

static inline struct __actvret_fscall_vfs_stat* actvhdlr_fshandler_vfs_stat_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_stat));
	return (struct __actvret_fscall_vfs_stat*)__ret;
}

static inline struct __actvret_fscall_vfs_statfs* actvhdlr_fshandler_vfs_statfs_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_statfs));
	return (struct __actvret_fscall_vfs_statfs*)__ret;
}

static inline struct __actvret_fscall_vfs_fstatfs* actvhdlr_fshandler_vfs_fstatfs_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fstatfs));
	return (struct __actvret_fscall_vfs_fstatfs*)__ret;
}

static inline struct __actvret_fscall_vfs_fsync* actvhdlr_fshandler_vfs_fsync_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fsync));
	return (struct __actvret_fscall_vfs_fsync*)__ret;
}

static inline struct __actvret_fscall_vfs_unmount* actvhdlr_fshandler_vfs_unmount_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_unmount));
	return (struct __actvret_fscall_vfs_unmount*)__ret;
}

static inline struct __actvret_fscall_vfs_unmount_from_server* actvhdlr_fshandler_vfs_unmount_from_server_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_unmount_from_server));
	return (struct __actvret_fscall_vfs_unmount_from_server*)__ret;
}

static inline struct __actvret_fscall_vfs_unmount_child* actvhdlr_fshandler_vfs_unmount_child_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_unmount_child));
	return (struct __actvret_fscall_vfs_unmount_child*)__ret;
}

static inline struct __actvret_fscall_vfs_truncate* actvhdlr_fshandler_vfs_truncate_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_truncate));
	return (struct __actvret_fscall_vfs_truncate*)__ret;
}

static inline struct __actvret_fscall_vfs_fs_fork* actvhdlr_fshandler_vfs_fs_fork_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fs_fork));
	return (struct __actvret_fscall_vfs_fs_fork*)__ret;
}

static inline struct __actvret_fscall_vfs_query_info* actvhdlr_fshandler_vfs_query_info_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_query_info));
	return (struct __actvret_fscall_vfs_query_info*)__ret;
}

static inline struct __actvret_fscall_vfs_lseek* actvhdlr_fshandler_vfs_lseek_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_lseek));
	return (struct __actvret_fscall_vfs_lseek*)__ret;
}

static inline struct __actvret_fscall_vfs_trans* actvhdlr_fshandler_vfs_trans_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_trans));
	return (struct __actvret_fscall_vfs_trans*)__ret;
}

static inline struct __actvret_fscall_vfs_pipe2* actvhdlr_fshandler_vfs_pipe2_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_pipe2));
	return (struct __actvret_fscall_vfs_pipe2*)__ret;
}

static inline struct __actvret_fscall_vfs_tee* actvhdlr_fshandler_vfs_tee_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_tee));
	return (struct __actvret_fscall_vfs_tee*)__ret;
}

static inline struct __actvret_fscall_vfs_splice* actvhdlr_fshandler_vfs_splice_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_splice));
	return (struct __actvret_fscall_vfs_splice*)__ret;
}

static inline struct __actvret_fscall_vfs_do_splice_srvs* actvhdlr_fshandler_vfs_do_splice_srvs_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_do_splice_srvs));
	return (struct __actvret_fscall_vfs_do_splice_srvs*)__ret;
}

static inline struct __actvret_fscall_vfs_revoke_process* actvhdlr_fshandler_vfs_revoke_process_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_revoke_process));
	return (struct __actvret_fscall_vfs_revoke_process*)__ret;
}

static inline struct __actvret_fscall_vfs_setrlimit* actvhdlr_fshandler_vfs_setrlimit_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_setrlimit));
	return (struct __actvret_fscall_vfs_setrlimit*)__ret;
}

static inline struct __actvret_fscall_vfs_get_ns* actvhdlr_fshandler_vfs_get_ns_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_ns));
	return (struct __actvret_fscall_vfs_get_ns*)__ret;
}

static inline struct __actvret_fscall_vfs_put_ns* actvhdlr_fshandler_vfs_put_ns_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_put_ns));
	return (struct __actvret_fscall_vfs_put_ns*)__ret;
}

static inline struct __actvret_fscall_vfs_init_eventfd* actvhdlr_fshandler_vfs_init_eventfd_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_init_eventfd));
	return (struct __actvret_fscall_vfs_init_eventfd*)__ret;
}

static inline struct __actvret_fscall_vfs_write_eventfd* actvhdlr_fshandler_vfs_write_eventfd_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_write_eventfd));
	return (struct __actvret_fscall_vfs_write_eventfd*)__ret;
}

static inline struct __actvret_fscall_vfs_timerfd_create* actvhdlr_fshandler_vfs_timerfd_create_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_timerfd_create));
	return (struct __actvret_fscall_vfs_timerfd_create*)__ret;
}

static inline struct __actvret_fscall_vfs_timerfd_settime* actvhdlr_fshandler_vfs_timerfd_settime_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_timerfd_settime));
	return (struct __actvret_fscall_vfs_timerfd_settime*)__ret;
}

static inline struct __actvret_fscall_vfs_timerfd_gettime* actvhdlr_fshandler_vfs_timerfd_gettime_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_timerfd_gettime));
	return (struct __actvret_fscall_vfs_timerfd_gettime*)__ret;
}

static inline struct __actvret_fscall_vfs_open_exec* actvhdlr_fshandler_vfs_open_exec_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_open_exec));
	return (struct __actvret_fscall_vfs_open_exec*)__ret;
}

static inline struct __actvret_fscall_vfs_close_exec* actvhdlr_fshandler_vfs_close_exec_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_close_exec));
	return (struct __actvret_fscall_vfs_close_exec*)__ret;
}

static inline struct __actvret_fscall_vfs_set_elf_file* actvhdlr_fshandler_vfs_set_elf_file_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_set_elf_file));
	return (struct __actvret_fscall_vfs_set_elf_file*)__ret;
}

static inline struct __actvret_fscall_vfs_ioctl* actvhdlr_fshandler_vfs_ioctl_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_ioctl));
	return (struct __actvret_fscall_vfs_ioctl*)__ret;
}

static inline struct __actvret_fscall_vfs_read* actvhdlr_fshandler_vfs_read_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_read));
	return (struct __actvret_fscall_vfs_read*)__ret;
}

static inline struct __actvret_fscall_vfs_readv* actvhdlr_fshandler_vfs_readv_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_readv));
	return (struct __actvret_fscall_vfs_readv*)__ret;
}

static inline struct __actvret_fscall_vfs_getcwd* actvhdlr_fshandler_vfs_getcwd_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_getcwd));
	return (struct __actvret_fscall_vfs_getcwd*)__ret;
}

static inline struct __actvret_fscall_vfs_get_process_cwdrootexe* actvhdlr_fshandler_vfs_get_process_cwdrootexe_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_process_cwdrootexe));
	return (struct __actvret_fscall_vfs_get_process_cwdrootexe*)__ret;
}

static inline struct __actvret_fscall_vfs_readdir* actvhdlr_fshandler_vfs_readdir_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_readdir));
	return (struct __actvret_fscall_vfs_readdir*)__ret;
}

static inline struct __actvret_fscall_vfs_write* actvhdlr_fshandler_vfs_write_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_write));
	return (struct __actvret_fscall_vfs_write*)__ret;
}

static inline struct __actvret_fscall_vfs_writev* actvhdlr_fshandler_vfs_writev_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_writev));
	return (struct __actvret_fscall_vfs_writev*)__ret;
}

static inline struct __actvret_fscall_vfs_sync* actvhdlr_fshandler_vfs_sync_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_sync));
	return (struct __actvret_fscall_vfs_sync*)__ret;
}

static inline struct __actvret_fscall_vfs_do_sync* actvhdlr_fshandler_vfs_do_sync_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_do_sync));
	return (struct __actvret_fscall_vfs_do_sync*)__ret;
}

static inline struct __actvret_fscall_vfs_utimensat* actvhdlr_fshandler_vfs_utimensat_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_utimensat));
	return (struct __actvret_fscall_vfs_utimensat*)__ret;
}

static inline struct __actvret_fscall_vfs_futimens* actvhdlr_fshandler_vfs_futimens_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_futimens));
	return (struct __actvret_fscall_vfs_futimens*)__ret;
}

static inline struct __actvret_fscall_vfs_fchmodat* actvhdlr_fshandler_vfs_fchmodat_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fchmodat));
	return (struct __actvret_fscall_vfs_fchmodat*)__ret;
}

static inline struct __actvret_fscall_vfs_fchmod* actvhdlr_fshandler_vfs_fchmod_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fchmod));
	return (struct __actvret_fscall_vfs_fchmod*)__ret;
}

static inline struct __actvret_fscall_vfs_drop_caches* actvhdlr_fshandler_vfs_drop_caches_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_drop_caches));
	return (struct __actvret_fscall_vfs_drop_caches*)__ret;
}

static inline struct __actvret_fscall_vfs_do_drop_caches* actvhdlr_fshandler_vfs_do_drop_caches_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_do_drop_caches));
	return (struct __actvret_fscall_vfs_do_drop_caches*)__ret;
}

static inline struct __actvret_fscall_vfs_fadvise* actvhdlr_fshandler_vfs_fadvise_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fadvise));
	return (struct __actvret_fscall_vfs_fadvise*)__ret;
}

static inline struct __actvret_fscall_vfs_readahead* actvhdlr_fshandler_vfs_readahead_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_readahead));
	return (struct __actvret_fscall_vfs_readahead*)__ret;
}

static inline struct __actvret_fscall_vfs_get_fd_path* actvhdlr_fshandler_vfs_get_fd_path_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_fd_path));
	return (struct __actvret_fscall_vfs_get_fd_path*)__ret;
}

static inline struct __actvret_fscall_vfs_sysmgr_get_fd_path* actvhdlr_fshandler_vfs_sysmgr_get_fd_path_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_sysmgr_get_fd_path));
	return (struct __actvret_fscall_vfs_sysmgr_get_fd_path*)__ret;
}

static inline struct __actvret_fscall_vfs_fcntl* actvhdlr_fshandler_vfs_fcntl_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fcntl));
	return (struct __actvret_fscall_vfs_fcntl*)__ret;
}

static inline struct __actvret_fscall_vfs_device_mounted* actvhdlr_fshandler_vfs_device_mounted_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_device_mounted));
	return (struct __actvret_fscall_vfs_device_mounted*)__ret;
}

static inline struct __actvret_fscall_vfs_quotactl* actvhdlr_fshandler_vfs_quotactl_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_quotactl));
	return (struct __actvret_fscall_vfs_quotactl*)__ret;
}

static inline struct __actvret_fscall_vfs_copy_file_range* actvhdlr_fshandler_vfs_copy_file_range_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_copy_file_range));
	return (struct __actvret_fscall_vfs_copy_file_range*)__ret;
}

static inline struct __actvret_fscall_vfs_same_file* actvhdlr_fshandler_vfs_same_file_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_same_file));
	return (struct __actvret_fscall_vfs_same_file*)__ret;
}

static inline struct __actvret_fscall_vfs_access* actvhdlr_fshandler_vfs_access_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_access));
	return (struct __actvret_fscall_vfs_access*)__ret;
}

static inline struct __actvret_fscall_vfs_flock* actvhdlr_fshandler_vfs_flock_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_flock));
	return (struct __actvret_fscall_vfs_flock*)__ret;
}

static inline struct __actvret_fscall_vfs_fchownat* actvhdlr_fshandler_vfs_fchownat_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fchownat));
	return (struct __actvret_fscall_vfs_fchownat*)__ret;
}

static inline struct __actvret_fscall_vfs_fchown* actvhdlr_fshandler_vfs_fchown_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fchown));
	return (struct __actvret_fscall_vfs_fchown*)__ret;
}

static inline struct __actvret_fscall_vfs_binderfs_mmap* actvhdlr_fshandler_vfs_binderfs_mmap_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_binderfs_mmap));
	return (struct __actvret_fscall_vfs_binderfs_mmap*)__ret;
}

static inline struct __actvret_fscall_vfs_init_signalfd* actvhdlr_fshandler_vfs_init_signalfd_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_init_signalfd));
	return (struct __actvret_fscall_vfs_init_signalfd*)__ret;
}

static inline struct __actvret_fscall_vfs_epoll_ctl* actvhdlr_fshandler_vfs_epoll_ctl_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_epoll_ctl));
	return (struct __actvret_fscall_vfs_epoll_ctl*)__ret;
}

static inline struct __actvret_fscall_vfs_epoll_et_revents* actvhdlr_fshandler_vfs_epoll_et_revents_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_epoll_et_revents));
	return (struct __actvret_fscall_vfs_epoll_et_revents*)__ret;
}

static inline struct __actvret_fscall_vfs_epoll_reinit* actvhdlr_fshandler_vfs_epoll_reinit_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_epoll_reinit));
	return (struct __actvret_fscall_vfs_epoll_reinit*)__ret;
}

static inline struct __actvret_fscall_vfs_signalfd_notify* actvhdlr_fshandler_vfs_signalfd_notify_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_signalfd_notify));
	return (struct __actvret_fscall_vfs_signalfd_notify*)__ret;
}

static inline struct __actvret_fscall_vfs_pid_io_stats* actvhdlr_fshandler_vfs_pid_io_stats_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_pid_io_stats));
	return (struct __actvret_fscall_vfs_pid_io_stats*)__ret;
}

static inline struct __actvret_fscall_vfs_fallocate* actvhdlr_fshandler_vfs_fallocate_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fallocate));
	return (struct __actvret_fscall_vfs_fallocate*)__ret;
}

static inline struct __actvret_fscall_vfs_set_cwdroot* actvhdlr_fshandler_vfs_set_cwdroot_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_set_cwdroot));
	return (struct __actvret_fscall_vfs_set_cwdroot*)__ret;
}

static inline struct __actvret_fscall_vfs_fchdir* actvhdlr_fshandler_vfs_fchdir_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fchdir));
	return (struct __actvret_fscall_vfs_fchdir*)__ret;
}

static inline struct __actvret_fscall_vfs_disable_cwdroot* actvhdlr_fshandler_vfs_disable_cwdroot_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_disable_cwdroot));
	return (struct __actvret_fscall_vfs_disable_cwdroot*)__ret;
}

static inline struct __actvret_fscall_vfs_update_cwdroot* actvhdlr_fshandler_vfs_update_cwdroot_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_update_cwdroot));
	return (struct __actvret_fscall_vfs_update_cwdroot*)__ret;
}

static inline struct __actvret_fscall_vfs_handle_global_locks* actvhdlr_fshandler_vfs_handle_global_locks_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_handle_global_locks));
	return (struct __actvret_fscall_vfs_handle_global_locks*)__ret;
}

static inline struct __actvret_fscall_vfs_send_fd* actvhdlr_fshandler_vfs_send_fd_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_send_fd));
	return (struct __actvret_fscall_vfs_send_fd*)__ret;
}

static inline struct __actvret_fscall_vfs_recv_fd* actvhdlr_fshandler_vfs_recv_fd_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_recv_fd));
	return (struct __actvret_fscall_vfs_recv_fd*)__ret;
}

static inline struct __actvret_fscall_vfs_get_buffer_wrapper* actvhdlr_fshandler_vfs_get_buffer_wrapper_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_buffer_wrapper));
	return (struct __actvret_fscall_vfs_get_buffer_wrapper*)__ret;
}

static inline struct __actvret_fscall_vfs_get_pathname_by_me_idx* actvhdlr_fshandler_vfs_get_pathname_by_me_idx_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_pathname_by_me_idx));
	return (struct __actvret_fscall_vfs_get_pathname_by_me_idx*)__ret;
}

static inline struct __actvret_fscall_vfs_sfile_put* actvhdlr_fshandler_vfs_sfile_put_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_sfile_put));
	return (struct __actvret_fscall_vfs_sfile_put*)__ret;
}

static inline struct __actvret_fscall_vfs_readlinkat* actvhdlr_fshandler_vfs_readlinkat_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_readlinkat));
	return (struct __actvret_fscall_vfs_readlinkat*)__ret;
}

static inline struct __actvret_fscall_vfs_get_slabinfo* actvhdlr_fshandler_vfs_get_slabinfo_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_slabinfo));
	return (struct __actvret_fscall_vfs_get_slabinfo*)__ret;
}

static inline struct __actvret_fscall_vfs_do_get_slabinfo* actvhdlr_fshandler_vfs_do_get_slabinfo_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_do_get_slabinfo));
	return (struct __actvret_fscall_vfs_do_get_slabinfo*)__ret;
}

static inline struct __actvret_fscall_vfs_fscache_print_info* actvhdlr_fshandler_vfs_fscache_print_info_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fscache_print_info));
	return (struct __actvret_fscall_vfs_fscache_print_info*)__ret;
}

static inline struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device* actvhdlr_fshandler_vfs_alloc_fs_handle_for_same_device_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device));
	return (struct __actvret_fscall_vfs_alloc_fs_handle_for_same_device*)__ret;
}

static inline struct __actvret_fscall_vfs_free_fs_handle_for_same_device* actvhdlr_fshandler_vfs_free_fs_handle_for_same_device_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_free_fs_handle_for_same_device));
	return (struct __actvret_fscall_vfs_free_fs_handle_for_same_device*)__ret;
}

static inline struct __actvret_fscall_vfs_memfd_create* actvhdlr_fshandler_vfs_memfd_create_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_memfd_create));
	return (struct __actvret_fscall_vfs_memfd_create*)__ret;
}

static inline struct __actvret_fscall_vfs_mknod* actvhdlr_fshandler_vfs_mknod_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mknod));
	return (struct __actvret_fscall_vfs_mknod*)__ret;
}

static inline struct __actvret_fscall_vfs_rename* actvhdlr_fshandler_vfs_rename_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_rename));
	return (struct __actvret_fscall_vfs_rename*)__ret;
}

static inline struct __actvret_fscall_vfs_mkdirat* actvhdlr_fshandler_vfs_mkdirat_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mkdirat));
	return (struct __actvret_fscall_vfs_mkdirat*)__ret;
}

static inline struct __actvret_fscall_vfs_link* actvhdlr_fshandler_vfs_link_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_link));
	return (struct __actvret_fscall_vfs_link*)__ret;
}

static inline struct __actvret_fscall_vfs_unlink* actvhdlr_fshandler_vfs_unlink_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_unlink));
	return (struct __actvret_fscall_vfs_unlink*)__ret;
}

static inline struct __actvret_fscall_vfs_symlink* actvhdlr_fshandler_vfs_symlink_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_symlink));
	return (struct __actvret_fscall_vfs_symlink*)__ret;
}

static inline struct __actvret_fscall_vfs_getxattr* actvhdlr_fshandler_vfs_getxattr_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_getxattr));
	return (struct __actvret_fscall_vfs_getxattr*)__ret;
}

static inline struct __actvret_fscall_vfs_fgetxattr* actvhdlr_fshandler_vfs_fgetxattr_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fgetxattr));
	return (struct __actvret_fscall_vfs_fgetxattr*)__ret;
}

static inline struct __actvret_fscall_vfs_setxattr* actvhdlr_fshandler_vfs_setxattr_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_setxattr));
	return (struct __actvret_fscall_vfs_setxattr*)__ret;
}

static inline struct __actvret_fscall_vfs_fsetxattr* actvhdlr_fshandler_vfs_fsetxattr_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fsetxattr));
	return (struct __actvret_fscall_vfs_fsetxattr*)__ret;
}

static inline struct __actvret_fscall_vfs_listxattr* actvhdlr_fshandler_vfs_listxattr_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_listxattr));
	return (struct __actvret_fscall_vfs_listxattr*)__ret;
}

static inline struct __actvret_fscall_vfs_flistxattr* actvhdlr_fshandler_vfs_flistxattr_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_flistxattr));
	return (struct __actvret_fscall_vfs_flistxattr*)__ret;
}

static inline struct __actvret_fscall_vfs_removexattr* actvhdlr_fshandler_vfs_removexattr_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_removexattr));
	return (struct __actvret_fscall_vfs_removexattr*)__ret;
}

static inline struct __actvret_fscall_vfs_fremovexattr* actvhdlr_fshandler_vfs_fremovexattr_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fremovexattr));
	return (struct __actvret_fscall_vfs_fremovexattr*)__ret;
}

static inline struct __actvret_fscall_vfs_iommap* actvhdlr_fshandler_vfs_iommap_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_iommap));
	return (struct __actvret_fscall_vfs_iommap*)__ret;
}

static inline struct __actvret_fscall_vfs_mmap_create* actvhdlr_fshandler_vfs_mmap_create_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mmap_create));
	return (struct __actvret_fscall_vfs_mmap_create*)__ret;
}

static inline struct __actvret_fscall_vfs_mmap_release_file* actvhdlr_fshandler_vfs_mmap_release_file_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mmap_release_file));
	return (struct __actvret_fscall_vfs_mmap_release_file*)__ret;
}

static inline struct __actvret_fscall_vfs_mmap_change* actvhdlr_fshandler_vfs_mmap_change_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mmap_change));
	return (struct __actvret_fscall_vfs_mmap_change*)__ret;
}

static inline struct __actvret_fscall_vfs_mmap_fill_page* actvhdlr_fshandler_vfs_mmap_fill_page_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mmap_fill_page));
	return (struct __actvret_fscall_vfs_mmap_fill_page*)__ret;
}

static inline struct __actvret_fscall_vfs_mmap_fetch_page* actvhdlr_fshandler_vfs_mmap_fetch_page_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mmap_fetch_page));
	return (struct __actvret_fscall_vfs_mmap_fetch_page*)__ret;
}

static inline struct __actvret_fscall_vfs_mmap_change_page* actvhdlr_fshandler_vfs_mmap_change_page_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mmap_change_page));
	return (struct __actvret_fscall_vfs_mmap_change_page*)__ret;
}

static inline struct __actvret_fscall_vfs_mmap_fallocate* actvhdlr_fshandler_vfs_mmap_fallocate_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_mmap_fallocate));
	return (struct __actvret_fscall_vfs_mmap_fallocate*)__ret;
}

static inline struct __actvret_fscall_vfs_gfd_table_update* actvhdlr_fshandler_vfs_gfd_table_update_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_gfd_table_update));
	return (struct __actvret_fscall_vfs_gfd_table_update*)__ret;
}

static inline struct __actvret_fscall_vfs_gfd_table_remove* actvhdlr_fshandler_vfs_gfd_table_remove_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_gfd_table_remove));
	return (struct __actvret_fscall_vfs_gfd_table_remove*)__ret;
}

static inline struct __actvret_fscall_vfs_gfd_table_expand* actvhdlr_fshandler_vfs_gfd_table_expand_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_gfd_table_expand));
	return (struct __actvret_fscall_vfs_gfd_table_expand*)__ret;
}

static inline struct __actvret_fscall_vfs_gfd_table_acquire* actvhdlr_fshandler_vfs_gfd_table_acquire_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_gfd_table_acquire));
	return (struct __actvret_fscall_vfs_gfd_table_acquire*)__ret;
}

static inline struct __actvret_fscall_vfs_gfd_table_release* actvhdlr_fshandler_vfs_gfd_table_release_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_gfd_table_release));
	return (struct __actvret_fscall_vfs_gfd_table_release*)__ret;
}

static inline struct __actvret_fscall_vfs_gfd_table_replace* actvhdlr_fshandler_vfs_gfd_table_replace_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_gfd_table_replace));
	return (struct __actvret_fscall_vfs_gfd_table_replace*)__ret;
}

static inline struct __actvret_fscall_vfs_gfd_table_fault* actvhdlr_fshandler_vfs_gfd_table_fault_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_gfd_table_fault));
	return (struct __actvret_fscall_vfs_gfd_table_fault*)__ret;
}

static inline struct __actvret_fscall_vfs_anon_register_devhost* actvhdlr_fshandler_vfs_anon_register_devhost_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_anon_register_devhost));
	return (struct __actvret_fscall_vfs_anon_register_devhost*)__ret;
}

static inline struct __actvret_fscall_vfs_get_unused_fd* actvhdlr_fshandler_vfs_get_unused_fd_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_unused_fd));
	return (struct __actvret_fscall_vfs_get_unused_fd*)__ret;
}

static inline struct __actvret_fscall_vfs_put_unused_fd* actvhdlr_fshandler_vfs_put_unused_fd_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_put_unused_fd));
	return (struct __actvret_fscall_vfs_put_unused_fd*)__ret;
}

static inline struct __actvret_fscall_vfs_fd_info_update* actvhdlr_fshandler_vfs_fd_info_update_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_fd_info_update));
	return (struct __actvret_fscall_vfs_fd_info_update*)__ret;
}

static inline struct __actvret_fscall_vfs_get_root_path* actvhdlr_fshandler_vfs_get_root_path_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_get_root_path));
	return (struct __actvret_fscall_vfs_get_root_path*)__ret;
}

static inline struct __actvret_fscall_vfs_transfs_fget* actvhdlr_fshandler_vfs_transfs_fget_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_transfs_fget));
	return (struct __actvret_fscall_vfs_transfs_fget*)__ret;
}

static inline struct __actvret_fscall_vfs_do_trans_fget* actvhdlr_fshandler_vfs_do_trans_fget_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_do_trans_fget));
	return (struct __actvret_fscall_vfs_do_trans_fget*)__ret;
}

static inline struct __actvret_fscall_vfs_transfs_fput* actvhdlr_fshandler_vfs_transfs_fput_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_transfs_fput));
	return (struct __actvret_fscall_vfs_transfs_fput*)__ret;
}

static inline struct __actvret_fscall_vfs_do_trans_fput* actvhdlr_fshandler_vfs_do_trans_fput_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_do_trans_fput));
	return (struct __actvret_fscall_vfs_do_trans_fput*)__ret;
}

static inline struct __actvret_fscall_vfs_read_mounts* actvhdlr_fshandler_vfs_read_mounts_prepare_ret(unsigned long long sender, unsigned long credential)
{
	void *__ret = hm_actvpool_prepare_ret(sender, credential, sizeof(struct __actvret_fscall_vfs_read_mounts));
	return (struct __actvret_fscall_vfs_read_mounts*)__ret;
}

#ifdef __sysif_server_fs_no_compat32_handlers__
#ifdef __HOST_LLT__
union fs_hdlrs_union {
	void *p_sysif_actvhdlr_ptr_void;
	int (*p_sysif_default_handler)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgehdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgehdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tx);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tx);
	int (*p__actvbridgehdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, int fd, int wd);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int wd);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgehdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgehdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, int fd, unsigned long long label);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long label);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref1, uref_t uref2);
	int (*p__actvbridgehdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, int old_fd, int new_fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_fd, int new_fd);
	int (*p__actvbridgehdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int fd, int is_dir);
	int (*p__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgehdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long length);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long length);
	int (*p__actvbridgehdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, int fd, void *st);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *st);
	int (*p__actvbridgehdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, int fd, void *msg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *msg);
	int (*p__actvbridgehdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgehdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, int whence);
	int (*p__actvbridgehdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgehdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int read_fd, int write_fd, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgehdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgehdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int count, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int clockid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, char *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgehdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, int fd, const void *tsp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *tsp);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, int fd, mode_t mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, mode_t mode);
	int (*p__actvbridgehdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgehdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, size_t count);
	int (*p__actvbridgehdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgehdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgehdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgehdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, int fd1, int fd2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd1, int fd2);
	int (*p__actvbridgehdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd);
	int (*p__actvbridgehdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgehdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgehdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgehdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int pid);
	int (*p__actvbridgehdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgehdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgehdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long ptr);
	int (*p__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgehdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, int count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int count);
	int (*p__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *list, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen);
	int (*p__actvbridgehdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned int new_size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int new_size);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, int fd, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *pathname, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t dh_ap_uref);
	int (*p__actvbridgehdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long file_id);
	int (*p__actvbridgehdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p_sysif_handle_kcall_entry)(void);
};

#else
#ifdef __aarch64__
union fs_hdlrs_union {
	void *p_sysif_actvhdlr_ptr_void;
	int (*p_sysif_default_handler)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgehdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgehdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tx);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tx);
	int (*p__actvbridgehdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, int fd, int wd);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int wd);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgehdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgehdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, int fd, unsigned long long label);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long label);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref1, uref_t uref2);
	int (*p__actvbridgehdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, int old_fd, int new_fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_fd, int new_fd);
	int (*p__actvbridgehdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int fd, int is_dir);
	int (*p__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgehdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long length);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long length);
	int (*p__actvbridgehdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, int fd, void *st);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *st);
	int (*p__actvbridgehdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, int fd, void *msg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *msg);
	int (*p__actvbridgehdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgehdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, int whence);
	int (*p__actvbridgehdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgehdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int read_fd, int write_fd, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgehdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgehdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int count, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int clockid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, char *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgehdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, int fd, const void *tsp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *tsp);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, int fd, mode_t mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, mode_t mode);
	int (*p__actvbridgehdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgehdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, size_t count);
	int (*p__actvbridgehdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgehdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgehdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgehdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, int fd1, int fd2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd1, int fd2);
	int (*p__actvbridgehdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd);
	int (*p__actvbridgehdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgehdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgehdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgehdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int pid);
	int (*p__actvbridgehdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgehdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgehdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long ptr);
	int (*p__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgehdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, int count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int count);
	int (*p__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *list, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen);
	int (*p__actvbridgehdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned int new_size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int new_size);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, int fd, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *pathname, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t dh_ap_uref);
	int (*p__actvbridgehdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long file_id);
	int (*p__actvbridgehdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p_sysif_handle_kcall_entry)(unsigned long long sender, unsigned long credential, __u64 arg1, __u64 arg2, __u64 arg3);
};

#endif
#ifdef __arm__
union fs_hdlrs_union {
	void *p_sysif_actvhdlr_ptr_void;
	int (*p_sysif_default_handler)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgehdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgehdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tx);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tx);
	int (*p__actvbridgehdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, int fd, int wd);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int wd);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgehdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgehdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, int fd, unsigned long long label);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long label);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref1, uref_t uref2);
	int (*p__actvbridgehdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, int old_fd, int new_fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_fd, int new_fd);
	int (*p__actvbridgehdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int fd, int is_dir);
	int (*p__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgehdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long length);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long length);
	int (*p__actvbridgehdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, int fd, void *st);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *st);
	int (*p__actvbridgehdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, int fd, void *msg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *msg);
	int (*p__actvbridgehdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgehdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, int whence);
	int (*p__actvbridgehdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgehdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int read_fd, int write_fd, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgehdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgehdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int count, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int clockid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, char *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgehdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, int fd, const void *tsp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *tsp);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, int fd, mode_t mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, mode_t mode);
	int (*p__actvbridgehdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgehdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, size_t count);
	int (*p__actvbridgehdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgehdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgehdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgehdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, int fd1, int fd2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd1, int fd2);
	int (*p__actvbridgehdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd);
	int (*p__actvbridgehdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgehdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgehdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgehdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int pid);
	int (*p__actvbridgehdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgehdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgehdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long ptr);
	int (*p__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgehdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, int count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int count);
	int (*p__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *list, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen);
	int (*p__actvbridgehdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned int new_size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int new_size);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, int fd, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *pathname, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t dh_ap_uref);
	int (*p__actvbridgehdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long file_id);
	int (*p__actvbridgehdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p_sysif_handle_kcall_entry)(unsigned long long sender, unsigned long credential);
};

#endif
#endif
#else
#ifndef __ARCH_RPC_REQUIRE_BRIDGE_HDLR
#error "Only support 64-bit server, build for aarch64 please!"
#else
#ifdef __HOST_LLT__
union fs_hdlrs_union {
	void *p_sysif_actvhdlr_ptr_void;
	int (*p_sysif_default_handler)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgehdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgehdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tx);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tx);
	int (*p__actvbridgehdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, int fd, int wd);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int wd);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgehdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgehdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, int fd, unsigned long long label);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long label);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref1, uref_t uref2);
	int (*p__actvbridgehdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, int old_fd, int new_fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_fd, int new_fd);
	int (*p__actvbridgehdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int fd, int is_dir);
	int (*p__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgehdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long length);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long length);
	int (*p__actvbridgehdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, int fd, void *st);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *st);
	int (*p__actvbridgehdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, int fd, void *msg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *msg);
	int (*p__actvbridgehdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgehdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, int whence);
	int (*p__actvbridgehdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgehdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int read_fd, int write_fd, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgehdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgehdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int count, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int clockid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, char *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgehdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, int fd, const void *tsp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *tsp);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, int fd, mode_t mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, mode_t mode);
	int (*p__actvbridgehdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgehdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, size_t count);
	int (*p__actvbridgehdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgehdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgehdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgehdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, int fd1, int fd2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd1, int fd2);
	int (*p__actvbridgehdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd);
	int (*p__actvbridgehdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgehdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgehdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgehdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int pid);
	int (*p__actvbridgehdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgehdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgehdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long ptr);
	int (*p__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgehdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, int count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int count);
	int (*p__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *list, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen);
	int (*p__actvbridgehdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned int new_size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int new_size);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, int fd, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *pathname, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t dh_ap_uref);
	int (*p__actvbridgehdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long file_id);
	int (*p__actvbridgehdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_create_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_create_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_delete_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_delete_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_delete)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_delete)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_getres)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_getres)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_adjtime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_adjtime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_init1)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_init1)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_rm_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_mark)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_audit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_audit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_client_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_client_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_bind_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_bind_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_close)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_close)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_check_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_check_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_ftruncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_ftruncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fstat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fstat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_stat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_stat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_statfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_statfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fstatfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fstatfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fsync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fsync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount_child)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_child)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_truncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_truncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fs_fork)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fs_fork)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_query_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_query_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_lseek)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_lseek)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_trans)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_trans)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_pipe2)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_pipe2)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_tee)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_tee)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_splice)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_splice)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_close_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_close_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_ioctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_ioctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_read)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_read)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readv)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readv)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_getcwd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_getcwd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_write)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_write)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_writev)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_writev)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_utimensat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_utimensat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_futimens)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_futimens)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchmodat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmodat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchmod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fadvise)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fadvise)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readahead)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readahead)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fcntl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fcntl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_device_mounted)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_device_mounted)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_quotactl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_quotactl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_same_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_same_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_access)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_access)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_flock)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_flock)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchownat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchownat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchown)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchown)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_send_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_send_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_recv_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_recv_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_memfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_memfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mknod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mknod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_rename)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_rename)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mkdirat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mkdirat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_link)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_link)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_setxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_setxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_flistxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_flistxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_removexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_removexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_iommap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_iommap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_change)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p_sysif_handle_kcall_entry)(void);
};

#else
#ifdef __aarch64__
union fs_hdlrs_union {
	void *p_sysif_actvhdlr_ptr_void;
	int (*p_sysif_default_handler)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgehdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgehdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tx);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tx);
	int (*p__actvbridgehdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, int fd, int wd);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int wd);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgehdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgehdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, int fd, unsigned long long label);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long label);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref1, uref_t uref2);
	int (*p__actvbridgehdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, int old_fd, int new_fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_fd, int new_fd);
	int (*p__actvbridgehdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int fd, int is_dir);
	int (*p__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgehdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long length);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long length);
	int (*p__actvbridgehdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, int fd, void *st);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *st);
	int (*p__actvbridgehdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, int fd, void *msg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *msg);
	int (*p__actvbridgehdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgehdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, int whence);
	int (*p__actvbridgehdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgehdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int read_fd, int write_fd, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgehdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgehdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int count, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int clockid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, char *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgehdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, int fd, const void *tsp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *tsp);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, int fd, mode_t mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, mode_t mode);
	int (*p__actvbridgehdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgehdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, size_t count);
	int (*p__actvbridgehdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgehdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgehdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgehdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, int fd1, int fd2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd1, int fd2);
	int (*p__actvbridgehdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd);
	int (*p__actvbridgehdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgehdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgehdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgehdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int pid);
	int (*p__actvbridgehdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgehdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgehdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long ptr);
	int (*p__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgehdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, int count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int count);
	int (*p__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *list, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen);
	int (*p__actvbridgehdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned int new_size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int new_size);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, int fd, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *pathname, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t dh_ap_uref);
	int (*p__actvbridgehdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long file_id);
	int (*p__actvbridgehdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_create_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_create_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_delete_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_delete_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_delete)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_delete)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_getres)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_getres)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_adjtime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_adjtime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_init1)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_init1)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_rm_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_mark)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_audit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_audit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_client_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_client_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_bind_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_bind_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_close)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_close)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_check_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_check_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_ftruncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_ftruncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fstat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fstat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_stat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_stat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_statfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_statfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fstatfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fstatfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fsync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fsync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount_child)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_child)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_truncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_truncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fs_fork)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fs_fork)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_query_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_query_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_lseek)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_lseek)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_trans)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_trans)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_pipe2)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_pipe2)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_tee)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_tee)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_splice)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_splice)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_close_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_close_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_ioctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_ioctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_read)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_read)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readv)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readv)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_getcwd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_getcwd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_write)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_write)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_writev)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_writev)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_utimensat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_utimensat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_futimens)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_futimens)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchmodat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmodat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchmod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fadvise)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fadvise)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readahead)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readahead)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fcntl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fcntl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_device_mounted)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_device_mounted)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_quotactl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_quotactl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_same_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_same_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_access)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_access)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_flock)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_flock)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchownat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchownat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchown)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchown)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_send_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_send_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_recv_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_recv_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_memfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_memfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mknod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mknod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_rename)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_rename)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mkdirat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mkdirat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_link)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_link)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_setxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_setxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_flistxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_flistxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_removexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_removexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_iommap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_iommap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_change)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p_sysif_handle_kcall_entry)(unsigned long long sender, unsigned long credential, __u64 arg1, __u64 arg2, __u64 arg3);
};

#endif
#ifdef __arm__
union fs_hdlrs_union {
	void *p_sysif_actvhdlr_ptr_void;
	int (*p_sysif_default_handler)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgehdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_create_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct procfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_delete_data)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files);
	int (*p__actvbridgehdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode);
	int (*p__actvbridgehdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, const char *pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_delete)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname);
	int (*p__actvbridgehdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_sysfs_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, int fd, unsigned long tp);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_getres)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp);
	int (*p__actvbridgehdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, int fd, unsigned long tx);
	int (*p__actvbridgecapcallhdlr_fshandler_clock_adjtime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tx);
	int (*p__actvbridgehdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_init1)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, int fd, int wd);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int wd);
	int (*p__actvbridgehdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx);
	int (*p__actvbridgehdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname);
	int (*p__actvbridgehdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type);
	int (*p__actvbridgehdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid);
	int (*p__actvbridgehdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_destroyed)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token);
	int (*p__actvbridgehdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_fanotify_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long long dev_id);
	int (*p__actvbridgecapcallhdlr_fshandler_endio_io_done)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long dev_id);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, int fd, unsigned long long label);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long label);
	int (*p__actvbridgehdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_label)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_audit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, unsigned long long dev_id, unsigned int index);
	int (*p__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, int audit_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_client_init)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref, char *root_srvname, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_bind_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref1, uref_t uref2);
	int (*p__actvbridgehdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, int old_fd, int new_fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_fd, int new_fd);
	int (*p__actvbridgehdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse);
	int (*p__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int orig_parent_me_idx, int child_me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_check_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int fd, int is_dir);
	int (*p__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *mp, int me_idx, unsigned int nsid);
	int (*p__actvbridgehdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long length);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ftruncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long length);
	int (*p__actvbridgehdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, int fd, void *st);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *st);
	int (*p__actvbridgehdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_stat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_statfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, int fd, void *msg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fstatfs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *msg);
	int (*p__actvbridgehdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unmount_child)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_truncate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fs_fork)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int idx_src, unsigned int idx_dst);
	int (*p__actvbridgehdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_query_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_lseek)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, int whence);
	int (*p__actvbridgehdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_trans)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *data, int pos, size_t nbyte);
	int (*p__actvbridgehdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pipe2)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int read_fd, int write_fd, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_tee)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, int fd_out, unsigned int len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_splice)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const char *buf, unsigned long len);
	int (*p__actvbridgehdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_revoke_process)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setrlimit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type);
	int (*p__actvbridgehdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_ns)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int me_idx, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int count, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int clockid, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec);
	int (*p__actvbridgehdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_open_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_close_exec)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sys_rfd, unsigned int cnode_idx, int uapp_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int sys_rfd);
	int (*p__actvbridgehdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_ioctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, size_t msg_len, void *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readv)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, char *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getcwd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf);
	int (*p__actvbridgehdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *buf, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_write)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const void *buf, size_t buf_len);
	int (*p__actvbridgehdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_writev)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos);
	int (*p__actvbridgehdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS);
	int (*p__actvbridgehdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, int me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_sync)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_utimensat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, int fd, const void *tsp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_futimens)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *tsp);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmodat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, int fd, mode_t mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchmod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, mode_t mode);
	int (*p__actvbridgehdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason);
	int (*p__actvbridgehdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fadvise)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, long long len, int advice);
	int (*p__actvbridgehdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readahead)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, size_t count);
	int (*p__actvbridgehdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path);
	int (*p__actvbridgehdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fcntl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int cmd, unsigned long arg);
	int (*p__actvbridgehdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_device_mounted)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *special, unsigned long long len, char *srvname, int srvlen);
	int (*p__actvbridgehdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_quotactl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long off_in, int fd_out, long long off_out, size_t len);
	int (*p__actvbridgehdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, int fd1, int fd2);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_same_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd1, int fd2);
	int (*p__actvbridgehdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_access)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flock)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd);
	int (*p__actvbridgehdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchownat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchown)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, uid_t uid, gid_t gid);
	int (*p__actvbridgehdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *addr, size_t len, int fd, unsigned long long shm_key);
	int (*p__actvbridgehdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long sigmask, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int op, int is_epoll, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info);
	int (*p__actvbridgehdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, const void *buf, int fdcnt);
	int (*p__actvbridgehdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned int pid);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int pid);
	int (*p__actvbridgehdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long offset, unsigned long long len, int mode);
	int (*p__actvbridgehdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, int type, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fchdir)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id);
	int (*p__actvbridgehdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_send_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int send_fd, unsigned int send_cidx, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_recv_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long ptr);
	int (*p__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int me_idx, uintptr_t pathname);
	int (*p__actvbridgehdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_sfile_put)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_readlinkat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len);
	int (*p__actvbridgehdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, int count);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int count);
	int (*p__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int new_me_idx, unsigned long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, unsigned int fs_handle);
	int (*p__actvbridgehdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, int fd, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_memfd_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mknod)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_rename)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mkdirat)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_link)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd);
	int (*p__actvbridgehdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_unlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_symlink)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_getxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, void *value, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_setxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_listxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_flistxattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *list, size_t size);
	int (*p__actvbridgehdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_removexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen);
	int (*p__actvbridgehdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_iommap)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_create)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag);
	int (*p__actvbridgehdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int remote_index, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned int new_size);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int new_size);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int start, int type, unsigned int cnode_idx);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, int fd, int type);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int type);
	int (*p__actvbridgehdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *pathname, int pathlen);
	int (*p__actvbridgehdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t dh_ap_uref);
	int (*p__actvbridgehdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned int flags);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int flags);
	int (*p__actvbridgehdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long file_id);
	int (*p__actvbridgehdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_get_root_path)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, int buflen);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, int fd);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd);
	int (*p__actvbridgehdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int me_index, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long long hm_filp);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long hm_filp);
	int (*p__actvbridgehdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgecapcallhdlr_fshandler_vfs_read_mounts)(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_create_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_create_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_delete_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_delete_data)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_get_process_fds)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_procfs_get_fd_mode)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_delete)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_delete)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_sysfs_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_sysfs_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_getres)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_getres)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_clock_adjtime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_clock_adjtime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_init1)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_init1)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_rm_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_inotify_inode_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_mark)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_rm_watch_internal)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_destroyed)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_fanotify_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_endio_io_done)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label_by_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_label)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_audit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_audit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_add_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_del_audit_rule)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_dir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_client_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_client_init)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_bind_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_bind_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_close)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_close)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_check_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_check_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mountpoint_del_mount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_open)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_ftruncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_ftruncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fstat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fstat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_stat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_stat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_statfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_statfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fstatfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fstatfs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fsync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fsync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_from_server)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unmount_child)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_child)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_truncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_truncate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fs_fork)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fs_fork)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_query_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_query_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_lseek)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_lseek)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_trans)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_trans)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_pipe2)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_pipe2)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_tee)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_tee)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_splice)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_splice)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_splice_srvs)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_revoke_process)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_setrlimit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_put_ns)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_write_eventfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_settime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_gettime)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_open_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_close_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_close_exec)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_elf_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_ioctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_ioctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_read)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_read)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readv)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readv)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_getcwd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_getcwd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_process_cwdrootexe)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_write)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_write)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_writev)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_writev)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_sync)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_utimensat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_utimensat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_futimens)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_futimens)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchmodat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmodat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchmod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_drop_caches)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fadvise)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fadvise)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readahead)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readahead)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sysmgr_get_fd_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fcntl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fcntl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_device_mounted)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_device_mounted)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_quotactl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_quotactl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_copy_file_range)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_same_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_same_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_access)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_access)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_flock)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_flock)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchownat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchownat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchown)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchown)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_binderfs_mmap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_signalfd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_ctl)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_et_revents)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_reinit)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_signalfd_notify)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_pid_io_stats)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fchdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchdir)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_disable_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_update_cwdroot)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_handle_global_locks)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_send_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_send_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_recv_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_recv_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_buffer_wrapper)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_pathname_by_me_idx)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_sfile_put)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_readlinkat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_get_slabinfo)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fscache_print_info)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_free_fs_handle_for_same_device)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_memfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_memfd_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mknod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mknod)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_rename)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_rename)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mkdirat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mkdirat)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_link)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_link)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_unlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_unlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_symlink)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_getxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fgetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_setxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_setxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fsetxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_listxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_flistxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_flistxattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_removexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_removexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fremovexattr)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_iommap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_iommap)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_create)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_release_file)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_change)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fill_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fetch_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change_page)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fallocate)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_remove)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_expand)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_acquire)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_release)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_replace)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_fault)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_anon_register_devhost)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_put_unused_fd)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_fd_info_update)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_root_path)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fget)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fput)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgehdlr_fshandler_compat_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p__actvbridgecapcallhdlr_fshandler_compat_vfs_read_mounts)(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3);
	int (*p_sysif_handle_kcall_entry)(unsigned long long sender, unsigned long credential);
};

#endif
#endif
#endif
#endif
extern union fs_hdlrs_union sysif_fs_actvhdlr_table[__fs_method_MAX];

extern union fs_hdlrs_union sysif_fs_actvcapcallhdlr_table[__fs_method_MAX];

extern void sysif_show_fs_methods(void);


#ifdef SYSIF_GEN_IFACE
#include <stdint.h>
#include <asm/actv_rpc.h>
#include <hongmeng/syscall.h>
#include <hongmeng/panic.h>
#include <hongmeng/errno.h>
#include <libstrict/strict.h>
#include <libhwsecurec/securec.h>
#include <libsysif/base/server_arg_compat.h>
#ifdef __ARCH_RPC_REQUIRE_BRIDGE_HDLR
int __attribute__((weak)) __actvshadowhdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) __actvshadowhdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, ...)
{
	return E_HM_NOSYS;
}

#else
int __attribute__((weak)) actvhdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, const char *pathname)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, const char *pathname)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, int fd, unsigned long tx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, int fd, unsigned int mask, int me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, int fd, int wd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, unsigned long long dev_id)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, int fd, unsigned long long label)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, int old_fd, int new_fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, int me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, int fd, unsigned long long length)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, int fd, void *st)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, int fd, void *msg)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, char *buf, size_t size)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, int me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, int fd, const void *tsp)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, int fd, mode_t mode)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, int fd1, int fd2)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, unsigned int pid)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, int type)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, int count)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, unsigned int new_size)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, int fd, int type)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, unsigned int flags)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, int fd)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, unsigned long long hm_filp)
{
	return E_HM_NOSYS;
}

int __attribute__((weak)) actvhdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname)
{
	return E_HM_NOSYS;
}

#endif
#ifdef __ARCH_RPC_REQUIRE_BRIDGE_HDLR
static int __opt_nonoframe __actvbridgehdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct procfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct procfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_create_data(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(struct procfs_ops_cb, ops));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct procfs_ops_cb ops)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct procfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct procfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_create_data(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(struct procfs_ops_cb, ops));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, const char *pathname)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_delete_data(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_delete_data(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long*), __arch_actv_rpc_stksz_alignment(unsigned long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_get_process_fds(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long*, bitmap), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, max_files));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long*), __arch_actv_rpc_stksz_alignment(unsigned long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_get_process_fds(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long*, bitmap), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, max_files));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_get_fd_mode(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_get_fd_mode(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct sysfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(struct sysfs_ops_cb, ops));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct sysfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(struct sysfs_ops_cb, ops));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_dir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_dir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_symlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_symlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, const char *pathname)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_delete(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_delete(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	return __actvshadowhdlr_fshandler_sysfs_notify(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	return __actvshadowhdlr_fshandler_sysfs_notify(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_settime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_settime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_gettime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_gettime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_getres(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_getres(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, int fd, unsigned long tx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_adjtime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_adjtime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_init1(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_init1(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_add_watch(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mask), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_add_watch(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mask), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, int fd, int wd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_rm_watch(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int wd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_rm_watch(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_add_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(struct fsnotify_mark_pars, pars), __ARCH_ACTV_RPC_RECV_ARG(char*, new_path), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_add_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(struct fsnotify_mark_pars, pars), __ARCH_ACTV_RPC_RECV_ARG(char*, new_path), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_rm_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_rm_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, event), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cookie), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, event), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cookie), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_inode_destroyed(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_inode_destroyed(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_init(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_init(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint64_t), __arch_actv_rpc_stksz_alignment(uint64_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_mark(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fanotify_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(uint64_t, mask), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint64_t), __arch_actv_rpc_stksz_alignment(uint64_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_mark(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fanotify_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(uint64_t, mask), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_mark_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(struct fsnotify_mark_pars, pars), __ARCH_ACTV_RPC_RECV_ARG(char*, new_path), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_mark_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(struct fsnotify_mark_pars, pars), __ARCH_ACTV_RPC_RECV_ARG(char*, new_path), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_rm_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, fanotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, obj_type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_rm_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, fanotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, obj_type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, event), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cookie), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token), __ARCH_ACTV_RPC_RECV_ARG(int, pid));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, event), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cookie), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token), __ARCH_ACTV_RPC_RECV_ARG(int, pid));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_destroyed(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_destroyed(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_open(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_open(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, unsigned long long dev_id)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_endio_io_done(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long dev_id)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_endio_io_done(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, int fd, unsigned long long label)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_label(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, label));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long label)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_label(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, label));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_label_by_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, label), __ARCH_ACTV_RPC_RECV_ARG(int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_label_by_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, label), __ARCH_ACTV_RPC_RECV_ARG(int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_label(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_label(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	return __actvshadowhdlr_fshandler_vfs_init_audit(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	return __actvshadowhdlr_fshandler_vfs_init_audit(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_add_audit_rule(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned short, shm_rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned short, shm_rule_num), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_add_audit_rule(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned short, shm_rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned short, shm_rule_num), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_del_audit_rule(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_del_audit_rule(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_match_audit_watch_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_match_audit_watch_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_match_audit_watch_dir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(int, audit_me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, int audit_me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_match_audit_watch_dir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(int, audit_me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_client_init(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref), __ARCH_ACTV_RPC_RECV_ARG(char*, root_srvname), __ARCH_ACTV_RPC_RECV_ARG(int, buflen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref, char *root_srvname, int buflen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_client_init(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref), __ARCH_ACTV_RPC_RECV_ARG(char*, root_srvname), __ARCH_ACTV_RPC_RECV_ARG(int, buflen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_bind_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref1), __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref2));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref1, uref_t uref2)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_bind_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref1), __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref2));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, int old_fd, int new_fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_fd), __ARCH_ACTV_RPC_RECV_ARG(int, new_fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_fd, int new_fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_fd), __ARCH_ACTV_RPC_RECV_ARG(int, new_fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_close(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_close(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, parent_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, parent_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone_mount_entry(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, dst), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, dst_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, child_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_fd), __ARCH_ACTV_RPC_RECV_ARG(int, recurse));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone_mount_entry(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, dst), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, dst_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, child_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_fd), __ARCH_ACTV_RPC_RECV_ARG(int, recurse));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, parent_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, parent_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, orig_parent_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, child_me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, orig_parent_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, child_me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, int me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_check_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, is_dir));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int fd, int is_dir)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_check_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, is_dir));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mountpoint_del_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(void*, mp), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *mp, int me_idx, unsigned int nsid)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mountpoint_del_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(void*, mp), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_open(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_open(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, int fd, unsigned long long length)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_ftruncate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long length)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_ftruncate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, int fd, void *st)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fstat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, st));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *st)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fstat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, st));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_stat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(void*, st), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_stat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(void*, st), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_statfs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(void*, stfs), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_statfs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(void*, stfs), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, int fd, void *msg)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fstatfs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, msg));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *msg)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fstatfs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, msg));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fsync(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fsync(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount_from_server(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uint32_t, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount_from_server(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uint32_t, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount_child(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uint32_t, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount_child(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uint32_t, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_truncate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_truncate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fs_fork(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, idx_src), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, idx_dst));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int idx_src, unsigned int idx_dst)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fs_fork(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, idx_src), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, idx_dst));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_query_info(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_query_info(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_lseek(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(int, whence));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, int whence)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_lseek(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(int, whence));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_trans(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, data), __ARCH_ACTV_RPC_RECV_ARG(int, pos), __ARCH_ACTV_RPC_RECV_ARG(size_t, nbyte));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *data, int pos, size_t nbyte)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_trans(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, data), __ARCH_ACTV_RPC_RECV_ARG(int, pos), __ARCH_ACTV_RPC_RECV_ARG(size_t, nbyte));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_pipe2(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, read_fd), __ARCH_ACTV_RPC_RECV_ARG(int, write_fd), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int read_fd, int write_fd, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_pipe2(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, read_fd), __ARCH_ACTV_RPC_RECV_ARG(int, write_fd), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_tee(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_tee(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_splice(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(long long*, offset_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(int, multi_srvs), __ARCH_ACTV_RPC_RECV_ARG(long long*, offset_out), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_splice(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(long long*, offset_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(int, multi_srvs), __ARCH_ACTV_RPC_RECV_ARG(long long*, offset_out), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_splice_srvs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(const char*, buf), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const char *buf, unsigned long len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_splice_srvs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(const char*, buf), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_revoke_process(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_revoke_process(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_setrlimit(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rlim_cur), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rlim_max), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_setrlimit(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rlim_cur), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rlim_max), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_ns(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, oldid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, newid), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_ns(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, oldid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, newid), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_put_ns(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int me_idx, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_put_ns(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_init_eventfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, count), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int count, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_init_eventfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, count), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_write_eventfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buf_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_write_eventfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buf_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, clockid), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int clockid, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, clockid), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_settime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, flags), __ARCH_ACTV_RPC_RECV_ARG(time_t, it_inval_sec), __ARCH_ACTV_RPC_RECV_ARG(long, it_inval_nsec), __ARCH_ACTV_RPC_RECV_ARG(time_t, it_val_sec), __ARCH_ACTV_RPC_RECV_ARG(long, it_val_nsec));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_settime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, flags), __ARCH_ACTV_RPC_RECV_ARG(time_t, it_inval_sec), __ARCH_ACTV_RPC_RECV_ARG(long, it_inval_nsec), __ARCH_ACTV_RPC_RECV_ARG(time_t, it_val_sec), __ARCH_ACTV_RPC_RECV_ARG(long, it_val_nsec));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_gettime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_gettime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_open_exec(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, sys_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pcnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_open_exec(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, sys_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pcnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_close_exec(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, sys_rfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, uapp_rfd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_close_exec(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, sys_rfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, uapp_rfd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_elf_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, sys_rfd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int sys_rfd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_elf_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, sys_rfd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_ioctl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, arg));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd, unsigned long arg)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_ioctl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, arg));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_read(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(size_t, msg_len), __ARCH_ACTV_RPC_RECV_ARG(void*, buf));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, size_t msg_len, void *buf)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_read(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(size_t, msg_len), __ARCH_ACTV_RPC_RECV_ARG(void*, buf));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readv(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, vec), __ARCH_ACTV_RPC_RECV_ARG(int, vlen), __ARCH_ACTV_RPC_RECV_ARG(long long, pos));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readv(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, vec), __ARCH_ACTV_RPC_RECV_ARG(int, vlen), __ARCH_ACTV_RPC_RECV_ARG(long long, pos));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, char *buf, size_t size)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_getcwd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *buf, size_t size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_getcwd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_process_cwdrootexe(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, root_cnode), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(char*, buf));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_process_cwdrootexe(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, root_cnode), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(char*, buf));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readdir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *buf, size_t size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readdir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_write(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buf_len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const void *buf, size_t buf_len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_write(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buf_len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_writev(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, vec), __ARCH_ACTV_RPC_RECV_ARG(int, vlen), __ARCH_ACTV_RPC_RECV_ARG(long long, pos));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_writev(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, vec), __ARCH_ACTV_RPC_RECV_ARG(int, vlen), __ARCH_ACTV_RPC_RECV_ARG(long long, pos));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	return __actvshadowhdlr_fshandler_vfs_sync(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	return __actvshadowhdlr_fshandler_vfs_sync(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, int me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_sync(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_sync(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_utimensat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const void*, tsp), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_utimensat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const void*, tsp), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, int fd, const void *tsp)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_futimens(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, tsp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *tsp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_futimens(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, tsp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchmodat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchmodat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, int fd, mode_t mode)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchmod(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, mode_t mode)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchmod(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_drop_caches(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(int, max), __ARCH_ACTV_RPC_RECV_ARG(int, reason));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_drop_caches(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(int, max), __ARCH_ACTV_RPC_RECV_ARG(int, reason));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_drop_caches(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(int, max), __ARCH_ACTV_RPC_RECV_ARG(int, reason));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_drop_caches(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(int, max), __ARCH_ACTV_RPC_RECV_ARG(int, reason));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fadvise(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(long long, len), __ARCH_ACTV_RPC_RECV_ARG(int, advice));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, long long len, int advice)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fadvise(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(long long, len), __ARCH_ACTV_RPC_RECV_ARG(int, advice));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readahead(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(size_t, count));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, size_t count)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readahead(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(size_t, count));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_fd_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, path), __ARCH_ACTV_RPC_RECV_ARG(int, pathlen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_fd_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, path), __ARCH_ACTV_RPC_RECV_ARG(int, pathlen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_sysmgr_get_fd_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, path));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_sysmgr_get_fd_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, path));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fcntl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, arg));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int cmd, unsigned long arg)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fcntl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, arg));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_device_mounted(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, special), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname), __ARCH_ACTV_RPC_RECV_ARG(int, srvlen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *special, unsigned long long len, char *srvname, int srvlen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_device_mounted(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, special), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname), __ARCH_ACTV_RPC_RECV_ARG(int, srvlen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_quotactl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, cmd), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, id), __ARCH_ACTV_RPC_RECV_ARG(char*, buffer), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, buffer_size), __ARCH_ACTV_RPC_RECV_ARG(int, fs_handle));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_quotactl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, cmd), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, id), __ARCH_ACTV_RPC_RECV_ARG(char*, buffer), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, buffer_size), __ARCH_ACTV_RPC_RECV_ARG(int, fs_handle));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_copy_file_range(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(long long, off_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(long long, off_out), __ARCH_ACTV_RPC_RECV_ARG(size_t, len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long off_in, int fd_out, long long off_out, size_t len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_copy_file_range(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(long long, off_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(long long, off_out), __ARCH_ACTV_RPC_RECV_ARG(size_t, len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, int fd1, int fd2)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_same_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd1), __ARCH_ACTV_RPC_RECV_ARG(int, fd2));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd1, int fd2)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_same_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd1), __ARCH_ACTV_RPC_RECV_ARG(int, fd2));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_access(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_access(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_flock(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_flock(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchownat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(uid_t, uid), __ARCH_ACTV_RPC_RECV_ARG(gid_t, gid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchownat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(uid_t, uid), __ARCH_ACTV_RPC_RECV_ARG(gid_t, gid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchown(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(uid_t, uid), __ARCH_ACTV_RPC_RECV_ARG(gid_t, gid));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, uid_t uid, gid_t gid)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchown(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(uid_t, uid), __ARCH_ACTV_RPC_RECV_ARG(gid_t, gid));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_binderfs_mmap(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(void*, addr), __ARCH_ACTV_RPC_RECV_ARG(size_t, len), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, shm_key));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *addr, size_t len, int fd, unsigned long long shm_key)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_binderfs_mmap(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(void*, addr), __ARCH_ACTV_RPC_RECV_ARG(size_t, len), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, shm_key));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_init_signalfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, sigmask), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long sigmask, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_init_signalfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, sigmask), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_ctl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, op), __ARCH_ACTV_RPC_RECV_ARG(int, is_epoll), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_reg_info));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_ctl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, op), __ARCH_ACTV_RPC_RECV_ARG(int, is_epoll), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_reg_info));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_et_revents(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_pre_reg_info));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_et_revents(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_pre_reg_info));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_reinit(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_pre_reg_info), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_reg_info));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_reinit(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_pre_reg_info), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_reg_info));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_signalfd_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(int, fdcnt));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, const void *buf, int fdcnt)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_signalfd_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(int, fdcnt));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, unsigned int pid)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_pid_io_stats(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pid));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int pid)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_pid_io_stats(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pid));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fallocate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(int, mode));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long offset, unsigned long long len, int mode)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fallocate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(int, mode));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, int type, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchdir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchdir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, int type)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_disable_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_disable_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_update_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_update_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_handle_global_locks(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, lock_id));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_handle_global_locks(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, lock_id));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_send_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, send_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_send_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, send_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_recv_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, sfiles_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(int, recv_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_recv_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, sfiles_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(int, recv_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_buffer_wrapper(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, ptr));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long ptr)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_buffer_wrapper(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, ptr));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_pathname_by_me_idx(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uintptr_t, pathname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int me_idx, uintptr_t pathname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_pathname_by_me_idx(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uintptr_t, pathname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_sfile_put(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx), __ARCH_ACTV_RPC_RECV_ARG(int, sfiles_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_sfile_put(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx), __ARCH_ACTV_RPC_RECV_ARG(int, sfiles_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readlinkat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, bufsize), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readlinkat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, bufsize), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_slabinfo(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, msg_len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_slabinfo(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, msg_len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_get_slabinfo(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, msg_len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_get_slabinfo(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, msg_len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, int count)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fscache_print_info(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, count));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int count)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fscache_print_info(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, count));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, new_me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int new_me_idx, unsigned long flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, new_me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_free_fs_handle_for_same_device(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, fs_handle));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, unsigned int fs_handle)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_free_fs_handle_for_same_device(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, fs_handle));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_memfd_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_memfd_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mknod(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, parent_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, devno), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(void*, msg), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mknod(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, parent_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, devno), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(void*, msg), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_rename(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_pfd), __ARCH_ACTV_RPC_RECV_ARG(int, new_pfd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_rename(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_pfd), __ARCH_ACTV_RPC_RECV_ARG(int, new_pfd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mkdirat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mkdirat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_link(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_pfd), __ARCH_ACTV_RPC_RECV_ARG(int, new_pfd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_link(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_pfd), __ARCH_ACTV_RPC_RECV_ARG(int, new_pfd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_symlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const void*, target), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, tarlen), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_symlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const void*, target), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, tarlen), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysif_getxattr_args), __arch_actv_rpc_stksz_alignment(struct sysif_getxattr_args));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_getxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pcnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(struct sysif_getxattr_args, sga), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysif_getxattr_args), __arch_actv_rpc_stksz_alignment(struct sysif_getxattr_args));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_getxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pcnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(struct sysif_getxattr_args, sga), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fgetxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(void*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, void *value, size_t size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fgetxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(void*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_setxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(const char*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, walk_flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_setxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(const char*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, walk_flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fsetxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(const char*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fsetxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(const char*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_listxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(char*, list), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_listxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(char*, list), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_flistxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(char*, list), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *list, size_t size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_flistxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(char*, list), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_removexattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_removexattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fremovexattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fremovexattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(rref_t), __arch_actv_rpc_stksz_alignment(rref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_iommap(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(rref_t, vs_rref), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, vs_cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(uintptr_t, vaddr), __ARCH_ACTV_RPC_RECV_ARG(size_t, aligned_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(long long, offset));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(rref_t), __arch_actv_rpc_stksz_alignment(rref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_iommap(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(rref_t, vs_rref), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, vs_cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(uintptr_t, vaddr), __ARCH_ACTV_RPC_RECV_ARG(size_t, aligned_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(long long, offset));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_release_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_release_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_change(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_change(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fill_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fill_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fetch_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fetch_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_change_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_change_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fallocate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length), __ARCH_ACTV_RPC_RECV_ARG(int, mode), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fallocate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length), __ARCH_ACTV_RPC_RECV_ARG(int, mode), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, remote_index), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int remote_index, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, remote_index), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_remove(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_remove(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, unsigned int new_size)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_expand(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, new_size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int new_size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_expand(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, new_size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_acquire(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, start), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int start, int type, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_acquire(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, start), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_release(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_release(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, int fd, int type)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_replace(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_replace(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_fault(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(int, pathlen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *pathname, int pathlen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_fault(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(int, pathlen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_anon_register_devhost(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, dh_ap_uref));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t dh_ap_uref)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_anon_register_devhost(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, dh_ap_uref));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, unsigned int flags)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_unused_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_unused_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_put_unused_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_put_unused_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fd_info_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, file_id));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long file_id)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fd_info_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, file_id));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_root_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(int, buflen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, int buflen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_root_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(int, buflen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_transfs_fget(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_transfs_fget(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, int fd)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_trans_fget(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_trans_fget(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_transfs_fput(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, me_index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, hm_filp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int me_index, unsigned long long hm_filp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_transfs_fput(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, me_index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, hm_filp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, unsigned long long hm_filp)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_trans_fput(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, hm_filp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long hm_filp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_trans_fput(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, hm_filp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname)
{
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_read_mounts(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buflen), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	__maybe_unused unsigned long *__p_prev_frame = __builtin_frame_address(0);
	unsigned long __maybe_unused __stacksz = __ARCH_ACTV_STACK_ARG_SIZE;
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_read_mounts(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buflen), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

#ifndef __sysif_server_fs_no_compat32_handlers__
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
struct compat_x3 {
	unsigned int reserverd;
	unsigned int w3;
};

#else
struct compat_x3 {
	unsigned int w3;
	unsigned int reserverd;
};

#endif
static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_procfs_create_data(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	unsigned int __maybe_unused _mode;
	struct procfs_ops_cb __maybe_unused _ops;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct procfs_ops_cb);
		type = __type_of(struct procfs_ops_cb);
		__fetch_one_arg((void*)&_ops, data, 2, arg_sz, model, type, struct procfs_ops_cb, _ops)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_create_data(sender, credential, _pathname, _mode, _ops);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_procfs_create_data(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	unsigned int __maybe_unused _mode;
	struct procfs_ops_cb __maybe_unused _ops;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct procfs_ops_cb);
		type = __type_of(struct procfs_ops_cb);
		__fetch_one_arg((void*)&_ops, data, 2, arg_sz, model, type, struct procfs_ops_cb, _ops)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_create_data(sender, credential, _pathname, _mode, _ops);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_procfs_delete_data(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_delete_data(sender, credential, _pathname);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_procfs_delete_data(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_delete_data(sender, credential, _pathname);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_procfs_get_process_fds(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused unsigned long long *_bitmap;
	unsigned int __maybe_unused _max_files;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long*);
		type = __type_of(unsigned long long*);
		__fetch_one_arg((void*)&_bitmap, data, 1, arg_sz, model, type, unsigned long long*, _bitmap)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_max_files, data, 2, arg_sz, model, type, unsigned int, _max_files)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_get_process_fds(sender, credential, _cnode_idx, _bitmap, _max_files);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_procfs_get_process_fds(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused unsigned long long *_bitmap;
	unsigned int __maybe_unused _max_files;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long*);
		type = __type_of(unsigned long long*);
		__fetch_one_arg((void*)&_bitmap, data, 1, arg_sz, model, type, unsigned long long*, _bitmap)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_max_files, data, 2, arg_sz, model, type, unsigned int, _max_files)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_get_process_fds(sender, credential, _cnode_idx, _bitmap, _max_files);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_get_fd_mode(sender, credential, _fd, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_procfs_get_fd_mode(sender, credential, _fd, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_sysfs_create_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	unsigned int __maybe_unused _mode;
	struct sysfs_ops_cb __maybe_unused _ops;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct sysfs_ops_cb);
		type = __type_of(struct sysfs_ops_cb);
		__fetch_one_arg((void*)&_ops, data, 2, arg_sz, model, type, struct sysfs_ops_cb, _ops)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_file(sender, credential, _pathname, _mode, _ops);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_sysfs_create_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	unsigned int __maybe_unused _mode;
	struct sysfs_ops_cb __maybe_unused _ops;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct sysfs_ops_cb);
		type = __type_of(struct sysfs_ops_cb);
		__fetch_one_arg((void*)&_ops, data, 2, arg_sz, model, type, struct sysfs_ops_cb, _ops)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_file(sender, credential, _pathname, _mode, _ops);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_sysfs_create_dir(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	unsigned int __maybe_unused _mode;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_dir(sender, credential, _pathname, _mode);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_sysfs_create_dir(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	unsigned int __maybe_unused _mode;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_dir(sender, credential, _pathname, _mode);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_sysfs_create_symlink(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	unsigned int __maybe_unused _mode;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_symlink(sender, credential, _pathname, _mode);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_sysfs_create_symlink(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	unsigned int __maybe_unused _mode;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_create_symlink(sender, credential, _pathname, _mode);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_sysfs_delete(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_delete(sender, credential, _pathname);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_sysfs_delete(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_pathname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 0, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_sysfs_delete(sender, credential, _pathname);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_sysfs_notify(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	return __actvshadowhdlr_fshandler_sysfs_notify(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_sysfs_notify(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	return __actvshadowhdlr_fshandler_sysfs_notify(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_clock_settime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long __maybe_unused _tp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_tp, data, 1, arg_sz, model, type, unsigned long, _tp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_settime(sender, credential, _fd, _tp);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_clock_settime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long __maybe_unused _tp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_tp, data, 1, arg_sz, model, type, unsigned long, _tp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_settime(sender, credential, _fd, _tp);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_clock_gettime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long __maybe_unused _tp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_tp, data, 1, arg_sz, model, type, unsigned long, _tp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_gettime(sender, credential, _fd, _tp);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_clock_gettime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long __maybe_unused _tp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_tp, data, 1, arg_sz, model, type, unsigned long, _tp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_gettime(sender, credential, _fd, _tp);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_clock_getres(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long __maybe_unused _tp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_tp, data, 1, arg_sz, model, type, unsigned long, _tp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_getres(sender, credential, _fd, _tp);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_clock_getres(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long __maybe_unused _tp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_tp, data, 1, arg_sz, model, type, unsigned long, _tp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_getres(sender, credential, _fd, _tp);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_clock_adjtime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long __maybe_unused _tx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_tx, data, 1, arg_sz, model, type, unsigned long, _tx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_adjtime(sender, credential, _fd, _tx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_clock_adjtime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long __maybe_unused _tx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_tx, data, 1, arg_sz, model, type, unsigned long, _tx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_clock_adjtime(sender, credential, _fd, _tx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_inotify_init1(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_init1(sender, credential, _fd, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_inotify_init1(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_init1(sender, credential, _fd, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_inotify_add_watch(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _mask;
	int __maybe_unused _me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mask, data, 1, arg_sz, model, type, unsigned int, _mask)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 2, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_add_watch(sender, credential, _fd, _mask, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _mask;
	int __maybe_unused _me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mask, data, 1, arg_sz, model, type, unsigned int, _mask)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 2, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_add_watch(sender, credential, _fd, _mask, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_inotify_rm_watch(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _wd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 1, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_rm_watch(sender, credential, _fd, _wd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _wd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 1, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_rm_watch(sender, credential, _fd, _wd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused int *_me_idx;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _nsid;
	struct fsnotify_mark_pars __maybe_unused _pars;
	__maybe_unused char *_new_path;
	__maybe_unused char *_srvname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 2, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct fsnotify_mark_pars);
		type = __type_of(struct fsnotify_mark_pars);
		__fetch_one_arg((void*)&_pars, data, 3, arg_sz, model, type, struct fsnotify_mark_pars, _pars)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_path, data, 4, arg_sz, model, type, char*, _new_path)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_srvname, data, 5, arg_sz, model, type, char*, _srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_add_watch_internal(sender, credential, _me_idx, _cnode_idx, _nsid, _pars, _new_path, _srvname);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused int *_me_idx;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _nsid;
	struct fsnotify_mark_pars __maybe_unused _pars;
	__maybe_unused char *_new_path;
	__maybe_unused char *_srvname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 2, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct fsnotify_mark_pars);
		type = __type_of(struct fsnotify_mark_pars);
		__fetch_one_arg((void*)&_pars, data, 3, arg_sz, model, type, struct fsnotify_mark_pars, _pars)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_path, data, 4, arg_sz, model, type, char*, _new_path)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_srvname, data, 5, arg_sz, model, type, char*, _srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_add_watch_internal(sender, credential, _me_idx, _cnode_idx, _nsid, _pars, _new_path, _srvname);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _nsid;
	unsigned int __maybe_unused _index;
	unsigned long long __maybe_unused _dev_id;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 3, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_index, data, 4, arg_sz, model, type, unsigned int, _index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 5, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_rm_watch_internal(sender, credential, _cnode_idx, _inotify_fd, _wd, _nsid, _index, _dev_id);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _nsid;
	unsigned int __maybe_unused _index;
	unsigned long long __maybe_unused _dev_id;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 3, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_index, data, 4, arg_sz, model, type, unsigned int, _index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 5, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_rm_watch_internal(sender, credential, _cnode_idx, _inotify_fd, _wd, _nsid, _index, _dev_id);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_inotify_notify(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _event;
	unsigned int __maybe_unused _cookie;
	unsigned int __maybe_unused _token;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_event, data, 3, arg_sz, model, type, unsigned int, _event)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cookie, data, 4, arg_sz, model, type, unsigned int, _cookie)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_token, data, 5, arg_sz, model, type, unsigned int, _token)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_notify(sender, credential, _cnode_idx, _inotify_fd, _wd, _event, _cookie, _token);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_inotify_notify(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _event;
	unsigned int __maybe_unused _cookie;
	unsigned int __maybe_unused _token;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_event, data, 3, arg_sz, model, type, unsigned int, _event)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cookie, data, 4, arg_sz, model, type, unsigned int, _cookie)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_token, data, 5, arg_sz, model, type, unsigned int, _token)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_notify(sender, credential, _cnode_idx, _inotify_fd, _wd, _event, _cookie, _token);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _token;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_token, data, 3, arg_sz, model, type, unsigned int, _token)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_inode_destroyed(sender, credential, _cnode_idx, _inotify_fd, _wd, _token);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _token;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_token, data, 3, arg_sz, model, type, unsigned int, _token)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_inotify_inode_destroyed(sender, credential, _cnode_idx, _inotify_fd, _wd, _token);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_fanotify_init(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_init(sender, credential, _fd, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_fanotify_init(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_init(sender, credential, _fd, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_fanotify_mark(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fanotify_fd;
	unsigned int __maybe_unused _flags;
	uint64_t __maybe_unused _mask;
	int __maybe_unused _me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fanotify_fd, data, 0, arg_sz, model, type, int, _fanotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uint64_t);
		type = __type_of(uint64_t);
		__fetch_one_arg((void*)&_mask, data, 2, arg_sz, model, type, uint64_t, _mask)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 3, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_mark(sender, credential, _fanotify_fd, _flags, _mask, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_fanotify_mark(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fanotify_fd;
	unsigned int __maybe_unused _flags;
	uint64_t __maybe_unused _mask;
	int __maybe_unused _me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fanotify_fd, data, 0, arg_sz, model, type, int, _fanotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uint64_t);
		type = __type_of(uint64_t);
		__fetch_one_arg((void*)&_mask, data, 2, arg_sz, model, type, uint64_t, _mask)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 3, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_mark(sender, credential, _fanotify_fd, _flags, _mask, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_fanotify_mark_internal(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused int *_me_idx;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _nsid;
	struct fsnotify_mark_pars __maybe_unused _pars;
	__maybe_unused char *_new_path;
	__maybe_unused char *_srvname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 2, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct fsnotify_mark_pars);
		type = __type_of(struct fsnotify_mark_pars);
		__fetch_one_arg((void*)&_pars, data, 3, arg_sz, model, type, struct fsnotify_mark_pars, _pars)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_path, data, 4, arg_sz, model, type, char*, _new_path)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_srvname, data, 5, arg_sz, model, type, char*, _srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_mark_internal(sender, credential, _me_idx, _cnode_idx, _nsid, _pars, _new_path, _srvname);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_fanotify_mark_internal(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused int *_me_idx;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _nsid;
	struct fsnotify_mark_pars __maybe_unused _pars;
	__maybe_unused char *_new_path;
	__maybe_unused char *_srvname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 2, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct fsnotify_mark_pars);
		type = __type_of(struct fsnotify_mark_pars);
		__fetch_one_arg((void*)&_pars, data, 3, arg_sz, model, type, struct fsnotify_mark_pars, _pars)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_path, data, 4, arg_sz, model, type, char*, _new_path)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_srvname, data, 5, arg_sz, model, type, char*, _srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_mark_internal(sender, credential, _me_idx, _cnode_idx, _nsid, _pars, _new_path, _srvname);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _fanotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _nsid;
	unsigned int __maybe_unused _index;
	unsigned long long __maybe_unused _dev_id;
	unsigned int __maybe_unused _obj_type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fanotify_fd, data, 1, arg_sz, model, type, int, _fanotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 3, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_index, data, 4, arg_sz, model, type, unsigned int, _index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 5, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_obj_type, data, 6, arg_sz, model, type, unsigned int, _obj_type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_rm_watch_internal(sender, credential, _cnode_idx, _fanotify_fd, _wd, _nsid, _index, _dev_id, _obj_type);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _fanotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _nsid;
	unsigned int __maybe_unused _index;
	unsigned long long __maybe_unused _dev_id;
	unsigned int __maybe_unused _obj_type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fanotify_fd, data, 1, arg_sz, model, type, int, _fanotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 3, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_index, data, 4, arg_sz, model, type, unsigned int, _index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 5, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_obj_type, data, 6, arg_sz, model, type, unsigned int, _obj_type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_rm_watch_internal(sender, credential, _cnode_idx, _fanotify_fd, _wd, _nsid, _index, _dev_id, _obj_type);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_fanotify_notify(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _event;
	unsigned int __maybe_unused _cookie;
	unsigned int __maybe_unused _token;
	int __maybe_unused _pid;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_event, data, 3, arg_sz, model, type, unsigned int, _event)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cookie, data, 4, arg_sz, model, type, unsigned int, _cookie)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_token, data, 5, arg_sz, model, type, unsigned int, _token)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_pid, data, 6, arg_sz, model, type, int, _pid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_notify(sender, credential, _cnode_idx, _inotify_fd, _wd, _event, _cookie, _token, _pid);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_fanotify_notify(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _event;
	unsigned int __maybe_unused _cookie;
	unsigned int __maybe_unused _token;
	int __maybe_unused _pid;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_event, data, 3, arg_sz, model, type, unsigned int, _event)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cookie, data, 4, arg_sz, model, type, unsigned int, _cookie)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_token, data, 5, arg_sz, model, type, unsigned int, _token)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_pid, data, 6, arg_sz, model, type, int, _pid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_notify(sender, credential, _cnode_idx, _inotify_fd, _wd, _event, _cookie, _token, _pid);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_fanotify_destroyed(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _token;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_token, data, 3, arg_sz, model, type, unsigned int, _token)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_destroyed(sender, credential, _cnode_idx, _inotify_fd, _wd, _token);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_fanotify_destroyed(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _inotify_fd;
	int __maybe_unused _wd;
	unsigned int __maybe_unused _token;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_inotify_fd, data, 1, arg_sz, model, type, int, _inotify_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_wd, data, 2, arg_sz, model, type, int, _wd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_token, data, 3, arg_sz, model, type, unsigned int, _token)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_destroyed(sender, credential, _cnode_idx, _inotify_fd, _wd, _token);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_fanotify_open(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	unsigned int __maybe_unused _mode;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 1, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 3, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 4, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 5, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 6, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 7, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_open(sender, credential, _dfd, _fd, _flags, _mode, _cnode_idx, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_fanotify_open(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	unsigned int __maybe_unused _mode;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 1, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 3, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 4, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 5, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 6, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 7, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_fanotify_open(sender, credential, _dfd, _fd, _flags, _mode, _cnode_idx, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_endio_io_done(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned long long __maybe_unused _dev_id;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 0, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_endio_io_done(sender, credential, _dev_id);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_endio_io_done(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned long long __maybe_unused _dev_id;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 0, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_endio_io_done(sender, credential, _dev_id);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_set_label(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _label;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_label, data, 1, arg_sz, model, type, unsigned long long, _label)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_label(sender, credential, _fd, _label);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_set_label(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _label;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_label, data, 1, arg_sz, model, type, unsigned long long, _label)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_label(sender, credential, _fd, _label);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned long long __maybe_unused _label;
	int __maybe_unused _flag;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_label, data, 1, arg_sz, model, type, unsigned long long, _label)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flag, data, 2, arg_sz, model, type, int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_label_by_path(sender, credential, _dfd, _label, _flag, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned long long __maybe_unused _label;
	int __maybe_unused _flag;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_label, data, 1, arg_sz, model, type, unsigned long long, _label)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flag, data, 2, arg_sz, model, type, int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_label_by_path(sender, credential, _dfd, _label, _flag, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_label(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_label(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_label(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_label(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_init_audit(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	return __actvshadowhdlr_fshandler_vfs_init_audit(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_init_audit(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	return __actvshadowhdlr_fshandler_vfs_init_audit(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned short __maybe_unused _shm_rule_id;
	unsigned short __maybe_unused _shm_rule_num;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned short);
		type = __type_of(unsigned short);
		__fetch_one_arg((void*)&_shm_rule_id, data, 1, arg_sz, model, type, unsigned short, _shm_rule_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned short);
		type = __type_of(unsigned short);
		__fetch_one_arg((void*)&_shm_rule_num, data, 2, arg_sz, model, type, unsigned short, _shm_rule_num)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 4, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 5, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 6, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_add_audit_rule(sender, credential, _dfd, _shm_rule_id, _shm_rule_num, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned short __maybe_unused _shm_rule_id;
	unsigned short __maybe_unused _shm_rule_num;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned short);
		type = __type_of(unsigned short);
		__fetch_one_arg((void*)&_shm_rule_id, data, 1, arg_sz, model, type, unsigned short, _shm_rule_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned short);
		type = __type_of(unsigned short);
		__fetch_one_arg((void*)&_shm_rule_num, data, 2, arg_sz, model, type, unsigned short, _shm_rule_num)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 4, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 5, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 6, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_add_audit_rule(sender, credential, _dfd, _shm_rule_id, _shm_rule_num, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned long long __maybe_unused _rule_id;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rule_id, data, 1, arg_sz, model, type, unsigned long long, _rule_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_del_audit_rule(sender, credential, _dfd, _rule_id, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned long long __maybe_unused _rule_id;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rule_id, data, 1, arg_sz, model, type, unsigned long long, _rule_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_del_audit_rule(sender, credential, _dfd, _rule_id, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned long long __maybe_unused _rule_id;
	unsigned long long __maybe_unused _dev_id;
	unsigned int __maybe_unused _index;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rule_id, data, 0, arg_sz, model, type, unsigned long long, _rule_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 1, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_index, data, 2, arg_sz, model, type, unsigned int, _index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_match_audit_watch_file(sender, credential, _rule_id, _dev_id, _index);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned long long __maybe_unused _rule_id;
	unsigned long long __maybe_unused _dev_id;
	unsigned int __maybe_unused _index;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rule_id, data, 0, arg_sz, model, type, unsigned long long, _rule_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 1, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_index, data, 2, arg_sz, model, type, unsigned int, _index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_match_audit_watch_file(sender, credential, _rule_id, _dev_id, _index);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned long long __maybe_unused _rule_id;
	int __maybe_unused _audit_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rule_id, data, 0, arg_sz, model, type, unsigned long long, _rule_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_audit_me_idx, data, 1, arg_sz, model, type, int, _audit_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_match_audit_watch_dir(sender, credential, _rule_id, _audit_me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned long long __maybe_unused _rule_id;
	int __maybe_unused _audit_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rule_id, data, 0, arg_sz, model, type, unsigned long long, _rule_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_audit_me_idx, data, 1, arg_sz, model, type, int, _audit_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_match_audit_watch_dir(sender, credential, _rule_id, _audit_me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_client_init(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	uref_t __maybe_unused _uref;
	__maybe_unused char *_root_srvname;
	int __maybe_unused _buflen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uref_t);
		type = __type_of(uref_t);
		__fetch_one_arg((void*)&_uref, data, 0, arg_sz, model, type, uref_t, _uref)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_root_srvname, data, 1, arg_sz, model, type, char*, _root_srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_buflen, data, 2, arg_sz, model, type, int, _buflen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_client_init(sender, credential, _uref, _root_srvname, _buflen);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_client_init(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	uref_t __maybe_unused _uref;
	__maybe_unused char *_root_srvname;
	int __maybe_unused _buflen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uref_t);
		type = __type_of(uref_t);
		__fetch_one_arg((void*)&_uref, data, 0, arg_sz, model, type, uref_t, _uref)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_root_srvname, data, 1, arg_sz, model, type, char*, _root_srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_buflen, data, 2, arg_sz, model, type, int, _buflen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_client_init(sender, credential, _uref, _root_srvname, _buflen);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_bind_update(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	uref_t __maybe_unused _uref1;
	uref_t __maybe_unused _uref2;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uref_t);
		type = __type_of(uref_t);
		__fetch_one_arg((void*)&_uref1, data, 0, arg_sz, model, type, uref_t, _uref1)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uref_t);
		type = __type_of(uref_t);
		__fetch_one_arg((void*)&_uref2, data, 1, arg_sz, model, type, uref_t, _uref2)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_bind_update(sender, credential, _uref1, _uref2);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_bind_update(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	uref_t __maybe_unused _uref1;
	uref_t __maybe_unused _uref2;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uref_t);
		type = __type_of(uref_t);
		__fetch_one_arg((void*)&_uref1, data, 0, arg_sz, model, type, uref_t, _uref1)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uref_t);
		type = __type_of(uref_t);
		__fetch_one_arg((void*)&_uref2, data, 1, arg_sz, model, type, uref_t, _uref2)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_bind_update(sender, credential, _uref1, _uref2);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_clone(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _old_fd;
	int __maybe_unused _new_fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_old_fd, data, 0, arg_sz, model, type, int, _old_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_new_fd, data, 1, arg_sz, model, type, int, _new_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone(sender, credential, _old_fd, _new_fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_clone(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _old_fd;
	int __maybe_unused _new_fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_old_fd, data, 0, arg_sz, model, type, int, _old_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_new_fd, data, 1, arg_sz, model, type, int, _new_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone(sender, credential, _old_fd, _new_fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_close(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_close(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_close(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_close(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mount(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _parent_fd;
	unsigned long long __maybe_unused _dev_id;
	unsigned long __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_parent_fd, data, 0, arg_sz, model, type, int, _parent_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 1, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mount(sender, credential, _parent_fd, _dev_id, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mount(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _parent_fd;
	unsigned long long __maybe_unused _dev_id;
	unsigned long __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_parent_fd, data, 0, arg_sz, model, type, int, _parent_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 1, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mount(sender, credential, _parent_fd, _dev_id, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_dst;
	unsigned int __maybe_unused _dst_len;
	unsigned long __maybe_unused _flags;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _child_me_idx;
	int __maybe_unused _orig_me_idx;
	int __maybe_unused _orig_fd;
	int __maybe_unused _recurse;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_dst, data, 0, arg_sz, model, type, const char*, _dst)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_dst_len, data, 1, arg_sz, model, type, unsigned int, _dst_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 3, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_child_me_idx, data, 4, arg_sz, model, type, int, _child_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_orig_me_idx, data, 5, arg_sz, model, type, int, _orig_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_orig_fd, data, 6, arg_sz, model, type, int, _orig_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_recurse, data, 7, arg_sz, model, type, int, _recurse)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone_mount_entry(sender, credential, _dst, _dst_len, _flags, _cnode_idx, _child_me_idx, _orig_me_idx, _orig_fd, _recurse);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_dst;
	unsigned int __maybe_unused _dst_len;
	unsigned long __maybe_unused _flags;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _child_me_idx;
	int __maybe_unused _orig_me_idx;
	int __maybe_unused _orig_fd;
	int __maybe_unused _recurse;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_dst, data, 0, arg_sz, model, type, const char*, _dst)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_dst_len, data, 1, arg_sz, model, type, unsigned int, _dst_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 3, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_child_me_idx, data, 4, arg_sz, model, type, int, _child_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_orig_me_idx, data, 5, arg_sz, model, type, int, _orig_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_orig_fd, data, 6, arg_sz, model, type, int, _orig_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_recurse, data, 7, arg_sz, model, type, int, _recurse)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone_mount_entry(sender, credential, _dst, _dst_len, _flags, _cnode_idx, _child_me_idx, _orig_me_idx, _orig_fd, _recurse);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _nsid;
	int __maybe_unused _parent_me_idx;
	int __maybe_unused _orig_me_idx;
	unsigned long long __maybe_unused _dev_id;
	unsigned long __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 0, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_parent_me_idx, data, 1, arg_sz, model, type, int, _parent_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_orig_me_idx, data, 2, arg_sz, model, type, int, _orig_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 3, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_flags, data, 4, arg_sz, model, type, unsigned long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(sender, credential, _nsid, _parent_me_idx, _orig_me_idx, _dev_id, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _nsid;
	int __maybe_unused _parent_me_idx;
	int __maybe_unused _orig_me_idx;
	unsigned long long __maybe_unused _dev_id;
	unsigned long __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 0, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_parent_me_idx, data, 1, arg_sz, model, type, int, _parent_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_orig_me_idx, data, 2, arg_sz, model, type, int, _orig_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 3, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_flags, data, 4, arg_sz, model, type, unsigned long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(sender, credential, _nsid, _parent_me_idx, _orig_me_idx, _dev_id, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _nsid;
	int __maybe_unused _orig_parent_me_idx;
	int __maybe_unused _child_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 0, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_orig_parent_me_idx, data, 1, arg_sz, model, type, int, _orig_parent_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_child_me_idx, data, 2, arg_sz, model, type, int, _child_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(sender, credential, _nsid, _orig_parent_me_idx, _child_me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _nsid;
	int __maybe_unused _orig_parent_me_idx;
	int __maybe_unused _child_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 0, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_orig_parent_me_idx, data, 1, arg_sz, model, type, int, _orig_parent_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_child_me_idx, data, 2, arg_sz, model, type, int, _child_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(sender, credential, _nsid, _orig_parent_me_idx, _child_me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry(sender, credential, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_destroy_cloned_mount_entry(sender, credential, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_check_mount(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	int __maybe_unused _fd;
	int __maybe_unused _is_dir;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 1, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_is_dir, data, 2, arg_sz, model, type, int, _is_dir)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_check_mount(sender, credential, _me_idx, _fd, _is_dir);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_check_mount(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	int __maybe_unused _fd;
	int __maybe_unused _is_dir;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 1, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_is_dir, data, 2, arg_sz, model, type, int, _is_dir)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_check_mount(sender, credential, _me_idx, _fd, _is_dir);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused void *_mp;
	int __maybe_unused _me_idx;
	unsigned int __maybe_unused _nsid;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_mp, data, 0, arg_sz, model, type, void*, _mp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 1, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 2, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mountpoint_del_mount(sender, credential, _mp, _me_idx, _nsid);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused void *_mp;
	int __maybe_unused _me_idx;
	unsigned int __maybe_unused _nsid;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_mp, data, 0, arg_sz, model, type, void*, _mp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 1, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 2, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mountpoint_del_mount(sender, credential, _mp, _me_idx, _nsid);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_open(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _dfd;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	unsigned int __maybe_unused _mode;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 1, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 2, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 4, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 5, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 6, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 7, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_open(sender, credential, _cnode_idx, _dfd, _fd, _flags, _mode, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_open(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _dfd;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	unsigned int __maybe_unused _mode;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 1, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 2, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 4, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 5, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 6, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 7, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_open(sender, credential, _cnode_idx, _dfd, _fd, _flags, _mode, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_ftruncate(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _length;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_length, data, 1, arg_sz, model, type, unsigned long long, _length)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_ftruncate(sender, credential, _fd, _length);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_ftruncate(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _length;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_length, data, 1, arg_sz, model, type, unsigned long long, _length)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_ftruncate(sender, credential, _fd, _length);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fstat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused void *_st;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_st, data, 1, arg_sz, model, type, void*, _st)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fstat(sender, credential, _fd, _st);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fstat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused void *_st;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_st, data, 1, arg_sz, model, type, void*, _st)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fstat(sender, credential, _fd, _st);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_stat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned int __maybe_unused _flag;
	__maybe_unused void *_st;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 1, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_st, data, 2, arg_sz, model, type, void*, _st)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_stat(sender, credential, _dfd, _flag, _st, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_stat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned int __maybe_unused _flag;
	__maybe_unused void *_st;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 1, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_st, data, 2, arg_sz, model, type, void*, _st)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_stat(sender, credential, _dfd, _flag, _st, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_statfs(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused void *_stfs;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_stfs, data, 1, arg_sz, model, type, void*, _stfs)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_statfs(sender, credential, _dfd, _stfs, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_statfs(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused void *_stfs;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_stfs, data, 1, arg_sz, model, type, void*, _stfs)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_statfs(sender, credential, _dfd, _stfs, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fstatfs(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused void *_msg;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_msg, data, 1, arg_sz, model, type, void*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fstatfs(sender, credential, _fd, _msg);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fstatfs(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused void *_msg;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_msg, data, 1, arg_sz, model, type, void*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fstatfs(sender, credential, _fd, _msg);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fsync(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fsync(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fsync(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fsync(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_unmount(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_msg;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_msg, data, 2, arg_sz, model, type, char*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount(sender, credential, _fd, _flags, _msg, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_unmount(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_msg;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_msg, data, 2, arg_sz, model, type, char*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount(sender, credential, _fd, _flags, _msg, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	uint32_t __maybe_unused _nsid;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uint32_t);
		type = __type_of(uint32_t);
		__fetch_one_arg((void*)&_nsid, data, 1, arg_sz, model, type, uint32_t, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount_from_server(sender, credential, _me_idx, _nsid, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	uint32_t __maybe_unused _nsid;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uint32_t);
		type = __type_of(uint32_t);
		__fetch_one_arg((void*)&_nsid, data, 1, arg_sz, model, type, uint32_t, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount_from_server(sender, credential, _me_idx, _nsid, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_unmount_child(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	uint32_t __maybe_unused _nsid;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uint32_t);
		type = __type_of(uint32_t);
		__fetch_one_arg((void*)&_nsid, data, 1, arg_sz, model, type, uint32_t, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount_child(sender, credential, _me_idx, _nsid, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_child(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	uint32_t __maybe_unused _nsid;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uint32_t);
		type = __type_of(uint32_t);
		__fetch_one_arg((void*)&_nsid, data, 1, arg_sz, model, type, uint32_t, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unmount_child(sender, credential, _me_idx, _nsid, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_truncate(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned long long __maybe_unused _length;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_length, data, 1, arg_sz, model, type, unsigned long long, _length)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_truncate(sender, credential, _dfd, _length, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_truncate(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned long long __maybe_unused _length;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_length, data, 1, arg_sz, model, type, unsigned long long, _length)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_truncate(sender, credential, _dfd, _length, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fs_fork(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _idx_src;
	unsigned int __maybe_unused _idx_dst;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_idx_src, data, 1, arg_sz, model, type, unsigned int, _idx_src)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_idx_dst, data, 2, arg_sz, model, type, unsigned int, _idx_dst)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fs_fork(sender, credential, _fd, _idx_src, _idx_dst);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fs_fork(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _idx_src;
	unsigned int __maybe_unused _idx_dst;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_idx_src, data, 1, arg_sz, model, type, unsigned int, _idx_src)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_idx_dst, data, 2, arg_sz, model, type, unsigned int, _idx_dst)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fs_fork(sender, credential, _fd, _idx_src, _idx_dst);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_query_info(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_query_info(sender, credential, _fd, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_query_info(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_query_info(sender, credential, _fd, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_lseek(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _offset;
	int __maybe_unused _whence;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_whence, data, 2, arg_sz, model, type, int, _whence)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_lseek(sender, credential, _fd, _offset, _whence);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_lseek(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _offset;
	int __maybe_unused _whence;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_whence, data, 2, arg_sz, model, type, int, _whence)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_lseek(sender, credential, _fd, _offset, _whence);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_trans(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const char *_data;
	int __maybe_unused _pos;
	size_t __maybe_unused _nbyte;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_data, data, 1, arg_sz, model, type, const char*, _data)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_pos, data, 2, arg_sz, model, type, int, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_nbyte, data, 3, arg_sz, model, type, size_t, _nbyte)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_trans(sender, credential, _fd, _data, _pos, _nbyte);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_trans(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const char *_data;
	int __maybe_unused _pos;
	size_t __maybe_unused _nbyte;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_data, data, 1, arg_sz, model, type, const char*, _data)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_pos, data, 2, arg_sz, model, type, int, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_nbyte, data, 3, arg_sz, model, type, size_t, _nbyte)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_trans(sender, credential, _fd, _data, _pos, _nbyte);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_pipe2(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _read_fd;
	int __maybe_unused _write_fd;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_read_fd, data, 0, arg_sz, model, type, int, _read_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_write_fd, data, 1, arg_sz, model, type, int, _write_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_pipe2(sender, credential, _read_fd, _write_fd, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_pipe2(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _read_fd;
	int __maybe_unused _write_fd;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_read_fd, data, 0, arg_sz, model, type, int, _read_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_write_fd, data, 1, arg_sz, model, type, int, _write_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_pipe2(sender, credential, _read_fd, _write_fd, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_tee(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd_in;
	int __maybe_unused _fd_out;
	unsigned int __maybe_unused _len;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_in, data, 0, arg_sz, model, type, int, _fd_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_out, data, 1, arg_sz, model, type, int, _fd_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, unsigned int, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_tee(sender, credential, _fd_in, _fd_out, _len, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_tee(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd_in;
	int __maybe_unused _fd_out;
	unsigned int __maybe_unused _len;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_in, data, 0, arg_sz, model, type, int, _fd_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_out, data, 1, arg_sz, model, type, int, _fd_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, unsigned int, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_tee(sender, credential, _fd_in, _fd_out, _len, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_splice(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd_in;
	__maybe_unused long long *_offset_in;
	int __maybe_unused _fd_out;
	__maybe_unused const char *_pathname;
	int __maybe_unused _multi_srvs;
	__maybe_unused long long *_offset_out;
	unsigned long __maybe_unused _len;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_in, data, 0, arg_sz, model, type, int, _fd_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long*);
		type = __type_of(long long*);
		__fetch_one_arg((void*)&_offset_in, data, 1, arg_sz, model, type, long long*, _offset_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_out, data, 2, arg_sz, model, type, int, _fd_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 3, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_multi_srvs, data, 4, arg_sz, model, type, int, _multi_srvs)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long*);
		type = __type_of(long long*);
		__fetch_one_arg((void*)&_offset_out, data, 5, arg_sz, model, type, long long*, _offset_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_len, data, 6, arg_sz, model, type, unsigned long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 7, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_splice(sender, credential, _fd_in, _offset_in, _fd_out, _pathname, _multi_srvs, _offset_out, _len, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_splice(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd_in;
	__maybe_unused long long *_offset_in;
	int __maybe_unused _fd_out;
	__maybe_unused const char *_pathname;
	int __maybe_unused _multi_srvs;
	__maybe_unused long long *_offset_out;
	unsigned long __maybe_unused _len;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_in, data, 0, arg_sz, model, type, int, _fd_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long*);
		type = __type_of(long long*);
		__fetch_one_arg((void*)&_offset_in, data, 1, arg_sz, model, type, long long*, _offset_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_out, data, 2, arg_sz, model, type, int, _fd_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_pathname, data, 3, arg_sz, model, type, const char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_multi_srvs, data, 4, arg_sz, model, type, int, _multi_srvs)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long*);
		type = __type_of(long long*);
		__fetch_one_arg((void*)&_offset_out, data, 5, arg_sz, model, type, long long*, _offset_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_len, data, 6, arg_sz, model, type, unsigned long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 7, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_splice(sender, credential, _fd_in, _offset_in, _fd_out, _pathname, _multi_srvs, _offset_out, _len, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _pos;
	__maybe_unused const char *_buf;
	unsigned long __maybe_unused _len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 1, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_buf, data, 2, arg_sz, model, type, const char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_len, data, 3, arg_sz, model, type, unsigned long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_splice_srvs(sender, credential, _fd, _pos, _buf, _len);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _pos;
	__maybe_unused const char *_buf;
	unsigned long __maybe_unused _len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 1, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_buf, data, 2, arg_sz, model, type, const char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_len, data, 3, arg_sz, model, type, unsigned long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_splice_srvs(sender, credential, _fd, _pos, _buf, _len);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_revoke_process(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_revoke_process(sender, credential, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_revoke_process(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_revoke_process(sender, credential, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_setrlimit(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	unsigned long long __maybe_unused _rlim_cur;
	unsigned long long __maybe_unused _rlim_max;
	unsigned int __maybe_unused _type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rlim_cur, data, 1, arg_sz, model, type, unsigned long long, _rlim_cur)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rlim_max, data, 2, arg_sz, model, type, unsigned long long, _rlim_max)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_type, data, 3, arg_sz, model, type, unsigned int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_setrlimit(sender, credential, _cnode_idx, _rlim_cur, _rlim_max, _type);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_setrlimit(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	unsigned long long __maybe_unused _rlim_cur;
	unsigned long long __maybe_unused _rlim_max;
	unsigned int __maybe_unused _type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rlim_cur, data, 1, arg_sz, model, type, unsigned long long, _rlim_cur)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_rlim_max, data, 2, arg_sz, model, type, unsigned long long, _rlim_max)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_type, data, 3, arg_sz, model, type, unsigned int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_setrlimit(sender, credential, _cnode_idx, _rlim_cur, _rlim_max, _type);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_ns(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _oldid;
	unsigned int __maybe_unused _newid;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_oldid, data, 1, arg_sz, model, type, unsigned int, _oldid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_newid, data, 2, arg_sz, model, type, unsigned int, _newid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_ns(sender, credential, _cnode_idx, _oldid, _newid, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_ns(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _oldid;
	unsigned int __maybe_unused _newid;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_oldid, data, 1, arg_sz, model, type, unsigned int, _oldid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_newid, data, 2, arg_sz, model, type, unsigned int, _newid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_ns(sender, credential, _cnode_idx, _oldid, _newid, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_put_ns(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _nsid;
	int __maybe_unused _me_idx;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 0, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 1, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_put_ns(sender, credential, _nsid, _me_idx, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_put_ns(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _nsid;
	int __maybe_unused _me_idx;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_nsid, data, 0, arg_sz, model, type, unsigned int, _nsid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 1, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_put_ns(sender, credential, _nsid, _me_idx, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_init_eventfd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _count;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_count, data, 1, arg_sz, model, type, unsigned int, _count)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_init_eventfd(sender, credential, _fd, _count, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_init_eventfd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _count;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_count, data, 1, arg_sz, model, type, unsigned int, _count)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_init_eventfd(sender, credential, _fd, _count, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_write_eventfd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_buf;
	size_t __maybe_unused _buf_len;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, const void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_buf_len, data, 2, arg_sz, model, type, size_t, _buf_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 3, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_write_eventfd(sender, credential, _fd, _buf, _buf_len, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_write_eventfd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_buf;
	size_t __maybe_unused _buf_len;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, const void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_buf_len, data, 2, arg_sz, model, type, size_t, _buf_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 3, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_write_eventfd(sender, credential, _fd, _buf, _buf_len, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_timerfd_create(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _clockid;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_clockid, data, 1, arg_sz, model, type, int, _clockid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_create(sender, credential, _fd, _clockid, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_create(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _clockid;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_clockid, data, 1, arg_sz, model, type, int, _clockid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_create(sender, credential, _fd, _clockid, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _flags;
	time_t __maybe_unused _it_inval_sec;
	long __maybe_unused _it_inval_nsec;
	time_t __maybe_unused _it_val_sec;
	long __maybe_unused _it_val_nsec;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(time_t);
		type = __type_of(time_t);
		__fetch_one_arg((void*)&_it_inval_sec, data, 2, arg_sz, model, type, time_t, _it_inval_sec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long);
		type = __type_of(long);
		__fetch_one_arg((void*)&_it_inval_nsec, data, 3, arg_sz, model, type, long, _it_inval_nsec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(time_t);
		type = __type_of(time_t);
		__fetch_one_arg((void*)&_it_val_sec, data, 4, arg_sz, model, type, time_t, _it_val_sec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long);
		type = __type_of(long);
		__fetch_one_arg((void*)&_it_val_nsec, data, 5, arg_sz, model, type, long, _it_val_nsec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_settime(sender, credential, _fd, _flags, _it_inval_sec, _it_inval_nsec, _it_val_sec, _it_val_nsec);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _flags;
	time_t __maybe_unused _it_inval_sec;
	long __maybe_unused _it_inval_nsec;
	time_t __maybe_unused _it_val_sec;
	long __maybe_unused _it_val_nsec;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(time_t);
		type = __type_of(time_t);
		__fetch_one_arg((void*)&_it_inval_sec, data, 2, arg_sz, model, type, time_t, _it_inval_sec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long);
		type = __type_of(long);
		__fetch_one_arg((void*)&_it_inval_nsec, data, 3, arg_sz, model, type, long, _it_inval_nsec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(time_t);
		type = __type_of(time_t);
		__fetch_one_arg((void*)&_it_val_sec, data, 4, arg_sz, model, type, time_t, _it_val_sec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long);
		type = __type_of(long);
		__fetch_one_arg((void*)&_it_val_nsec, data, 5, arg_sz, model, type, long, _it_val_nsec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_settime(sender, credential, _fd, _flags, _it_inval_sec, _it_inval_nsec, _it_val_sec, _it_val_nsec);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_gettime(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_timerfd_gettime(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_open_exec(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	int __maybe_unused _sys_fd;
	unsigned int __maybe_unused _flags;
	unsigned int __maybe_unused _pcnode_idx;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sys_fd, data, 1, arg_sz, model, type, int, _sys_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_pcnode_idx, data, 3, arg_sz, model, type, unsigned int, _pcnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 4, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 5, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 6, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 7, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_open_exec(sender, credential, _dfd, _sys_fd, _flags, _pcnode_idx, _cnode_idx, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_open_exec(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	int __maybe_unused _sys_fd;
	unsigned int __maybe_unused _flags;
	unsigned int __maybe_unused _pcnode_idx;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sys_fd, data, 1, arg_sz, model, type, int, _sys_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_pcnode_idx, data, 3, arg_sz, model, type, unsigned int, _pcnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 4, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 5, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 6, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 7, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_open_exec(sender, credential, _dfd, _sys_fd, _flags, _pcnode_idx, _cnode_idx, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_close_exec(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _sys_rfd;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _uapp_rfd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sys_rfd, data, 0, arg_sz, model, type, int, _sys_rfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_uapp_rfd, data, 2, arg_sz, model, type, int, _uapp_rfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_close_exec(sender, credential, _sys_rfd, _cnode_idx, _uapp_rfd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_close_exec(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _sys_rfd;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _uapp_rfd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sys_rfd, data, 0, arg_sz, model, type, int, _sys_rfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_uapp_rfd, data, 2, arg_sz, model, type, int, _uapp_rfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_close_exec(sender, credential, _sys_rfd, _cnode_idx, _uapp_rfd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_set_elf_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _sys_rfd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sys_rfd, data, 1, arg_sz, model, type, int, _sys_rfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_elf_file(sender, credential, _cnode_idx, _sys_rfd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_set_elf_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _sys_rfd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sys_rfd, data, 1, arg_sz, model, type, int, _sys_rfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_elf_file(sender, credential, _cnode_idx, _sys_rfd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_ioctl(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cmd;
	unsigned long __maybe_unused _arg;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cmd, data, 1, arg_sz, model, type, unsigned int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_arg, data, 2, arg_sz, model, type, unsigned long, _arg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_ioctl(sender, credential, _fd, _cmd, _arg);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_ioctl(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cmd;
	unsigned long __maybe_unused _arg;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cmd, data, 1, arg_sz, model, type, unsigned int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_arg, data, 2, arg_sz, model, type, unsigned long, _arg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_ioctl(sender, credential, _fd, _cmd, _arg);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_read(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _pos;
	size_t __maybe_unused _msg_len;
	__maybe_unused void *_buf;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 1, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_msg_len, data, 2, arg_sz, model, type, size_t, _msg_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_buf, data, 3, arg_sz, model, type, void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_read(sender, credential, _fd, _pos, _msg_len, _buf);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_read(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _pos;
	size_t __maybe_unused _msg_len;
	__maybe_unused void *_buf;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 1, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_msg_len, data, 2, arg_sz, model, type, size_t, _msg_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_buf, data, 3, arg_sz, model, type, void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_read(sender, credential, _fd, _pos, _msg_len, _buf);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_readv(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_vec;
	int __maybe_unused _vlen;
	long long __maybe_unused _pos;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_vec, data, 1, arg_sz, model, type, const void*, _vec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_vlen, data, 2, arg_sz, model, type, int, _vlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 3, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readv(sender, credential, _fd, _vec, _vlen, _pos);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_readv(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_vec;
	int __maybe_unused _vlen;
	long long __maybe_unused _pos;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_vec, data, 1, arg_sz, model, type, const void*, _vec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_vlen, data, 2, arg_sz, model, type, int, _vlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 3, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readv(sender, credential, _fd, _vec, _vlen, _pos);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_getcwd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused char *_buf;
	size_t __maybe_unused _size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 0, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 1, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_getcwd(sender, credential, _buf, _size);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_getcwd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused char *_buf;
	size_t __maybe_unused _size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 0, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 1, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_getcwd(sender, credential, _buf, _size);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _root_cnode;
	int __maybe_unused _type;
	__maybe_unused char *_buf;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_root_cnode, data, 1, arg_sz, model, type, unsigned int, _root_cnode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 2, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 3, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_process_cwdrootexe(sender, credential, _cnode_idx, _root_cnode, _type, _buf);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _root_cnode;
	int __maybe_unused _type;
	__maybe_unused char *_buf;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_root_cnode, data, 1, arg_sz, model, type, unsigned int, _root_cnode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 2, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 3, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_process_cwdrootexe(sender, credential, _cnode_idx, _root_cnode, _type, _buf);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_readdir(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused void *_buf;
	size_t __maybe_unused _size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 2, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readdir(sender, credential, _fd, _buf, _size);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_readdir(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused void *_buf;
	size_t __maybe_unused _size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 2, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readdir(sender, credential, _fd, _buf, _size);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_write(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _pos;
	__maybe_unused const void *_buf;
	size_t __maybe_unused _buf_len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 1, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_buf, data, 2, arg_sz, model, type, const void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_buf_len, data, 3, arg_sz, model, type, size_t, _buf_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_write(sender, credential, _fd, _pos, _buf, _buf_len);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_write(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _pos;
	__maybe_unused const void *_buf;
	size_t __maybe_unused _buf_len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 1, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_buf, data, 2, arg_sz, model, type, const void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_buf_len, data, 3, arg_sz, model, type, size_t, _buf_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_write(sender, credential, _fd, _pos, _buf, _buf_len);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_writev(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_vec;
	int __maybe_unused _vlen;
	long long __maybe_unused _pos;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_vec, data, 1, arg_sz, model, type, const void*, _vec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_vlen, data, 2, arg_sz, model, type, int, _vlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 3, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_writev(sender, credential, _fd, _vec, _vlen, _pos);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_writev(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_vec;
	int __maybe_unused _vlen;
	long long __maybe_unused _pos;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_vec, data, 1, arg_sz, model, type, const void*, _vec)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_vlen, data, 2, arg_sz, model, type, int, _vlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_pos, data, 3, arg_sz, model, type, long long, _pos)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_writev(sender, credential, _fd, _vec, _vlen, _pos);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_sync(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	return __actvshadowhdlr_fshandler_vfs_sync(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_sync(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	return __actvshadowhdlr_fshandler_vfs_sync(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_do_sync(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_sync(sender, credential, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_do_sync(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_sync(sender, credential, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_utimensat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused const void *_tsp;
	unsigned int __maybe_unused _flag;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_tsp, data, 1, arg_sz, model, type, const void*, _tsp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 2, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_utimensat(sender, credential, _dfd, _tsp, _flag, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_utimensat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused const void *_tsp;
	unsigned int __maybe_unused _flag;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_tsp, data, 1, arg_sz, model, type, const void*, _tsp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 2, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_utimensat(sender, credential, _dfd, _tsp, _flag, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_futimens(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_tsp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_tsp, data, 1, arg_sz, model, type, const void*, _tsp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_futimens(sender, credential, _fd, _tsp);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_futimens(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_tsp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_tsp, data, 1, arg_sz, model, type, const void*, _tsp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_futimens(sender, credential, _fd, _tsp);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fchmodat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	mode_t __maybe_unused _mode;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(mode_t);
		type = __type_of(mode_t);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, mode_t, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchmodat(sender, credential, _dfd, _mode, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fchmodat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	mode_t __maybe_unused _mode;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(mode_t);
		type = __type_of(mode_t);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, mode_t, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchmodat(sender, credential, _dfd, _mode, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fchmod(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	mode_t __maybe_unused _mode;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(mode_t);
		type = __type_of(mode_t);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, mode_t, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchmod(sender, credential, _fd, _mode);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fchmod(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	mode_t __maybe_unused _mode;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(mode_t);
		type = __type_of(mode_t);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, mode_t, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchmod(sender, credential, _fd, _mode);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_drop_caches(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _mode;
	int __maybe_unused _max;
	int __maybe_unused _reason;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 0, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_max, data, 1, arg_sz, model, type, int, _max)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_reason, data, 2, arg_sz, model, type, int, _reason)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_drop_caches(sender, credential, _mode, _max, _reason);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_drop_caches(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _mode;
	int __maybe_unused _max;
	int __maybe_unused _reason;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 0, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_max, data, 1, arg_sz, model, type, int, _max)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_reason, data, 2, arg_sz, model, type, int, _reason)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_drop_caches(sender, credential, _mode, _max, _reason);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _mode;
	int __maybe_unused _max;
	int __maybe_unused _reason;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 0, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_max, data, 1, arg_sz, model, type, int, _max)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_reason, data, 2, arg_sz, model, type, int, _reason)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_drop_caches(sender, credential, _mode, _max, _reason);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _mode;
	int __maybe_unused _max;
	int __maybe_unused _reason;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 0, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_max, data, 1, arg_sz, model, type, int, _max)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_reason, data, 2, arg_sz, model, type, int, _reason)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_drop_caches(sender, credential, _mode, _max, _reason);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fadvise(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _offset;
	long long __maybe_unused _len;
	int __maybe_unused _advice;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_advice, data, 3, arg_sz, model, type, int, _advice)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fadvise(sender, credential, _fd, _offset, _len, _advice);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fadvise(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _offset;
	long long __maybe_unused _len;
	int __maybe_unused _advice;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_advice, data, 3, arg_sz, model, type, int, _advice)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fadvise(sender, credential, _fd, _offset, _len, _advice);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_readahead(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _offset;
	size_t __maybe_unused _count;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_count, data, 2, arg_sz, model, type, size_t, _count)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readahead(sender, credential, _fd, _offset, _count);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_readahead(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _offset;
	size_t __maybe_unused _count;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_count, data, 2, arg_sz, model, type, size_t, _count)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readahead(sender, credential, _fd, _offset, _count);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_fd_path(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_path;
	int __maybe_unused _pathlen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_path, data, 2, arg_sz, model, type, char*, _path)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_pathlen, data, 3, arg_sz, model, type, int, _pathlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_fd_path(sender, credential, _fd, _cnode_idx, _path, _pathlen);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_fd_path(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_path;
	int __maybe_unused _pathlen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_path, data, 2, arg_sz, model, type, char*, _path)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_pathlen, data, 3, arg_sz, model, type, int, _pathlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_fd_path(sender, credential, _fd, _cnode_idx, _path, _pathlen);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_path;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_path, data, 2, arg_sz, model, type, char*, _path)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_sysmgr_get_fd_path(sender, credential, _fd, _cnode_idx, _path);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_path;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_path, data, 2, arg_sz, model, type, char*, _path)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_sysmgr_get_fd_path(sender, credential, _fd, _cnode_idx, _path);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fcntl(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _cmd;
	unsigned long __maybe_unused _arg;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_cmd, data, 1, arg_sz, model, type, int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_arg, data, 2, arg_sz, model, type, unsigned long, _arg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fcntl(sender, credential, _fd, _cmd, _arg);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fcntl(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _cmd;
	unsigned long __maybe_unused _arg;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_cmd, data, 1, arg_sz, model, type, int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_arg, data, 2, arg_sz, model, type, unsigned long, _arg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fcntl(sender, credential, _fd, _cmd, _arg);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_device_mounted(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_special;
	unsigned long long __maybe_unused _len;
	__maybe_unused char *_srvname;
	int __maybe_unused _srvlen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_special, data, 0, arg_sz, model, type, const char*, _special)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_len, data, 1, arg_sz, model, type, unsigned long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_srvname, data, 2, arg_sz, model, type, char*, _srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_srvlen, data, 3, arg_sz, model, type, int, _srvlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_device_mounted(sender, credential, _special, _len, _srvname, _srvlen);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_device_mounted(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused const char *_special;
	unsigned long long __maybe_unused _len;
	__maybe_unused char *_srvname;
	int __maybe_unused _srvlen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_special, data, 0, arg_sz, model, type, const char*, _special)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_len, data, 1, arg_sz, model, type, unsigned long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_srvname, data, 2, arg_sz, model, type, char*, _srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_srvlen, data, 3, arg_sz, model, type, int, _srvlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_device_mounted(sender, credential, _special, _len, _srvname, _srvlen);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_quotactl(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _cmd;
	int __maybe_unused _type;
	unsigned int __maybe_unused _id;
	__maybe_unused char *_buffer;
	unsigned int __maybe_unused _buffer_size;
	int __maybe_unused _fs_handle;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_cmd, data, 0, arg_sz, model, type, int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_id, data, 2, arg_sz, model, type, unsigned int, _id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buffer, data, 3, arg_sz, model, type, char*, _buffer)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_buffer_size, data, 4, arg_sz, model, type, unsigned int, _buffer_size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fs_handle, data, 5, arg_sz, model, type, int, _fs_handle)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_quotactl(sender, credential, _cmd, _type, _id, _buffer, _buffer_size, _fs_handle);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_quotactl(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _cmd;
	int __maybe_unused _type;
	unsigned int __maybe_unused _id;
	__maybe_unused char *_buffer;
	unsigned int __maybe_unused _buffer_size;
	int __maybe_unused _fs_handle;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_cmd, data, 0, arg_sz, model, type, int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_id, data, 2, arg_sz, model, type, unsigned int, _id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buffer, data, 3, arg_sz, model, type, char*, _buffer)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_buffer_size, data, 4, arg_sz, model, type, unsigned int, _buffer_size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fs_handle, data, 5, arg_sz, model, type, int, _fs_handle)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_quotactl(sender, credential, _cmd, _type, _id, _buffer, _buffer_size, _fs_handle);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_copy_file_range(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd_in;
	long long __maybe_unused _off_in;
	int __maybe_unused _fd_out;
	long long __maybe_unused _off_out;
	size_t __maybe_unused _len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_in, data, 0, arg_sz, model, type, int, _fd_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_off_in, data, 1, arg_sz, model, type, long long, _off_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_out, data, 2, arg_sz, model, type, int, _fd_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_off_out, data, 3, arg_sz, model, type, long long, _off_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_len, data, 4, arg_sz, model, type, size_t, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_copy_file_range(sender, credential, _fd_in, _off_in, _fd_out, _off_out, _len);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_copy_file_range(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd_in;
	long long __maybe_unused _off_in;
	int __maybe_unused _fd_out;
	long long __maybe_unused _off_out;
	size_t __maybe_unused _len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_in, data, 0, arg_sz, model, type, int, _fd_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_off_in, data, 1, arg_sz, model, type, long long, _off_in)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd_out, data, 2, arg_sz, model, type, int, _fd_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_off_out, data, 3, arg_sz, model, type, long long, _off_out)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_len, data, 4, arg_sz, model, type, size_t, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_copy_file_range(sender, credential, _fd_in, _off_in, _fd_out, _off_out, _len);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_same_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd1;
	int __maybe_unused _fd2;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd1, data, 0, arg_sz, model, type, int, _fd1)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd2, data, 1, arg_sz, model, type, int, _fd2)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_same_file(sender, credential, _fd1, _fd2);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_same_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd1;
	int __maybe_unused _fd2;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd1, data, 0, arg_sz, model, type, int, _fd1)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd2, data, 1, arg_sz, model, type, int, _fd2)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_same_file(sender, credential, _fd1, _fd2);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_access(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned int __maybe_unused _mode;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_access(sender, credential, _dfd, _mode, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_access(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned int __maybe_unused _mode;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_access(sender, credential, _dfd, _mode, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_flock(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cmd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cmd, data, 1, arg_sz, model, type, unsigned int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_flock(sender, credential, _fd, _cmd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_flock(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cmd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cmd, data, 1, arg_sz, model, type, unsigned int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_flock(sender, credential, _fd, _cmd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fchownat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	uid_t __maybe_unused _uid;
	gid_t __maybe_unused _gid;
	unsigned int __maybe_unused _flag;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uid_t);
		type = __type_of(uid_t);
		__fetch_one_arg((void*)&_uid, data, 1, arg_sz, model, type, uid_t, _uid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(gid_t);
		type = __type_of(gid_t);
		__fetch_one_arg((void*)&_gid, data, 2, arg_sz, model, type, gid_t, _gid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 3, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 4, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 5, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 6, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchownat(sender, credential, _dfd, _uid, _gid, _flag, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fchownat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	uid_t __maybe_unused _uid;
	gid_t __maybe_unused _gid;
	unsigned int __maybe_unused _flag;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uid_t);
		type = __type_of(uid_t);
		__fetch_one_arg((void*)&_uid, data, 1, arg_sz, model, type, uid_t, _uid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(gid_t);
		type = __type_of(gid_t);
		__fetch_one_arg((void*)&_gid, data, 2, arg_sz, model, type, gid_t, _gid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 3, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 4, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 5, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 6, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchownat(sender, credential, _dfd, _uid, _gid, _flag, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fchown(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	uid_t __maybe_unused _uid;
	gid_t __maybe_unused _gid;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uid_t);
		type = __type_of(uid_t);
		__fetch_one_arg((void*)&_uid, data, 1, arg_sz, model, type, uid_t, _uid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(gid_t);
		type = __type_of(gid_t);
		__fetch_one_arg((void*)&_gid, data, 2, arg_sz, model, type, gid_t, _gid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchown(sender, credential, _fd, _uid, _gid);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fchown(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	uid_t __maybe_unused _uid;
	gid_t __maybe_unused _gid;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uid_t);
		type = __type_of(uid_t);
		__fetch_one_arg((void*)&_uid, data, 1, arg_sz, model, type, uid_t, _uid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(gid_t);
		type = __type_of(gid_t);
		__fetch_one_arg((void*)&_gid, data, 2, arg_sz, model, type, gid_t, _gid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchown(sender, credential, _fd, _uid, _gid);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused void *_addr;
	size_t __maybe_unused _len;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _shm_key;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_addr, data, 0, arg_sz, model, type, void*, _addr)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_len, data, 1, arg_sz, model, type, size_t, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 2, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_shm_key, data, 3, arg_sz, model, type, unsigned long long, _shm_key)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_binderfs_mmap(sender, credential, _addr, _len, _fd, _shm_key);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused void *_addr;
	size_t __maybe_unused _len;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _shm_key;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_addr, data, 0, arg_sz, model, type, void*, _addr)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_len, data, 1, arg_sz, model, type, size_t, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 2, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_shm_key, data, 3, arg_sz, model, type, unsigned long long, _shm_key)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_binderfs_mmap(sender, credential, _addr, _len, _fd, _shm_key);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_init_signalfd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _sigmask;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_sigmask, data, 1, arg_sz, model, type, unsigned long long, _sigmask)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_init_signalfd(sender, credential, _fd, _sigmask, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_init_signalfd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _sigmask;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_sigmask, data, 1, arg_sz, model, type, unsigned long long, _sigmask)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_init_signalfd(sender, credential, _fd, _sigmask, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _op;
	int __maybe_unused _is_epoll;
	__maybe_unused const void *_epoll_reg_info;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_op, data, 1, arg_sz, model, type, int, _op)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_is_epoll, data, 2, arg_sz, model, type, int, _is_epoll)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_epoll_reg_info, data, 3, arg_sz, model, type, const void*, _epoll_reg_info)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_ctl(sender, credential, _fd, _op, _is_epoll, _epoll_reg_info);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _op;
	int __maybe_unused _is_epoll;
	__maybe_unused const void *_epoll_reg_info;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_op, data, 1, arg_sz, model, type, int, _op)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_is_epoll, data, 2, arg_sz, model, type, int, _is_epoll)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_epoll_reg_info, data, 3, arg_sz, model, type, const void*, _epoll_reg_info)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_ctl(sender, credential, _fd, _op, _is_epoll, _epoll_reg_info);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_epoll_pre_reg_info;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_epoll_pre_reg_info, data, 1, arg_sz, model, type, const void*, _epoll_pre_reg_info)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_et_revents(sender, credential, _fd, _epoll_pre_reg_info);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_epoll_pre_reg_info;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_epoll_pre_reg_info, data, 1, arg_sz, model, type, const void*, _epoll_pre_reg_info)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_et_revents(sender, credential, _fd, _epoll_pre_reg_info);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_epoll_pre_reg_info;
	__maybe_unused const void *_epoll_reg_info;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_epoll_pre_reg_info, data, 1, arg_sz, model, type, const void*, _epoll_pre_reg_info)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_epoll_reg_info, data, 2, arg_sz, model, type, const void*, _epoll_reg_info)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_reinit(sender, credential, _fd, _epoll_pre_reg_info, _epoll_reg_info);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const void *_epoll_pre_reg_info;
	__maybe_unused const void *_epoll_reg_info;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_epoll_pre_reg_info, data, 1, arg_sz, model, type, const void*, _epoll_pre_reg_info)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_epoll_reg_info, data, 2, arg_sz, model, type, const void*, _epoll_reg_info)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_epoll_reinit(sender, credential, _fd, _epoll_pre_reg_info, _epoll_reg_info);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused const void *_buf;
	int __maybe_unused _fdcnt;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, const void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fdcnt, data, 2, arg_sz, model, type, int, _fdcnt)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_signalfd_notify(sender, credential, _cnode_idx, _buf, _fdcnt);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused const void *_buf;
	int __maybe_unused _fdcnt;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, const void*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fdcnt, data, 2, arg_sz, model, type, int, _fdcnt)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_signalfd_notify(sender, credential, _cnode_idx, _buf, _fdcnt);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _pid;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_pid, data, 0, arg_sz, model, type, unsigned int, _pid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_pid_io_stats(sender, credential, _pid);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _pid;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_pid, data, 0, arg_sz, model, type, unsigned int, _pid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_pid_io_stats(sender, credential, _pid);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fallocate(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _offset;
	unsigned long long __maybe_unused _len;
	int __maybe_unused _mode;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, unsigned long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, unsigned long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_mode, data, 3, arg_sz, model, type, int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fallocate(sender, credential, _fd, _offset, _len, _mode);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fallocate(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _offset;
	unsigned long long __maybe_unused _len;
	int __maybe_unused _mode;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, unsigned long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, unsigned long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_mode, data, 3, arg_sz, model, type, int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fallocate(sender, credential, _fd, _offset, _len, _mode);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	int __maybe_unused _type;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_cwdroot(sender, credential, _dfd, _type, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	int __maybe_unused _type;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_set_cwdroot(sender, credential, _dfd, _type, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fchdir(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchdir(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fchdir(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fchdir(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 0, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_disable_cwdroot(sender, credential, _type);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 0, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_disable_cwdroot(sender, credential, _type);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_update_cwdroot(sender, credential, _cnode_idx, _type);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_update_cwdroot(sender, credential, _cnode_idx, _type);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cmd;
	unsigned int __maybe_unused _cnode_idx;
	unsigned long __maybe_unused _lock_id;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cmd, data, 0, arg_sz, model, type, unsigned int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_lock_id, data, 2, arg_sz, model, type, unsigned long, _lock_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_handle_global_locks(sender, credential, _cmd, _cnode_idx, _lock_id);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cmd;
	unsigned int __maybe_unused _cnode_idx;
	unsigned long __maybe_unused _lock_id;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cmd, data, 0, arg_sz, model, type, unsigned int, _cmd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_lock_id, data, 2, arg_sz, model, type, unsigned long, _lock_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_handle_global_locks(sender, credential, _cmd, _cnode_idx, _lock_id);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_send_fd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _send_fd;
	unsigned int __maybe_unused _send_cidx;
	unsigned int __maybe_unused _recv_cidx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_send_fd, data, 0, arg_sz, model, type, int, _send_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_send_cidx, data, 1, arg_sz, model, type, unsigned int, _send_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_recv_cidx, data, 2, arg_sz, model, type, unsigned int, _recv_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_send_fd(sender, credential, _send_fd, _send_cidx, _recv_cidx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_send_fd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _send_fd;
	unsigned int __maybe_unused _send_cidx;
	unsigned int __maybe_unused _recv_cidx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_send_fd, data, 0, arg_sz, model, type, int, _send_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_send_cidx, data, 1, arg_sz, model, type, unsigned int, _send_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_recv_cidx, data, 2, arg_sz, model, type, unsigned int, _recv_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_send_fd(sender, credential, _send_fd, _send_cidx, _recv_cidx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_recv_fd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _sfiles_idx;
	unsigned int __maybe_unused _send_cidx;
	int __maybe_unused _recv_fd;
	unsigned int __maybe_unused _recv_cidx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sfiles_idx, data, 0, arg_sz, model, type, int, _sfiles_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_send_cidx, data, 1, arg_sz, model, type, unsigned int, _send_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_recv_fd, data, 2, arg_sz, model, type, int, _recv_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_recv_cidx, data, 3, arg_sz, model, type, unsigned int, _recv_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_recv_fd(sender, credential, _sfiles_idx, _send_cidx, _recv_fd, _recv_cidx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_recv_fd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _sfiles_idx;
	unsigned int __maybe_unused _send_cidx;
	int __maybe_unused _recv_fd;
	unsigned int __maybe_unused _recv_cidx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sfiles_idx, data, 0, arg_sz, model, type, int, _sfiles_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_send_cidx, data, 1, arg_sz, model, type, unsigned int, _send_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_recv_fd, data, 2, arg_sz, model, type, int, _recv_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_recv_cidx, data, 3, arg_sz, model, type, unsigned int, _recv_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_recv_fd(sender, credential, _sfiles_idx, _send_cidx, _recv_fd, _recv_cidx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _ptr;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_ptr, data, 1, arg_sz, model, type, unsigned long long, _ptr)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_buffer_wrapper(sender, credential, _fd, _ptr);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _ptr;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_ptr, data, 1, arg_sz, model, type, unsigned long long, _ptr)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_buffer_wrapper(sender, credential, _fd, _ptr);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _me_idx;
	uintptr_t __maybe_unused _pathname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 1, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uintptr_t);
		type = __type_of(uintptr_t);
		__fetch_one_arg((void*)&_pathname, data, 2, arg_sz, model, type, uintptr_t, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_pathname_by_me_idx(sender, credential, _fd, _me_idx, _pathname);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _me_idx;
	uintptr_t __maybe_unused _pathname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 1, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uintptr_t);
		type = __type_of(uintptr_t);
		__fetch_one_arg((void*)&_pathname, data, 2, arg_sz, model, type, uintptr_t, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_pathname_by_me_idx(sender, credential, _fd, _me_idx, _pathname);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_sfile_put(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _send_cidx;
	unsigned int __maybe_unused _recv_cidx;
	int __maybe_unused _sfiles_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_send_cidx, data, 0, arg_sz, model, type, unsigned int, _send_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_recv_cidx, data, 1, arg_sz, model, type, unsigned int, _recv_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sfiles_idx, data, 2, arg_sz, model, type, int, _sfiles_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_sfile_put(sender, credential, _send_cidx, _recv_cidx, _sfiles_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_sfile_put(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _send_cidx;
	unsigned int __maybe_unused _recv_cidx;
	int __maybe_unused _sfiles_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_send_cidx, data, 0, arg_sz, model, type, unsigned int, _send_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_recv_cidx, data, 1, arg_sz, model, type, unsigned int, _recv_cidx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_sfiles_idx, data, 2, arg_sz, model, type, int, _sfiles_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_sfile_put(sender, credential, _send_cidx, _recv_cidx, _sfiles_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_readlinkat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused char *_buf;
	unsigned long long __maybe_unused _bufsize;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_bufsize, data, 2, arg_sz, model, type, unsigned long long, _bufsize)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readlinkat(sender, credential, _dfd, _buf, _bufsize, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_readlinkat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused char *_buf;
	unsigned long long __maybe_unused _bufsize;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_bufsize, data, 2, arg_sz, model, type, unsigned long long, _bufsize)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_readlinkat(sender, credential, _dfd, _buf, _bufsize, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused char *_msg;
	unsigned int __maybe_unused _msg_len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_msg, data, 0, arg_sz, model, type, char*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_msg_len, data, 1, arg_sz, model, type, unsigned int, _msg_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_slabinfo(sender, credential, _msg, _msg_len);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused char *_msg;
	unsigned int __maybe_unused _msg_len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_msg, data, 0, arg_sz, model, type, char*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_msg_len, data, 1, arg_sz, model, type, unsigned int, _msg_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_slabinfo(sender, credential, _msg, _msg_len);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused char *_msg;
	unsigned int __maybe_unused _msg_len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_msg, data, 0, arg_sz, model, type, char*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_msg_len, data, 1, arg_sz, model, type, unsigned int, _msg_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_get_slabinfo(sender, credential, _msg, _msg_len);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	__maybe_unused char *_msg;
	unsigned int __maybe_unused _msg_len;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_msg, data, 0, arg_sz, model, type, char*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_msg_len, data, 1, arg_sz, model, type, unsigned int, _msg_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_get_slabinfo(sender, credential, _msg, _msg_len);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _count;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_count, data, 0, arg_sz, model, type, int, _count)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fscache_print_info(sender, credential, _count);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _count;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_count, data, 0, arg_sz, model, type, int, _count)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fscache_print_info(sender, credential, _count);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	int __maybe_unused _new_me_idx;
	unsigned long __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_new_me_idx, data, 1, arg_sz, model, type, int, _new_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(sender, credential, _me_idx, _new_me_idx, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	int __maybe_unused _new_me_idx;
	unsigned long __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_new_me_idx, data, 1, arg_sz, model, type, int, _new_me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long);
		type = __type_of(unsigned long);
		__fetch_one_arg((void*)&_flags, data, 2, arg_sz, model, type, unsigned long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(sender, credential, _me_idx, _new_me_idx, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	unsigned int __maybe_unused _fs_handle;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_fs_handle, data, 1, arg_sz, model, type, unsigned int, _fs_handle)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_free_fs_handle_for_same_device(sender, credential, _me_idx, _fs_handle);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _me_idx;
	unsigned int __maybe_unused _fs_handle;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_me_idx, data, 0, arg_sz, model, type, int, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_fs_handle, data, 1, arg_sz, model, type, unsigned int, _fs_handle)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_free_fs_handle_for_same_device(sender, credential, _me_idx, _fs_handle);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_memfd_create(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_memfd_create(sender, credential, _fd, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_memfd_create(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 1, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_memfd_create(sender, credential, _fd, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mknod(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _parent_fd;
	unsigned long long __maybe_unused _devno;
	unsigned int __maybe_unused _mode;
	__maybe_unused void *_msg;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_parent_fd, data, 0, arg_sz, model, type, int, _parent_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_devno, data, 1, arg_sz, model, type, unsigned long long, _devno)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 2, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_msg, data, 3, arg_sz, model, type, void*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mknod(sender, credential, _parent_fd, _devno, _mode, _msg, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mknod(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _parent_fd;
	unsigned long long __maybe_unused _devno;
	unsigned int __maybe_unused _mode;
	__maybe_unused void *_msg;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_parent_fd, data, 0, arg_sz, model, type, int, _parent_fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_devno, data, 1, arg_sz, model, type, unsigned long long, _devno)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_mode, data, 2, arg_sz, model, type, unsigned int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_msg, data, 3, arg_sz, model, type, void*, _msg)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mknod(sender, credential, _parent_fd, _devno, _mode, _msg, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_rename(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _old_pfd;
	int __maybe_unused _new_pfd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_old_pfd, data, 0, arg_sz, model, type, int, _old_pfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_new_pfd, data, 1, arg_sz, model, type, int, _new_pfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_rename(sender, credential, _old_pfd, _new_pfd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_rename(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _old_pfd;
	int __maybe_unused _new_pfd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_old_pfd, data, 0, arg_sz, model, type, int, _old_pfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_new_pfd, data, 1, arg_sz, model, type, int, _new_pfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_rename(sender, credential, _old_pfd, _new_pfd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mkdirat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	mode_t __maybe_unused _mode;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(mode_t);
		type = __type_of(mode_t);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, mode_t, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mkdirat(sender, credential, _dfd, _mode, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mkdirat(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	mode_t __maybe_unused _mode;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(mode_t);
		type = __type_of(mode_t);
		__fetch_one_arg((void*)&_mode, data, 1, arg_sz, model, type, mode_t, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mkdirat(sender, credential, _dfd, _mode, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_link(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _old_pfd;
	int __maybe_unused _new_pfd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_old_pfd, data, 0, arg_sz, model, type, int, _old_pfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_new_pfd, data, 1, arg_sz, model, type, int, _new_pfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_link(sender, credential, _old_pfd, _new_pfd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_link(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _old_pfd;
	int __maybe_unused _new_pfd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_old_pfd, data, 0, arg_sz, model, type, int, _old_pfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_new_pfd, data, 1, arg_sz, model, type, int, _new_pfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_link(sender, credential, _old_pfd, _new_pfd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_unlink(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned int __maybe_unused _flag;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 1, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unlink(sender, credential, _dfd, _flag, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_unlink(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	unsigned int __maybe_unused _flag;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 1, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 2, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 3, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 4, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_unlink(sender, credential, _dfd, _flag, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_symlink(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused const void *_target;
	unsigned int __maybe_unused _tarlen;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_target, data, 1, arg_sz, model, type, const void*, _target)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_tarlen, data, 2, arg_sz, model, type, unsigned int, _tarlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_symlink(sender, credential, _dfd, _target, _tarlen, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_symlink(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused const void *_target;
	unsigned int __maybe_unused _tarlen;
	__maybe_unused void *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const void*);
		type = __type_of(const void*);
		__fetch_one_arg((void*)&_target, data, 1, arg_sz, model, type, const void*, _target)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_tarlen, data, 2, arg_sz, model, type, unsigned int, _tarlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_newpath, data, 3, arg_sz, model, type, void*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 4, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 5, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_symlink(sender, credential, _dfd, _target, _tarlen, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_getxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _pcnode_idx;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _dfd;
	struct sysif_getxattr_args __maybe_unused _sga;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_pcnode_idx, data, 0, arg_sz, model, type, unsigned int, _pcnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 2, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct sysif_getxattr_args);
		type = __type_of(struct sysif_getxattr_args);
		__fetch_one_arg((void*)&_sga, data, 3, arg_sz, model, type, struct sysif_getxattr_args, _sga)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 4, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 5, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 6, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 7, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_getxattr(sender, credential, _pcnode_idx, _cnode_idx, _dfd, _sga, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_getxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _pcnode_idx;
	unsigned int __maybe_unused _cnode_idx;
	int __maybe_unused _dfd;
	struct sysif_getxattr_args __maybe_unused _sga;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_pcnode_idx, data, 0, arg_sz, model, type, unsigned int, _pcnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 2, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(struct sysif_getxattr_args);
		type = __type_of(struct sysif_getxattr_args);
		__fetch_one_arg((void*)&_sga, data, 3, arg_sz, model, type, struct sysif_getxattr_args, _sga)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 4, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 5, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 6, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 7, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_getxattr(sender, credential, _pcnode_idx, _cnode_idx, _dfd, _sga, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fgetxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	__maybe_unused void *_value;
	size_t __maybe_unused _size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_value, data, 3, arg_sz, model, type, void*, _value)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 4, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fgetxattr(sender, credential, _fd, _name, _namelen, _value, _size);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fgetxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	__maybe_unused void *_value;
	size_t __maybe_unused _size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(void*);
		type = __type_of(void*);
		__fetch_one_arg((void*)&_value, data, 3, arg_sz, model, type, void*, _value)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 4, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fgetxattr(sender, credential, _fd, _name, _namelen, _value, _size);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_setxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	__maybe_unused const char *_value;
	size_t __maybe_unused _size;
	int __maybe_unused _flags;
	unsigned int __maybe_unused _walk_flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_value, data, 3, arg_sz, model, type, const char*, _value)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 4, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 5, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_walk_flags, data, 6, arg_sz, model, type, unsigned int, _walk_flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 7, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 8, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 9, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_setxattr(sender, credential, _dfd, _name, _namelen, _value, _size, _flags, _walk_flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_setxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	__maybe_unused const char *_value;
	size_t __maybe_unused _size;
	int __maybe_unused _flags;
	unsigned int __maybe_unused _walk_flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_value, data, 3, arg_sz, model, type, const char*, _value)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 4, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 5, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_walk_flags, data, 6, arg_sz, model, type, unsigned int, _walk_flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 7, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 8, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 9, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_setxattr(sender, credential, _dfd, _name, _namelen, _value, _size, _flags, _walk_flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fsetxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	__maybe_unused const char *_value;
	size_t __maybe_unused _size;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_value, data, 3, arg_sz, model, type, const char*, _value)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 4, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 5, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fsetxattr(sender, credential, _fd, _name, _namelen, _value, _size, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fsetxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	__maybe_unused const char *_value;
	size_t __maybe_unused _size;
	int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_value, data, 3, arg_sz, model, type, const char*, _value)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 4, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_flags, data, 5, arg_sz, model, type, int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fsetxattr(sender, credential, _fd, _name, _namelen, _value, _size, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_listxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused char *_list;
	size_t __maybe_unused _size;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_list, data, 1, arg_sz, model, type, char*, _list)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 2, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 4, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 5, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 6, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_listxattr(sender, credential, _dfd, _list, _size, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_listxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_THREE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused char *_list;
	size_t __maybe_unused _size;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_list, data, 1, arg_sz, model, type, char*, _list)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 2, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 4, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 5, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 6, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_listxattr(sender, credential, _dfd, _list, _size, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_flistxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused char *_list;
	size_t __maybe_unused _size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_list, data, 1, arg_sz, model, type, char*, _list)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 2, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_flistxattr(sender, credential, _fd, _list, _size);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_flistxattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused char *_list;
	size_t __maybe_unused _size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_list, data, 1, arg_sz, model, type, char*, _list)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_size, data, 2, arg_sz, model, type, size_t, _size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_flistxattr(sender, credential, _fd, _list, _size);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_removexattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 4, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 5, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 6, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_removexattr(sender, credential, _dfd, _name, _namelen, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_removexattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _dfd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	unsigned int __maybe_unused _flags;
	__maybe_unused char *_newpath;
	__maybe_unused char *_new_server;
	__maybe_unused int *_me_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_dfd, data, 0, arg_sz, model, type, int, _dfd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_newpath, data, 4, arg_sz, model, type, char*, _newpath)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_new_server, data, 5, arg_sz, model, type, char*, _new_server)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int*);
		type = __type_of(int*);
		__fetch_one_arg((void*)&_me_idx, data, 6, arg_sz, model, type, int*, _me_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_removexattr(sender, credential, _dfd, _name, _namelen, _flags, _newpath, _new_server, _me_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fremovexattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fremovexattr(sender, credential, _fd, _name, _namelen);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fremovexattr(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused const char *_name;
	size_t __maybe_unused _namelen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(const char*);
		type = __type_of(const char*);
		__fetch_one_arg((void*)&_name, data, 1, arg_sz, model, type, const char*, _name)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_namelen, data, 2, arg_sz, model, type, size_t, _namelen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fremovexattr(sender, credential, _fd, _name, _namelen);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_iommap(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	rref_t __maybe_unused _vs_rref;
	unsigned int __maybe_unused _vs_cnode_idx;
	uintptr_t __maybe_unused _vaddr;
	size_t __maybe_unused _aligned_len;
	unsigned int __maybe_unused _prot;
	unsigned int __maybe_unused _flags;
	long long __maybe_unused _offset;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(rref_t);
		type = __type_of(rref_t);
		__fetch_one_arg((void*)&_vs_rref, data, 1, arg_sz, model, type, rref_t, _vs_rref)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_vs_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _vs_cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uintptr_t);
		type = __type_of(uintptr_t);
		__fetch_one_arg((void*)&_vaddr, data, 3, arg_sz, model, type, uintptr_t, _vaddr)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_aligned_len, data, 4, arg_sz, model, type, size_t, _aligned_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_prot, data, 5, arg_sz, model, type, unsigned int, _prot)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 6, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 7, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_iommap(sender, credential, _fd, _vs_rref, _vs_cnode_idx, _vaddr, _aligned_len, _prot, _flags, _offset);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_iommap(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	rref_t __maybe_unused _vs_rref;
	unsigned int __maybe_unused _vs_cnode_idx;
	uintptr_t __maybe_unused _vaddr;
	size_t __maybe_unused _aligned_len;
	unsigned int __maybe_unused _prot;
	unsigned int __maybe_unused _flags;
	long long __maybe_unused _offset;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(rref_t);
		type = __type_of(rref_t);
		__fetch_one_arg((void*)&_vs_rref, data, 1, arg_sz, model, type, rref_t, _vs_rref)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_vs_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _vs_cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uintptr_t);
		type = __type_of(uintptr_t);
		__fetch_one_arg((void*)&_vaddr, data, 3, arg_sz, model, type, uintptr_t, _vaddr)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_aligned_len, data, 4, arg_sz, model, type, size_t, _aligned_len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_prot, data, 5, arg_sz, model, type, unsigned int, _prot)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 6, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 7, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_iommap(sender, credential, _fd, _vs_rref, _vs_cnode_idx, _vaddr, _aligned_len, _prot, _flags, _offset);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mmap_create(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _offset;
	unsigned long long __maybe_unused _len;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _prot;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, unsigned long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 3, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_prot, data, 4, arg_sz, model, type, unsigned int, _prot)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 5, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_create(sender, credential, _fd, _offset, _len, _cnode_idx, _prot, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_create(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	long long __maybe_unused _offset;
	unsigned long long __maybe_unused _len;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _prot;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, unsigned long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 3, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_prot, data, 4, arg_sz, model, type, unsigned int, _prot)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 5, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_create(sender, credential, _fd, _offset, _len, _cnode_idx, _prot, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_release_file(sender, credential, _fid, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_release_file(sender, credential, _fid, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mmap_change(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	long long __maybe_unused _offset;
	unsigned long long __maybe_unused _len;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _prot;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, unsigned long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 3, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_prot, data, 4, arg_sz, model, type, unsigned int, _prot)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_change(sender, credential, _fid, _offset, _len, _cnode_idx, _prot);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	long long __maybe_unused _offset;
	unsigned long long __maybe_unused _len;
	unsigned int __maybe_unused _cnode_idx;
	unsigned int __maybe_unused _prot;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(long long);
		type = __type_of(long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_len, data, 2, arg_sz, model, type, unsigned long long, _len)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 3, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_prot, data, 4, arg_sz, model, type, unsigned int, _prot)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_change(sender, credential, _fid, _offset, _len, _cnode_idx, _prot);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	unsigned long long __maybe_unused _node_page_idx;
	unsigned int __maybe_unused _cnode_idx;
	unsigned long long __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_node_page_idx, data, 1, arg_sz, model, type, unsigned long long, _node_page_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned long long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fill_page(sender, credential, _fid, _node_page_idx, _cnode_idx, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	unsigned long long __maybe_unused _node_page_idx;
	unsigned int __maybe_unused _cnode_idx;
	unsigned long long __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_node_page_idx, data, 1, arg_sz, model, type, unsigned long long, _node_page_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_flags, data, 3, arg_sz, model, type, unsigned long long, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fill_page(sender, credential, _fid, _node_page_idx, _cnode_idx, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	unsigned long long __maybe_unused _node_page_idx;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_node_page_idx, data, 1, arg_sz, model, type, unsigned long long, _node_page_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fetch_page(sender, credential, _fid, _node_page_idx, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	unsigned long long __maybe_unused _node_page_idx;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_node_page_idx, data, 1, arg_sz, model, type, unsigned long long, _node_page_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fetch_page(sender, credential, _fid, _node_page_idx, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _index;
	unsigned long long __maybe_unused _dev_id;
	unsigned long long __maybe_unused _node_page_idx;
	unsigned int __maybe_unused _flag;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_index, data, 0, arg_sz, model, type, unsigned int, _index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 1, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_node_page_idx, data, 2, arg_sz, model, type, unsigned long long, _node_page_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 3, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_change_page(sender, credential, _index, _dev_id, _node_page_idx, _flag);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _index;
	unsigned long long __maybe_unused _dev_id;
	unsigned long long __maybe_unused _node_page_idx;
	unsigned int __maybe_unused _flag;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_index, data, 0, arg_sz, model, type, unsigned int, _index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_dev_id, data, 1, arg_sz, model, type, unsigned long long, _dev_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_node_page_idx, data, 2, arg_sz, model, type, unsigned long long, _node_page_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flag, data, 3, arg_sz, model, type, unsigned int, _flag)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_change_page(sender, credential, _index, _dev_id, _node_page_idx, _flag);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	unsigned long long __maybe_unused _offset;
	unsigned long long __maybe_unused _length;
	int __maybe_unused _mode;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, unsigned long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_length, data, 2, arg_sz, model, type, unsigned long long, _length)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_mode, data, 3, arg_sz, model, type, int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 4, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fallocate(sender, credential, _fid, _offset, _length, _mode, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fid;
	unsigned long long __maybe_unused _offset;
	unsigned long long __maybe_unused _length;
	int __maybe_unused _mode;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fid, data, 0, arg_sz, model, type, int, _fid)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_offset, data, 1, arg_sz, model, type, unsigned long long, _offset)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_length, data, 2, arg_sz, model, type, unsigned long long, _length)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_mode, data, 3, arg_sz, model, type, int, _mode)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 4, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_mmap_fallocate(sender, credential, _fid, _offset, _length, _mode, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _remote_index;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_remote_index, data, 1, arg_sz, model, type, int, _remote_index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_update(sender, credential, _fd, _remote_index, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _remote_index;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_remote_index, data, 1, arg_sz, model, type, int, _remote_index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_update(sender, credential, _fd, _remote_index, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_remove(sender, credential, _fd, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 1, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_remove(sender, credential, _fd, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _new_size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_new_size, data, 0, arg_sz, model, type, unsigned int, _new_size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_expand(sender, credential, _new_size);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _new_size;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_new_size, data, 0, arg_sz, model, type, unsigned int, _new_size)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_expand(sender, credential, _new_size);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _start;
	int __maybe_unused _type;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_start, data, 0, arg_sz, model, type, int, _start)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_acquire(sender, credential, _start, _type, _cnode_idx);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _start;
	int __maybe_unused _type;
	unsigned int __maybe_unused _cnode_idx;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_start, data, 0, arg_sz, model, type, int, _start)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 2, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_acquire(sender, credential, _start, _type, _cnode_idx);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_release(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_release(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_replace(sender, credential, _fd, _type);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	int __maybe_unused _type;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_type, data, 1, arg_sz, model, type, int, _type)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_replace(sender, credential, _fd, _type);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused char *_pathname;
	int __maybe_unused _pathlen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_pathname, data, 1, arg_sz, model, type, char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_pathlen, data, 2, arg_sz, model, type, int, _pathlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_fault(sender, credential, _fd, _pathname, _pathlen);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	__maybe_unused char *_pathname;
	int __maybe_unused _pathlen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_pathname, data, 1, arg_sz, model, type, char*, _pathname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_pathlen, data, 2, arg_sz, model, type, int, _pathlen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_gfd_table_fault(sender, credential, _fd, _pathname, _pathlen);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	uref_t __maybe_unused _dh_ap_uref;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uref_t);
		type = __type_of(uref_t);
		__fetch_one_arg((void*)&_dh_ap_uref, data, 0, arg_sz, model, type, uref_t, _dh_ap_uref)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_anon_register_devhost(sender, credential, _dh_ap_uref);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	uref_t __maybe_unused _dh_ap_uref;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(uref_t);
		type = __type_of(uref_t);
		__fetch_one_arg((void*)&_dh_ap_uref, data, 0, arg_sz, model, type, uref_t, _dh_ap_uref)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_anon_register_devhost(sender, credential, _dh_ap_uref);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 0, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_unused_fd(sender, credential, _flags);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _flags;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_flags, data, 0, arg_sz, model, type, unsigned int, _flags)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_unused_fd(sender, credential, _flags);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_put_unused_fd(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_put_unused_fd(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_fd_info_update(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _file_id;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_file_id, data, 1, arg_sz, model, type, unsigned long long, _file_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fd_info_update(sender, credential, _fd, _file_id);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_fd_info_update(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	unsigned long long __maybe_unused _file_id;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_file_id, data, 1, arg_sz, model, type, unsigned long long, _file_id)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_fd_info_update(sender, credential, _fd, _file_id);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_get_root_path(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_buf;
	int __maybe_unused _buflen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_buflen, data, 2, arg_sz, model, type, int, _buflen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_root_path(sender, credential, _cnode_idx, _buf, _buflen);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_get_root_path(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_buf;
	int __maybe_unused _buflen;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_buflen, data, 2, arg_sz, model, type, int, _buflen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_get_root_path(sender, credential, _cnode_idx, _buf, _buflen);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_transfs_fget(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_transfs_fget(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fget(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_transfs_fget(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_trans_fget(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	int __maybe_unused _fd;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(int);
		type = __type_of(int);
		__fetch_one_arg((void*)&_fd, data, 0, arg_sz, model, type, int, _fd)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_trans_fget(sender, credential, _fd);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_transfs_fput(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _me_index;
	unsigned long long __maybe_unused _hm_filp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_me_index, data, 0, arg_sz, model, type, unsigned int, _me_index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_hm_filp, data, 1, arg_sz, model, type, unsigned long long, _hm_filp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_transfs_fput(sender, credential, _me_index, _hm_filp);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fput(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _me_index;
	unsigned long long __maybe_unused _hm_filp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_me_index, data, 0, arg_sz, model, type, unsigned int, _me_index)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_hm_filp, data, 1, arg_sz, model, type, unsigned long long, _hm_filp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_transfs_fput(sender, credential, _me_index, _hm_filp);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned long long __maybe_unused _hm_filp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_hm_filp, data, 0, arg_sz, model, type, unsigned long long, _hm_filp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_trans_fput(sender, credential, _hm_filp);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned long long __maybe_unused _hm_filp;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned long long);
		type = __type_of(unsigned long long);
		__fetch_one_arg((void*)&_hm_filp, data, 0, arg_sz, model, type, unsigned long long, _hm_filp)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_do_trans_fput(sender, credential, _hm_filp);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_compat_vfs_read_mounts(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_NONE;
	bool __maybe_unused is_r3_passing = true;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_buf;
	size_t __maybe_unused _buflen;
	__maybe_unused char *_srvname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_buflen, data, 2, arg_sz, model, type, size_t, _buflen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_srvname, data, 3, arg_sz, model, type, char*, _srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_read_mounts(sender, credential, _cnode_idx, _buf, _buflen, _srvname);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_compat_vfs_read_mounts(unsigned long long sender, unsigned long credential, unsigned long sp, unsigned long x3)
{
	__maybe_unused union {
		unsigned long x3;
		struct compat_x3 __compat_x3;
	} ___val = {
		0
	};
	___val.x3 = x3;
	unsigned int __maybe_unused ___w3 = ___val.__compat_x3.w3;
	__maybe_unused char *data = (char*)(uintptr_t)sp;
	unsigned int __maybe_unused cursor = __RPC_ACTVCALL_HDLR_UNUSED_ARGS_ONE;
	bool __maybe_unused is_r3_passing = false;
	enum __data_model __maybe_unused model = _DATA_MODEL_ILP32;
	enum __type __maybe_unused type;
	unsigned int __maybe_unused _cnode_idx;
	__maybe_unused char *_buf;
	size_t __maybe_unused _buflen;
	__maybe_unused char *_srvname;
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(unsigned int);
		type = __type_of(unsigned int);
		__fetch_one_arg((void*)&_cnode_idx, data, 0, arg_sz, model, type, unsigned int, _cnode_idx)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_buf, data, 1, arg_sz, model, type, char*, _buf)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(size_t);
		type = __type_of(size_t);
		__fetch_one_arg((void*)&_buflen, data, 2, arg_sz, model, type, size_t, _buflen)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	do {
		int fetch_sz;
		unsigned long align;
		unsigned long arg_sz = sizeof(char*);
		type = __type_of(char*);
		__fetch_one_arg((void*)&_srvname, data, 3, arg_sz, model, type, char*, _srvname)
		if (fetch_sz < 0) {
			panic("failed to fetch arg: %s\n", hmstrerror(fetch_sz));
		}
		cursor += fetch_sz;
	} while (0);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	if (__nr_ul * sizeof(__u32) != cursor) {
		return E_HM_INVAL;
	}
	return __actvshadowhdlr_fshandler_vfs_read_mounts(sender, credential, _cnode_idx, _buf, _buflen, _srvname);
}

#endif
#else
static int __opt_nonoframe __actvbridgehdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct procfs_ops_cb ops)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct procfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct procfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_procfs_create_data(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(struct procfs_ops_cb, ops));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_procfs_create_data(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct procfs_ops_cb ops)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct procfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct procfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_procfs_create_data(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(struct procfs_ops_cb, ops));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, const char *pathname)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_procfs_delete_data(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_procfs_delete_data(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_procfs_delete_data(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long*), __arch_actv_rpc_stksz_alignment(unsigned long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_procfs_get_process_fds(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long*, bitmap), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, max_files));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_procfs_get_process_fds(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long *bitmap, unsigned int max_files)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long*), __arch_actv_rpc_stksz_alignment(unsigned long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_procfs_get_process_fds(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long*, bitmap), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, max_files));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_procfs_get_fd_mode(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_procfs_get_fd_mode(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct sysfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_sysfs_create_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(struct sysfs_ops_cb, ops));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_create_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode, struct sysfs_ops_cb ops)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysfs_ops_cb), __arch_actv_rpc_stksz_alignment(struct sysfs_ops_cb));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_sysfs_create_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(struct sysfs_ops_cb, ops));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_sysfs_create_dir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_create_dir(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_sysfs_create_dir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, const char *pathname, unsigned int mode)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_sysfs_create_symlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_create_symlink(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname, unsigned int mode)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_sysfs_create_symlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, const char *pathname)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_sysfs_delete(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_delete(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *pathname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_sysfs_delete(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential)
{
	return actvhdlr_fshandler_sysfs_notify(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_sysfs_notify(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	return actvhdlr_fshandler_sysfs_notify(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_clock_settime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_clock_settime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_clock_settime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_clock_gettime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_clock_gettime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_clock_gettime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, int fd, unsigned long tp)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_clock_getres(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_clock_getres(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_clock_getres(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, int fd, unsigned long tx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_clock_adjtime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_clock_adjtime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long tx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_clock_adjtime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, tx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_init1(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_init1(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_init1(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_add_watch(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mask), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_add_watch(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int fd, unsigned int mask, int me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_add_watch(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mask), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, int fd, int wd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_rm_watch(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_rm_watch(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int wd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_rm_watch(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_add_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(struct fsnotify_mark_pars, pars), __ARCH_ACTV_RPC_RECV_ARG(char*, new_path), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_add_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(struct fsnotify_mark_pars, pars), __ARCH_ACTV_RPC_RECV_ARG(char*, new_path), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_rm_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_rm_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, event), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cookie), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_notify(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, event), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cookie), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_inode_destroyed(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_inotify_inode_destroyed(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_init(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_init(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_init(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint64_t), __arch_actv_rpc_stksz_alignment(uint64_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_mark(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fanotify_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(uint64_t, mask), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_mark(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fanotify_fd, unsigned int flags, uint64_t mask, int me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint64_t), __arch_actv_rpc_stksz_alignment(uint64_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_mark(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fanotify_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(uint64_t, mask), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_mark_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(struct fsnotify_mark_pars, pars), __ARCH_ACTV_RPC_RECV_ARG(char*, new_path), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_mark_internal(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int *me_idx, unsigned int cnode_idx, unsigned int nsid, struct fsnotify_mark_pars pars, char *new_path, char *srvname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct fsnotify_mark_pars), __arch_actv_rpc_stksz_alignment(struct fsnotify_mark_pars));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_mark_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(struct fsnotify_mark_pars, pars), __ARCH_ACTV_RPC_RECV_ARG(char*, new_path), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_rm_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, fanotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, obj_type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int fanotify_fd, int wd, unsigned int nsid, unsigned int index, unsigned long long dev_id, unsigned int obj_type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_rm_watch_internal(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, fanotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, obj_type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, event), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cookie), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token), __ARCH_ACTV_RPC_RECV_ARG(int, pid));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_notify(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int event, unsigned int cookie, unsigned int token, int pid)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, event), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cookie), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token), __ARCH_ACTV_RPC_RECV_ARG(int, pid));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_destroyed(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_destroyed(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int inotify_fd, int wd, unsigned int token)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_destroyed(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, inotify_fd), __ARCH_ACTV_RPC_RECV_ARG(int, wd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, token));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_open(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_fanotify_open(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int fd, unsigned int flags, unsigned int mode, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_fanotify_open(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, unsigned long long dev_id)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_endio_io_done(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_endio_io_done(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long dev_id)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_endio_io_done(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, int fd, unsigned long long label)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_set_label(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, label));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_set_label(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long label)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_set_label(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, label));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_set_label_by_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, label), __ARCH_ACTV_RPC_RECV_ARG(int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long label, int flag, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_set_label_by_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, label), __ARCH_ACTV_RPC_RECV_ARG(int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_label(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_label(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_label(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential)
{
	return actvhdlr_fshandler_vfs_init_audit(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_init_audit(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	return actvhdlr_fshandler_vfs_init_audit(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_add_audit_rule(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned short, shm_rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned short, shm_rule_num), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned short shm_rule_id, unsigned short shm_rule_num, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned short), __arch_actv_rpc_stksz_alignment(unsigned short));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_add_audit_rule(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned short, shm_rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned short, shm_rule_num), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_del_audit_rule(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long rule_id, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_del_audit_rule(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_match_audit_watch_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, unsigned long long dev_id, unsigned int index)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_match_audit_watch_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, unsigned long long rule_id, int audit_me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_match_audit_watch_dir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(int, audit_me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long rule_id, int audit_me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_match_audit_watch_dir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rule_id), __ARCH_ACTV_RPC_RECV_ARG(int, audit_me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, uref_t uref, char *root_srvname, int buflen)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_client_init(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref), __ARCH_ACTV_RPC_RECV_ARG(char*, root_srvname), __ARCH_ACTV_RPC_RECV_ARG(int, buflen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_client_init(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref, char *root_srvname, int buflen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_client_init(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref), __ARCH_ACTV_RPC_RECV_ARG(char*, root_srvname), __ARCH_ACTV_RPC_RECV_ARG(int, buflen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, uref_t uref1, uref_t uref2)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_bind_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref1), __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref2));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_bind_update(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t uref1, uref_t uref2)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_bind_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref1), __ARCH_ACTV_RPC_RECV_ARG(uref_t, uref2));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, int old_fd, int new_fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_clone(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_fd), __ARCH_ACTV_RPC_RECV_ARG(int, new_fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_clone(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_fd, int new_fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_clone(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_fd), __ARCH_ACTV_RPC_RECV_ARG(int, new_fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_close(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_close(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_close(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, parent_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mount(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long dev_id, unsigned long flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, parent_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_clone_mount_entry(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, dst), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, dst_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, child_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_fd), __ARCH_ACTV_RPC_RECV_ARG(int, recurse));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *dst, unsigned int dst_len, unsigned long flags, unsigned int cnode_idx, int child_me_idx, int orig_me_idx, int orig_fd, int recurse)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_clone_mount_entry(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, dst), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, dst_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, child_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_fd), __ARCH_ACTV_RPC_RECV_ARG(int, recurse));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, parent_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int parent_me_idx, int orig_me_idx, unsigned long long dev_id, unsigned long flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, parent_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, orig_me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, orig_parent_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, child_me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int orig_parent_me_idx, int child_me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, orig_parent_me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, child_me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, int me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_destroy_cloned_mount_entry(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_destroy_cloned_mount_entry(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, int me_idx, int fd, int is_dir)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_check_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, is_dir));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_check_mount(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int fd, int is_dir)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_check_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, is_dir));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, void *mp, int me_idx, unsigned int nsid)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mountpoint_del_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(void*, mp), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *mp, int me_idx, unsigned int nsid)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mountpoint_del_mount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(void*, mp), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_open(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_open(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int cnode_idx, int dfd, int fd, unsigned int flags, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_open(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, int fd, unsigned long long length)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_ftruncate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_ftruncate(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long length)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_ftruncate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, int fd, void *st)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fstat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, st));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fstat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *st)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fstat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, st));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_stat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(void*, st), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_stat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *st, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_stat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(void*, st), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_statfs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(void*, stfs), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_statfs(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, void *stfs, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_statfs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(void*, stfs), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, int fd, void *msg)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fstatfs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, msg));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fstatfs(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *msg)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fstatfs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, msg));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fsync(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fsync(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fsync(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_unmount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_unmount(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags, char *msg, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_unmount(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_unmount_from_server(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uint32_t, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_unmount_from_server(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uint32_t, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, int me_idx, uint32_t nsid, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_unmount_child(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uint32_t, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_unmount_child(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, uint32_t nsid, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uint32_t), __arch_actv_rpc_stksz_alignment(uint32_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_unmount_child(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uint32_t, nsid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_truncate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_truncate(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned long long length, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_truncate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, int fd, unsigned int idx_src, unsigned int idx_dst)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fs_fork(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, idx_src), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, idx_dst));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fs_fork(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int idx_src, unsigned int idx_dst)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fs_fork(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, idx_src), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, idx_dst));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_query_info(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_query_info(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_query_info(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, int fd, long long offset, int whence)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_lseek(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(int, whence));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_lseek(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, int whence)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_lseek(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(int, whence));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, int fd, const char *data, int pos, size_t nbyte)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_trans(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, data), __ARCH_ACTV_RPC_RECV_ARG(int, pos), __ARCH_ACTV_RPC_RECV_ARG(size_t, nbyte));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_trans(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *data, int pos, size_t nbyte)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_trans(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, data), __ARCH_ACTV_RPC_RECV_ARG(int, pos), __ARCH_ACTV_RPC_RECV_ARG(size_t, nbyte));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, int read_fd, int write_fd, int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_pipe2(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, read_fd), __ARCH_ACTV_RPC_RECV_ARG(int, write_fd), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_pipe2(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int read_fd, int write_fd, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_pipe2(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, read_fd), __ARCH_ACTV_RPC_RECV_ARG(int, write_fd), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_tee(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_tee(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, int fd_out, unsigned int len, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_tee(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_splice(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(long long*, offset_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(int, multi_srvs), __ARCH_ACTV_RPC_RECV_ARG(long long*, offset_out), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_splice(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long *offset_in, int fd_out, const char *pathname, int multi_srvs, long long *offset_out, unsigned long len, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long*), __arch_actv_rpc_stksz_alignment(long long*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_splice(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(long long*, offset_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(const char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(int, multi_srvs), __ARCH_ACTV_RPC_RECV_ARG(long long*, offset_out), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, int fd, long long pos, const char *buf, unsigned long len)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_splice_srvs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(const char*, buf), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const char *buf, unsigned long len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_splice_srvs(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(const char*, buf), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_revoke_process(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_revoke_process(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_revoke_process(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_setrlimit(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rlim_cur), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rlim_max), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_setrlimit(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned long long rlim_cur, unsigned long long rlim_max, unsigned int type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_setrlimit(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rlim_cur), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, rlim_max), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_ns(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, oldid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, newid), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_ns(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int oldid, unsigned int newid, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_ns(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, oldid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, newid), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, unsigned int nsid, int me_idx, int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_put_ns(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_put_ns(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int nsid, int me_idx, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_put_ns(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, nsid), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, int fd, unsigned int count, int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_init_eventfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, count), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_init_eventfd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int count, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_init_eventfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, count), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_write_eventfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buf_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_write_eventfd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *buf, size_t buf_len, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_write_eventfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buf_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, int fd, int clockid, int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_timerfd_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, clockid), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_timerfd_create(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int clockid, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_timerfd_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, clockid), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_timerfd_settime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, flags), __ARCH_ACTV_RPC_RECV_ARG(time_t, it_inval_sec), __ARCH_ACTV_RPC_RECV_ARG(long, it_inval_nsec), __ARCH_ACTV_RPC_RECV_ARG(time_t, it_val_sec), __ARCH_ACTV_RPC_RECV_ARG(long, it_val_nsec));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int flags, time_t it_inval_sec, long it_inval_nsec, time_t it_val_sec, long it_val_nsec)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(time_t), __arch_actv_rpc_stksz_alignment(time_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long), __arch_actv_rpc_stksz_alignment(long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_timerfd_settime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, flags), __ARCH_ACTV_RPC_RECV_ARG(time_t, it_inval_sec), __ARCH_ACTV_RPC_RECV_ARG(long, it_inval_nsec), __ARCH_ACTV_RPC_RECV_ARG(time_t, it_val_sec), __ARCH_ACTV_RPC_RECV_ARG(long, it_val_nsec));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_timerfd_gettime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_timerfd_gettime(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_open_exec(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, sys_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pcnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_open_exec(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, int sys_fd, unsigned int flags, unsigned int pcnode_idx, unsigned int cnode_idx, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_open_exec(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, sys_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pcnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_close_exec(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, sys_rfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, uapp_rfd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_close_exec(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sys_rfd, unsigned int cnode_idx, int uapp_rfd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_close_exec(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, sys_rfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, uapp_rfd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int sys_rfd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_set_elf_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, sys_rfd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_set_elf_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int sys_rfd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_set_elf_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, sys_rfd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd, unsigned long arg)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_ioctl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, arg));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_ioctl(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd, unsigned long arg)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_ioctl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, arg));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, int fd, long long pos, size_t msg_len, void *buf)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_read(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(size_t, msg_len), __ARCH_ACTV_RPC_RECV_ARG(void*, buf));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_read(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, size_t msg_len, void *buf)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_read(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(size_t, msg_len), __ARCH_ACTV_RPC_RECV_ARG(void*, buf));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_readv(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, vec), __ARCH_ACTV_RPC_RECV_ARG(int, vlen), __ARCH_ACTV_RPC_RECV_ARG(long long, pos));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_readv(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_readv(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, vec), __ARCH_ACTV_RPC_RECV_ARG(int, vlen), __ARCH_ACTV_RPC_RECV_ARG(long long, pos));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, char *buf, size_t size)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_getcwd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_getcwd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *buf, size_t size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_getcwd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_process_cwdrootexe(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, root_cnode), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(char*, buf));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, unsigned int root_cnode, int type, char *buf)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_process_cwdrootexe(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, root_cnode), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(char*, buf));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, int fd, void *buf, size_t size)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_readdir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_readdir(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, void *buf, size_t size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_readdir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, int fd, long long pos, const void *buf, size_t buf_len)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_write(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buf_len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_write(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long pos, const void *buf, size_t buf_len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_write(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, pos), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buf_len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, int fd, const void *vec, int vlen, long long pos)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_writev(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, vec), __ARCH_ACTV_RPC_RECV_ARG(int, vlen), __ARCH_ACTV_RPC_RECV_ARG(long long, pos));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_writev(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *vec, int vlen, long long pos)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_writev(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, vec), __ARCH_ACTV_RPC_RECV_ARG(int, vlen), __ARCH_ACTV_RPC_RECV_ARG(long long, pos));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential)
{
	return actvhdlr_fshandler_vfs_sync(sender, credential);
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_sync(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	return actvhdlr_fshandler_vfs_sync(sender, credential);
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, int me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_sync(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_sync(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_sync(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_utimensat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const void*, tsp), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_utimensat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *tsp, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_utimensat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const void*, tsp), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, int fd, const void *tsp)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_futimens(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, tsp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_futimens(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *tsp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_futimens(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, tsp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchmodat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchmodat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchmodat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, int fd, mode_t mode)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchmod(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchmod(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, mode_t mode)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchmod(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_drop_caches(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(int, max), __ARCH_ACTV_RPC_RECV_ARG(int, reason));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_drop_caches(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_drop_caches(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(int, max), __ARCH_ACTV_RPC_RECV_ARG(int, reason));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, unsigned int mode, int max, int reason)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_drop_caches(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(int, max), __ARCH_ACTV_RPC_RECV_ARG(int, reason));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int mode, int max, int reason)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_drop_caches(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(int, max), __ARCH_ACTV_RPC_RECV_ARG(int, reason));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, int fd, long long offset, long long len, int advice)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fadvise(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(long long, len), __ARCH_ACTV_RPC_RECV_ARG(int, advice));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fadvise(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, long long len, int advice)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fadvise(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(long long, len), __ARCH_ACTV_RPC_RECV_ARG(int, advice));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, int fd, long long offset, size_t count)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_readahead(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(size_t, count));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_readahead(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, size_t count)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_readahead(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(size_t, count));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_fd_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, path), __ARCH_ACTV_RPC_RECV_ARG(int, pathlen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_fd_path(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path, int pathlen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_fd_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, path), __ARCH_ACTV_RPC_RECV_ARG(int, pathlen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx, char *path)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_sysmgr_get_fd_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, path));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx, char *path)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_sysmgr_get_fd_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, path));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, int fd, int cmd, unsigned long arg)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fcntl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, arg));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fcntl(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int cmd, unsigned long arg)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fcntl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, arg));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, const char *special, unsigned long long len, char *srvname, int srvlen)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_device_mounted(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, special), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname), __ARCH_ACTV_RPC_RECV_ARG(int, srvlen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_device_mounted(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, const char *special, unsigned long long len, char *srvname, int srvlen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_device_mounted(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(const char*, special), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname), __ARCH_ACTV_RPC_RECV_ARG(int, srvlen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_quotactl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, cmd), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, id), __ARCH_ACTV_RPC_RECV_ARG(char*, buffer), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, buffer_size), __ARCH_ACTV_RPC_RECV_ARG(int, fs_handle));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_quotactl(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int cmd, int type, unsigned int id, char *buffer, unsigned int buffer_size, int fs_handle)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_quotactl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, cmd), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, id), __ARCH_ACTV_RPC_RECV_ARG(char*, buffer), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, buffer_size), __ARCH_ACTV_RPC_RECV_ARG(int, fs_handle));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, int fd_in, long long off_in, int fd_out, long long off_out, size_t len)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_copy_file_range(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(long long, off_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(long long, off_out), __ARCH_ACTV_RPC_RECV_ARG(size_t, len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_copy_file_range(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd_in, long long off_in, int fd_out, long long off_out, size_t len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_copy_file_range(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd_in), __ARCH_ACTV_RPC_RECV_ARG(long long, off_in), __ARCH_ACTV_RPC_RECV_ARG(int, fd_out), __ARCH_ACTV_RPC_RECV_ARG(long long, off_out), __ARCH_ACTV_RPC_RECV_ARG(size_t, len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, int fd1, int fd2)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_same_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd1), __ARCH_ACTV_RPC_RECV_ARG(int, fd2));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_same_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd1, int fd2)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_same_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd1), __ARCH_ACTV_RPC_RECV_ARG(int, fd2));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_access(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_access(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_access(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, int fd, unsigned int cmd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_flock(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_flock(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cmd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_flock(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchownat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(uid_t, uid), __ARCH_ACTV_RPC_RECV_ARG(gid_t, gid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchownat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, uid_t uid, gid_t gid, unsigned int flag, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchownat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(uid_t, uid), __ARCH_ACTV_RPC_RECV_ARG(gid_t, gid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, int fd, uid_t uid, gid_t gid)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchown(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(uid_t, uid), __ARCH_ACTV_RPC_RECV_ARG(gid_t, gid));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchown(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, uid_t uid, gid_t gid)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uid_t), __arch_actv_rpc_stksz_alignment(uid_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(gid_t), __arch_actv_rpc_stksz_alignment(gid_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchown(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(uid_t, uid), __ARCH_ACTV_RPC_RECV_ARG(gid_t, gid));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, void *addr, size_t len, int fd, unsigned long long shm_key)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_binderfs_mmap(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(void*, addr), __ARCH_ACTV_RPC_RECV_ARG(size_t, len), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, shm_key));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, void *addr, size_t len, int fd, unsigned long long shm_key)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_binderfs_mmap(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(void*, addr), __ARCH_ACTV_RPC_RECV_ARG(size_t, len), __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, shm_key));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, int fd, unsigned long long sigmask, int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_init_signalfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, sigmask), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_init_signalfd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long sigmask, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_init_signalfd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, sigmask), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_epoll_ctl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, op), __ARCH_ACTV_RPC_RECV_ARG(int, is_epoll), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_reg_info));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int op, int is_epoll, const void *epoll_reg_info)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_epoll_ctl(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, op), __ARCH_ACTV_RPC_RECV_ARG(int, is_epoll), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_reg_info));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_epoll_et_revents(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_pre_reg_info));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_epoll_et_revents(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_pre_reg_info));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_epoll_reinit(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_pre_reg_info), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_reg_info));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const void *epoll_pre_reg_info, const void *epoll_reg_info)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_epoll_reinit(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_pre_reg_info), __ARCH_ACTV_RPC_RECV_ARG(const void*, epoll_reg_info));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, const void *buf, int fdcnt)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_signalfd_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(int, fdcnt));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, const void *buf, int fdcnt)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_signalfd_notify(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(const void*, buf), __ARCH_ACTV_RPC_RECV_ARG(int, fdcnt));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, unsigned int pid)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_pid_io_stats(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pid));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int pid)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_pid_io_stats(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pid));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, int fd, unsigned long long offset, unsigned long long len, int mode)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fallocate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(int, mode));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fallocate(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long offset, unsigned long long len, int mode)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fallocate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(int, mode));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, int dfd, int type, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_set_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, int type, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_set_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchdir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fchdir(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fchdir(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, int type)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_disable_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_disable_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, int type)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_update_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, int type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_update_cwdroot(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_handle_global_locks(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, lock_id));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cmd, unsigned int cnode_idx, unsigned long lock_id)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_handle_global_locks(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cmd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, lock_id));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_send_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, send_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_send_fd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int send_fd, unsigned int send_cidx, unsigned int recv_cidx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_send_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, send_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_recv_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, sfiles_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(int, recv_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_recv_fd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int sfiles_idx, unsigned int send_cidx, int recv_fd, unsigned int recv_cidx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_recv_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, sfiles_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(int, recv_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, int fd, unsigned long long ptr)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_buffer_wrapper(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, ptr));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long ptr)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_buffer_wrapper(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, ptr));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, int fd, int me_idx, uintptr_t pathname)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_pathname_by_me_idx(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uintptr_t, pathname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int me_idx, uintptr_t pathname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_pathname_by_me_idx(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(uintptr_t, pathname));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_sfile_put(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx), __ARCH_ACTV_RPC_RECV_ARG(int, sfiles_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_sfile_put(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int send_cidx, unsigned int recv_cidx, int sfiles_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_sfile_put(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, send_cidx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, recv_cidx), __ARCH_ACTV_RPC_RECV_ARG(int, sfiles_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_readlinkat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, bufsize), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_readlinkat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *buf, unsigned long long bufsize, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_readlinkat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, bufsize), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_slabinfo(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, msg_len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_slabinfo(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, msg_len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, char *msg, unsigned int msg_len)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_get_slabinfo(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, msg_len));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, char *msg, unsigned int msg_len)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_get_slabinfo(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(char*, msg), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, msg_len));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, int count)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fscache_print_info(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, count));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int count)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fscache_print_info(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, count));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, int new_me_idx, unsigned long flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, new_me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, int new_me_idx, unsigned long flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long), __arch_actv_rpc_stksz_alignment(unsigned long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_alloc_fs_handle_for_same_device(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(int, new_me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, int me_idx, unsigned int fs_handle)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_free_fs_handle_for_same_device(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, fs_handle));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int me_idx, unsigned int fs_handle)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_free_fs_handle_for_same_device(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, me_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, fs_handle));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, int fd, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_memfd_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_memfd_create(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_memfd_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mknod(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, parent_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, devno), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(void*, msg), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mknod(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int parent_fd, unsigned long long devno, unsigned int mode, void *msg, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mknod(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, parent_fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, devno), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, mode), __ARCH_ACTV_RPC_RECV_ARG(void*, msg), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_rename(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_pfd), __ARCH_ACTV_RPC_RECV_ARG(int, new_pfd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_rename(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_rename(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_pfd), __ARCH_ACTV_RPC_RECV_ARG(int, new_pfd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mkdirat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mkdirat(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, mode_t mode, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(mode_t), __arch_actv_rpc_stksz_alignment(mode_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mkdirat(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(mode_t, mode), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, int old_pfd, int new_pfd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_link(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_pfd), __ARCH_ACTV_RPC_RECV_ARG(int, new_pfd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_link(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int old_pfd, int new_pfd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_link(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, old_pfd), __ARCH_ACTV_RPC_RECV_ARG(int, new_pfd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_unlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_unlink(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, unsigned int flag, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_unlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_symlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const void*, target), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, tarlen), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_symlink(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const void *target, unsigned int tarlen, void *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const void*), __arch_actv_rpc_stksz_alignment(const void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_symlink(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const void*, target), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, tarlen), __ARCH_ACTV_RPC_RECV_ARG(void*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysif_getxattr_args), __arch_actv_rpc_stksz_alignment(struct sysif_getxattr_args));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_getxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pcnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(struct sysif_getxattr_args, sga), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_getxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, unsigned int pcnode_idx, unsigned int cnode_idx, int dfd, struct sysif_getxattr_args sga, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(struct sysif_getxattr_args), __arch_actv_rpc_stksz_alignment(struct sysif_getxattr_args));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_getxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, pcnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(struct sysif_getxattr_args, sga), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, void *value, size_t size)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fgetxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(void*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fgetxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, void *value, size_t size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(void*), __arch_actv_rpc_stksz_alignment(void*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fgetxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(void*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_setxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(const char*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, walk_flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_setxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, const char *value, size_t size, int flags, unsigned int walk_flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_setxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(const char*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(int, flags), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, walk_flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fsetxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(const char*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fsetxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen, const char *value, size_t size, int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fsetxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(const char*, value), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_listxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(char*, list), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_listxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long __actv_fallback_unused_1, unsigned long __actv_fallback_unused_2, int dfd, char *list, size_t size, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	UNUSED(__actv_fallback_unused_1, __actv_fallback_unused_2);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 1);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_listxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(char*, list), __ARCH_ACTV_RPC_RECV_ARG(size_t, size), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, int fd, char *list, size_t size)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_flistxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(char*, list), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_flistxattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *list, size_t size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_flistxattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(char*, list), __ARCH_ACTV_RPC_RECV_ARG(size_t, size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_removexattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_removexattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int dfd, const char *name, size_t namelen, unsigned int flags, char *newpath, char *new_server, int *me_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int*), __arch_actv_rpc_stksz_alignment(int*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_removexattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, dfd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(char*, newpath), __ARCH_ACTV_RPC_RECV_ARG(char*, new_server), __ARCH_ACTV_RPC_RECV_ARG(int*, me_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, int fd, const char *name, size_t namelen)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fremovexattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fremovexattr(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, const char *name, size_t namelen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(const char*), __arch_actv_rpc_stksz_alignment(const char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fremovexattr(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(const char*, name), __ARCH_ACTV_RPC_RECV_ARG(size_t, namelen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(rref_t), __arch_actv_rpc_stksz_alignment(rref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_iommap(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(rref_t, vs_rref), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, vs_cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(uintptr_t, vaddr), __ARCH_ACTV_RPC_RECV_ARG(size_t, aligned_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(long long, offset));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_iommap(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, rref_t vs_rref, unsigned int vs_cnode_idx, uintptr_t vaddr, size_t aligned_len, unsigned int prot, unsigned int flags, long long offset)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(rref_t), __arch_actv_rpc_stksz_alignment(rref_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uintptr_t), __arch_actv_rpc_stksz_alignment(uintptr_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_iommap(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(rref_t, vs_rref), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, vs_cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(uintptr_t, vaddr), __ARCH_ACTV_RPC_RECV_ARG(size_t, aligned_len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags), __ARCH_ACTV_RPC_RECV_ARG(long long, offset));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_create(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_create(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, int fid, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_release_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_release_file(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_change(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_change(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, long long offset, unsigned long long len, unsigned int cnode_idx, unsigned int prot)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(long long), __arch_actv_rpc_stksz_alignment(long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_change(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, len), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, prot));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_fill_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx, unsigned long long flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_fill_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, int fid, unsigned long long node_page_idx, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_fetch_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long node_page_idx, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_fetch_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_change_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int index, unsigned long long dev_id, unsigned long long node_page_idx, unsigned int flag)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_change_page(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, dev_id), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, node_page_idx), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flag));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_fallocate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length), __ARCH_ACTV_RPC_RECV_ARG(int, mode), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fid, unsigned long long offset, unsigned long long length, int mode, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_mmap_fallocate(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fid), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, offset), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, length), __ARCH_ACTV_RPC_RECV_ARG(int, mode), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, int fd, int remote_index, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, remote_index), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int remote_index, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, remote_index), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, int fd, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_remove(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_remove(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, unsigned int new_size)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_expand(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, new_size));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int new_size)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_expand(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, new_size));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, int start, int type, unsigned int cnode_idx)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_acquire(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, start), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int start, int type, unsigned int cnode_idx)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_acquire(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, start), __ARCH_ACTV_RPC_RECV_ARG(int, type), __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_release(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_release(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, int fd, int type)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_replace(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, int type)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_replace(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(int, type));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, int fd, char *pathname, int pathlen)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_fault(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(int, pathlen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, char *pathname, int pathlen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_gfd_table_fault(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(char*, pathname), __ARCH_ACTV_RPC_RECV_ARG(int, pathlen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, uref_t dh_ap_uref)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_anon_register_devhost(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, dh_ap_uref));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, uref_t dh_ap_uref)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(uref_t), __arch_actv_rpc_stksz_alignment(uref_t));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_anon_register_devhost(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(uref_t, dh_ap_uref));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, unsigned int flags)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_unused_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int flags)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_unused_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, flags));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_put_unused_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_put_unused_fd(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, int fd, unsigned long long file_id)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fd_info_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, file_id));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_fd_info_update(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd, unsigned long long file_id)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_fd_info_update(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, file_id));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, int buflen)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_root_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(int, buflen));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_get_root_path(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, int buflen)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_get_root_path(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(int, buflen));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_transfs_fget(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_transfs_fget(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_transfs_fget(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, int fd)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_trans_fget(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, int fd)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(int), __arch_actv_rpc_stksz_alignment(int));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_trans_fget(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(int, fd));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, unsigned int me_index, unsigned long long hm_filp)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_transfs_fput(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, me_index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, hm_filp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_transfs_fput(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int me_index, unsigned long long hm_filp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_transfs_fput(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, me_index), __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, hm_filp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, unsigned long long hm_filp)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_trans_fput(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, hm_filp));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned long long hm_filp)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned long long), __arch_actv_rpc_stksz_alignment(unsigned long long));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_do_trans_fput(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned long long, hm_filp));
}

static int __opt_nonoframe __actvbridgehdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname)
{
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(0, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_read_mounts(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buflen), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

static int __opt_nonoframe __actvbridgecapcallhdlr_fshandler_vfs_read_mounts(unsigned long long sender, unsigned long credential, __RPC_CAPCALL_HDLR_UNUSED_ARGS, unsigned int cnode_idx, char *buf, size_t buflen, char *srvname)
{
	UNUSED(__RPC_CAPCALL_HDLR_UNUSED_ARGS_STRICT);
	struct arch_actv_local *__local = hm_actv_current_arch_actv_local();
	unsigned long __nr_ul = __RPC_INFO_DECODE_STK_BUF_NR_UL(__local->rpcinfo);
	unsigned long __maybe_unused __stacksz = 0UL;
	struct __arch_actv_stksz_state __stksz_state;
	__stksz_state = __arch_actv_rpc_stksz_init(1, 0);
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(unsigned int), __arch_actv_rpc_stksz_alignment(unsigned int));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(size_t), __arch_actv_rpc_stksz_alignment(size_t));
	__stksz_state = __arch_actv_rpc_stksz_append(__stksz_state, sizeof(char*), __arch_actv_rpc_stksz_alignment(char*));
	__stacksz = __arch_actv_rpc_stksz_done(__stksz_state);
	if (__nr_ul * sizeof(unsigned long) != __stacksz) {
		return E_HM_INVAL;
	}
	return actvhdlr_fshandler_vfs_read_mounts(sender, credential, __ARCH_ACTV_RPC_RECV_ARG(unsigned int, cnode_idx), __ARCH_ACTV_RPC_RECV_ARG(char*, buf), __ARCH_ACTV_RPC_RECV_ARG(size_t, buflen), __ARCH_ACTV_RPC_RECV_ARG(char*, srvname));
}

#endif
#ifdef __sysif_server_fs_no_compat32_handlers__
union fs_hdlrs_union sysif_fs_actvhdlr_table[__fs_method_MAX] = {
	[0 ... __ACTV_UPCALL_POOL_GRANT_CHANGE - 1U] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_default_handler)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE] = {
		.p_sysif_handle_kcall_entry = (&sysif_actv_pool_handle_grant_change)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE + 1U ... __fs_method_MIN] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_default_handler)
	},
	[__fs_method_procfs_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_create_data] = {
		.p__actvbridgehdlr_fshandler_procfs_create_data = (&__actvbridgehdlr_fshandler_procfs_create_data)
	},
	[__fs_method_procfs_delete_data] = {
		.p__actvbridgehdlr_fshandler_procfs_delete_data = (&__actvbridgehdlr_fshandler_procfs_delete_data)
	},
	[__fs_method_procfs_get_process_fds] = {
		.p__actvbridgehdlr_fshandler_procfs_get_process_fds = (&__actvbridgehdlr_fshandler_procfs_get_process_fds)
	},
	[__fs_method_procfs_get_fd_mode] = {
		.p__actvbridgehdlr_fshandler_procfs_get_fd_mode = (&__actvbridgehdlr_fshandler_procfs_get_fd_mode)
	},
	[__fs_method_sysfs_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_create_file] = {
		.p__actvbridgehdlr_fshandler_sysfs_create_file = (&__actvbridgehdlr_fshandler_sysfs_create_file)
	},
	[__fs_method_sysfs_create_dir] = {
		.p__actvbridgehdlr_fshandler_sysfs_create_dir = (&__actvbridgehdlr_fshandler_sysfs_create_dir)
	},
	[__fs_method_sysfs_create_symlink] = {
		.p__actvbridgehdlr_fshandler_sysfs_create_symlink = (&__actvbridgehdlr_fshandler_sysfs_create_symlink)
	},
	[__fs_method_sysfs_delete] = {
		.p__actvbridgehdlr_fshandler_sysfs_delete = (&__actvbridgehdlr_fshandler_sysfs_delete)
	},
	[__fs_method_sysfs_notify] = {
		.p__actvbridgehdlr_fshandler_sysfs_notify = (&__actvbridgehdlr_fshandler_sysfs_notify)
	},
	[__fs_method_clock_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_settime] = {
		.p__actvbridgehdlr_fshandler_clock_settime = (&__actvbridgehdlr_fshandler_clock_settime)
	},
	[__fs_method_clock_gettime] = {
		.p__actvbridgehdlr_fshandler_clock_gettime = (&__actvbridgehdlr_fshandler_clock_gettime)
	},
	[__fs_method_clock_getres] = {
		.p__actvbridgehdlr_fshandler_clock_getres = (&__actvbridgehdlr_fshandler_clock_getres)
	},
	[__fs_method_clock_adjtime] = {
		.p__actvbridgehdlr_fshandler_clock_adjtime = (&__actvbridgehdlr_fshandler_clock_adjtime)
	},
	[__fs_method_inotify_rsvd_9] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_8] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_init1] = {
		.p__actvbridgehdlr_fshandler_inotify_init1 = (&__actvbridgehdlr_fshandler_inotify_init1)
	},
	[__fs_method_inotify_add_watch] = {
		.p__actvbridgehdlr_fshandler_inotify_add_watch = (&__actvbridgehdlr_fshandler_inotify_add_watch)
	},
	[__fs_method_inotify_rm_watch] = {
		.p__actvbridgehdlr_fshandler_inotify_rm_watch = (&__actvbridgehdlr_fshandler_inotify_rm_watch)
	},
	[__fs_method_inotify_add_watch_internal] = {
		.p__actvbridgehdlr_fshandler_inotify_add_watch_internal = (&__actvbridgehdlr_fshandler_inotify_add_watch_internal)
	},
	[__fs_method_inotify_rm_watch_internal] = {
		.p__actvbridgehdlr_fshandler_inotify_rm_watch_internal = (&__actvbridgehdlr_fshandler_inotify_rm_watch_internal)
	},
	[__fs_method_inotify_notify] = {
		.p__actvbridgehdlr_fshandler_inotify_notify = (&__actvbridgehdlr_fshandler_inotify_notify)
	},
	[__fs_method_inotify_inode_destroyed] = {
		.p__actvbridgehdlr_fshandler_inotify_inode_destroyed = (&__actvbridgehdlr_fshandler_inotify_inode_destroyed)
	},
	[__fs_method_fanotify_rsvd_9] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_8] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_init] = {
		.p__actvbridgehdlr_fshandler_fanotify_init = (&__actvbridgehdlr_fshandler_fanotify_init)
	},
	[__fs_method_fanotify_mark] = {
		.p__actvbridgehdlr_fshandler_fanotify_mark = (&__actvbridgehdlr_fshandler_fanotify_mark)
	},
	[__fs_method_fanotify_mark_internal] = {
		.p__actvbridgehdlr_fshandler_fanotify_mark_internal = (&__actvbridgehdlr_fshandler_fanotify_mark_internal)
	},
	[__fs_method_fanotify_rm_watch_internal] = {
		.p__actvbridgehdlr_fshandler_fanotify_rm_watch_internal = (&__actvbridgehdlr_fshandler_fanotify_rm_watch_internal)
	},
	[__fs_method_fanotify_notify] = {
		.p__actvbridgehdlr_fshandler_fanotify_notify = (&__actvbridgehdlr_fshandler_fanotify_notify)
	},
	[__fs_method_fanotify_destroyed] = {
		.p__actvbridgehdlr_fshandler_fanotify_destroyed = (&__actvbridgehdlr_fshandler_fanotify_destroyed)
	},
	[__fs_method_fanotify_open] = {
		.p__actvbridgehdlr_fshandler_fanotify_open = (&__actvbridgehdlr_fshandler_fanotify_open)
	},
	[__fs_method_endio_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_io_done] = {
		.p__actvbridgehdlr_fshandler_endio_io_done = (&__actvbridgehdlr_fshandler_endio_io_done)
	},
	[__fs_method_sec_rsvd_8] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_set_label] = {
		.p__actvbridgehdlr_fshandler_vfs_set_label = (&__actvbridgehdlr_fshandler_vfs_set_label)
	},
	[__fs_method_vfs_set_label_by_path] = {
		.p__actvbridgehdlr_fshandler_vfs_set_label_by_path = (&__actvbridgehdlr_fshandler_vfs_set_label_by_path)
	},
	[__fs_method_vfs_get_label] = {
		.p__actvbridgehdlr_fshandler_vfs_get_label = (&__actvbridgehdlr_fshandler_vfs_get_label)
	},
	[__fs_method_vfs_init_audit] = {
		.p__actvbridgehdlr_fshandler_vfs_init_audit = (&__actvbridgehdlr_fshandler_vfs_init_audit)
	},
	[__fs_method_vfs_add_audit_rule] = {
		.p__actvbridgehdlr_fshandler_vfs_add_audit_rule = (&__actvbridgehdlr_fshandler_vfs_add_audit_rule)
	},
	[__fs_method_vfs_del_audit_rule] = {
		.p__actvbridgehdlr_fshandler_vfs_del_audit_rule = (&__actvbridgehdlr_fshandler_vfs_del_audit_rule)
	},
	[__fs_method_vfs_match_audit_watch_file] = {
		.p__actvbridgehdlr_fshandler_vfs_match_audit_watch_file = (&__actvbridgehdlr_fshandler_vfs_match_audit_watch_file)
	},
	[__fs_method_vfs_match_audit_watch_dir] = {
		.p__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir = (&__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir)
	},
	[__fs_method_vfs_rsvd_121] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_120] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_119] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_118] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_117] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_116] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_115] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_114] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_113] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_112] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_111] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_110] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_109] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_108] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_107] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_106] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_105] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_104] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_103] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_102] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_101] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_100] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_99] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_98] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_97] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_96] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_95] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_94] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_93] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_92] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_91] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_90] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_89] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_88] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_87] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_86] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_85] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_84] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_83] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_82] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_81] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_80] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_79] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_78] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_77] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_76] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_75] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_74] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_73] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_72] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_71] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_70] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_69] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_68] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_67] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_66] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_65] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_64] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_63] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_62] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_61] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_60] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_59] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_58] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_57] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_56] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_55] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_54] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_53] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_52] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_51] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_50] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_49] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_48] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_47] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_46] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_45] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_44] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_43] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_42] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_41] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_40] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_39] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_38] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_37] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_36] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_35] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_34] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_33] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_32] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_31] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_30] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_29] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_28] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_27] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_26] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_25] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_24] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_23] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_22] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_21] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_20] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_19] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_18] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_17] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_16] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_15] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_14] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_13] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_12] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_11] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_10] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_9] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_8] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_client_init] = {
		.p__actvbridgehdlr_fshandler_vfs_client_init = (&__actvbridgehdlr_fshandler_vfs_client_init)
	},
	[__fs_method_vfs_bind_update] = {
		.p__actvbridgehdlr_fshandler_vfs_bind_update = (&__actvbridgehdlr_fshandler_vfs_bind_update)
	},
	[__fs_method_vfs_clone] = {
		.p__actvbridgehdlr_fshandler_vfs_clone = (&__actvbridgehdlr_fshandler_vfs_clone)
	},
	[__fs_method_vfs_close] = {
		.p__actvbridgehdlr_fshandler_vfs_close = (&__actvbridgehdlr_fshandler_vfs_close)
	},
	[__fs_method_vfs_mount] = {
		.p__actvbridgehdlr_fshandler_vfs_mount = (&__actvbridgehdlr_fshandler_vfs_mount)
	},
	[__fs_method_vfs_clone_mount_entry] = {
		.p__actvbridgehdlr_fshandler_vfs_clone_mount_entry = (&__actvbridgehdlr_fshandler_vfs_clone_mount_entry)
	},
	[__fs_method_vfs_clone_mount_entry_from_orig_parent] = {
		.p__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent = (&__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent] = {
		.p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent = (&__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry] = {
		.p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry = (&__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry)
	},
	[__fs_method_vfs_check_mount] = {
		.p__actvbridgehdlr_fshandler_vfs_check_mount = (&__actvbridgehdlr_fshandler_vfs_check_mount)
	},
	[__fs_method_vfs_mountpoint_del_mount] = {
		.p__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount = (&__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount)
	},
	[__fs_method_vfs_open] = {
		.p__actvbridgehdlr_fshandler_vfs_open = (&__actvbridgehdlr_fshandler_vfs_open)
	},
	[__fs_method_vfs_ftruncate] = {
		.p__actvbridgehdlr_fshandler_vfs_ftruncate = (&__actvbridgehdlr_fshandler_vfs_ftruncate)
	},
	[__fs_method_vfs_fstat] = {
		.p__actvbridgehdlr_fshandler_vfs_fstat = (&__actvbridgehdlr_fshandler_vfs_fstat)
	},
	[__fs_method_vfs_stat] = {
		.p__actvbridgehdlr_fshandler_vfs_stat = (&__actvbridgehdlr_fshandler_vfs_stat)
	},
	[__fs_method_vfs_statfs] = {
		.p__actvbridgehdlr_fshandler_vfs_statfs = (&__actvbridgehdlr_fshandler_vfs_statfs)
	},
	[__fs_method_vfs_fstatfs] = {
		.p__actvbridgehdlr_fshandler_vfs_fstatfs = (&__actvbridgehdlr_fshandler_vfs_fstatfs)
	},
	[__fs_method_vfs_fsync] = {
		.p__actvbridgehdlr_fshandler_vfs_fsync = (&__actvbridgehdlr_fshandler_vfs_fsync)
	},
	[__fs_method_vfs_unmount] = {
		.p__actvbridgehdlr_fshandler_vfs_unmount = (&__actvbridgehdlr_fshandler_vfs_unmount)
	},
	[__fs_method_vfs_unmount_from_server] = {
		.p__actvbridgehdlr_fshandler_vfs_unmount_from_server = (&__actvbridgehdlr_fshandler_vfs_unmount_from_server)
	},
	[__fs_method_vfs_unmount_child] = {
		.p__actvbridgehdlr_fshandler_vfs_unmount_child = (&__actvbridgehdlr_fshandler_vfs_unmount_child)
	},
	[__fs_method_vfs_truncate] = {
		.p__actvbridgehdlr_fshandler_vfs_truncate = (&__actvbridgehdlr_fshandler_vfs_truncate)
	},
	[__fs_method_vfs_fs_fork] = {
		.p__actvbridgehdlr_fshandler_vfs_fs_fork = (&__actvbridgehdlr_fshandler_vfs_fs_fork)
	},
	[__fs_method_vfs_query_info] = {
		.p__actvbridgehdlr_fshandler_vfs_query_info = (&__actvbridgehdlr_fshandler_vfs_query_info)
	},
	[__fs_method_vfs_lseek] = {
		.p__actvbridgehdlr_fshandler_vfs_lseek = (&__actvbridgehdlr_fshandler_vfs_lseek)
	},
	[__fs_method_vfs_trans] = {
		.p__actvbridgehdlr_fshandler_vfs_trans = (&__actvbridgehdlr_fshandler_vfs_trans)
	},
	[__fs_method_vfs_pipe2] = {
		.p__actvbridgehdlr_fshandler_vfs_pipe2 = (&__actvbridgehdlr_fshandler_vfs_pipe2)
	},
	[__fs_method_vfs_tee] = {
		.p__actvbridgehdlr_fshandler_vfs_tee = (&__actvbridgehdlr_fshandler_vfs_tee)
	},
	[__fs_method_vfs_splice] = {
		.p__actvbridgehdlr_fshandler_vfs_splice = (&__actvbridgehdlr_fshandler_vfs_splice)
	},
	[__fs_method_vfs_do_splice_srvs] = {
		.p__actvbridgehdlr_fshandler_vfs_do_splice_srvs = (&__actvbridgehdlr_fshandler_vfs_do_splice_srvs)
	},
	[__fs_method_vfs_revoke_process] = {
		.p__actvbridgehdlr_fshandler_vfs_revoke_process = (&__actvbridgehdlr_fshandler_vfs_revoke_process)
	},
	[__fs_method_vfs_setrlimit] = {
		.p__actvbridgehdlr_fshandler_vfs_setrlimit = (&__actvbridgehdlr_fshandler_vfs_setrlimit)
	},
	[__fs_method_vfs_get_ns] = {
		.p__actvbridgehdlr_fshandler_vfs_get_ns = (&__actvbridgehdlr_fshandler_vfs_get_ns)
	},
	[__fs_method_vfs_put_ns] = {
		.p__actvbridgehdlr_fshandler_vfs_put_ns = (&__actvbridgehdlr_fshandler_vfs_put_ns)
	},
	[__fs_method_vfs_init_eventfd] = {
		.p__actvbridgehdlr_fshandler_vfs_init_eventfd = (&__actvbridgehdlr_fshandler_vfs_init_eventfd)
	},
	[__fs_method_vfs_write_eventfd] = {
		.p__actvbridgehdlr_fshandler_vfs_write_eventfd = (&__actvbridgehdlr_fshandler_vfs_write_eventfd)
	},
	[__fs_method_vfs_timerfd_create] = {
		.p__actvbridgehdlr_fshandler_vfs_timerfd_create = (&__actvbridgehdlr_fshandler_vfs_timerfd_create)
	},
	[__fs_method_vfs_timerfd_settime] = {
		.p__actvbridgehdlr_fshandler_vfs_timerfd_settime = (&__actvbridgehdlr_fshandler_vfs_timerfd_settime)
	},
	[__fs_method_vfs_timerfd_gettime] = {
		.p__actvbridgehdlr_fshandler_vfs_timerfd_gettime = (&__actvbridgehdlr_fshandler_vfs_timerfd_gettime)
	},
	[__fs_method_vfs_open_exec] = {
		.p__actvbridgehdlr_fshandler_vfs_open_exec = (&__actvbridgehdlr_fshandler_vfs_open_exec)
	},
	[__fs_method_vfs_close_exec] = {
		.p__actvbridgehdlr_fshandler_vfs_close_exec = (&__actvbridgehdlr_fshandler_vfs_close_exec)
	},
	[__fs_method_vfs_set_elf_file] = {
		.p__actvbridgehdlr_fshandler_vfs_set_elf_file = (&__actvbridgehdlr_fshandler_vfs_set_elf_file)
	},
	[__fs_method_vfs_ioctl] = {
		.p__actvbridgehdlr_fshandler_vfs_ioctl = (&__actvbridgehdlr_fshandler_vfs_ioctl)
	},
	[__fs_method_vfs_read] = {
		.p__actvbridgehdlr_fshandler_vfs_read = (&__actvbridgehdlr_fshandler_vfs_read)
	},
	[__fs_method_vfs_readv] = {
		.p__actvbridgehdlr_fshandler_vfs_readv = (&__actvbridgehdlr_fshandler_vfs_readv)
	},
	[__fs_method_vfs_getcwd] = {
		.p__actvbridgehdlr_fshandler_vfs_getcwd = (&__actvbridgehdlr_fshandler_vfs_getcwd)
	},
	[__fs_method_vfs_get_process_cwdrootexe] = {
		.p__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe = (&__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe)
	},
	[__fs_method_vfs_readdir] = {
		.p__actvbridgehdlr_fshandler_vfs_readdir = (&__actvbridgehdlr_fshandler_vfs_readdir)
	},
	[__fs_method_vfs_write] = {
		.p__actvbridgehdlr_fshandler_vfs_write = (&__actvbridgehdlr_fshandler_vfs_write)
	},
	[__fs_method_vfs_writev] = {
		.p__actvbridgehdlr_fshandler_vfs_writev = (&__actvbridgehdlr_fshandler_vfs_writev)
	},
	[__fs_method_vfs_sync] = {
		.p__actvbridgehdlr_fshandler_vfs_sync = (&__actvbridgehdlr_fshandler_vfs_sync)
	},
	[__fs_method_vfs_do_sync] = {
		.p__actvbridgehdlr_fshandler_vfs_do_sync = (&__actvbridgehdlr_fshandler_vfs_do_sync)
	},
	[__fs_method_vfs_utimensat] = {
		.p__actvbridgehdlr_fshandler_vfs_utimensat = (&__actvbridgehdlr_fshandler_vfs_utimensat)
	},
	[__fs_method_vfs_futimens] = {
		.p__actvbridgehdlr_fshandler_vfs_futimens = (&__actvbridgehdlr_fshandler_vfs_futimens)
	},
	[__fs_method_vfs_fchmodat] = {
		.p__actvbridgehdlr_fshandler_vfs_fchmodat = (&__actvbridgehdlr_fshandler_vfs_fchmodat)
	},
	[__fs_method_vfs_fchmod] = {
		.p__actvbridgehdlr_fshandler_vfs_fchmod = (&__actvbridgehdlr_fshandler_vfs_fchmod)
	},
	[__fs_method_vfs_drop_caches] = {
		.p__actvbridgehdlr_fshandler_vfs_drop_caches = (&__actvbridgehdlr_fshandler_vfs_drop_caches)
	},
	[__fs_method_vfs_do_drop_caches] = {
		.p__actvbridgehdlr_fshandler_vfs_do_drop_caches = (&__actvbridgehdlr_fshandler_vfs_do_drop_caches)
	},
	[__fs_method_vfs_fadvise] = {
		.p__actvbridgehdlr_fshandler_vfs_fadvise = (&__actvbridgehdlr_fshandler_vfs_fadvise)
	},
	[__fs_method_vfs_readahead] = {
		.p__actvbridgehdlr_fshandler_vfs_readahead = (&__actvbridgehdlr_fshandler_vfs_readahead)
	},
	[__fs_method_vfs_get_fd_path] = {
		.p__actvbridgehdlr_fshandler_vfs_get_fd_path = (&__actvbridgehdlr_fshandler_vfs_get_fd_path)
	},
	[__fs_method_vfs_sysmgr_get_fd_path] = {
		.p__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path = (&__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path)
	},
	[__fs_method_vfs_fcntl] = {
		.p__actvbridgehdlr_fshandler_vfs_fcntl = (&__actvbridgehdlr_fshandler_vfs_fcntl)
	},
	[__fs_method_vfs_device_mounted] = {
		.p__actvbridgehdlr_fshandler_vfs_device_mounted = (&__actvbridgehdlr_fshandler_vfs_device_mounted)
	},
	[__fs_method_vfs_quotactl] = {
		.p__actvbridgehdlr_fshandler_vfs_quotactl = (&__actvbridgehdlr_fshandler_vfs_quotactl)
	},
	[__fs_method_vfs_copy_file_range] = {
		.p__actvbridgehdlr_fshandler_vfs_copy_file_range = (&__actvbridgehdlr_fshandler_vfs_copy_file_range)
	},
	[__fs_method_vfs_same_file] = {
		.p__actvbridgehdlr_fshandler_vfs_same_file = (&__actvbridgehdlr_fshandler_vfs_same_file)
	},
	[__fs_method_vfs_access] = {
		.p__actvbridgehdlr_fshandler_vfs_access = (&__actvbridgehdlr_fshandler_vfs_access)
	},
	[__fs_method_vfs_flock] = {
		.p__actvbridgehdlr_fshandler_vfs_flock = (&__actvbridgehdlr_fshandler_vfs_flock)
	},
	[__fs_method_vfs_fchownat] = {
		.p__actvbridgehdlr_fshandler_vfs_fchownat = (&__actvbridgehdlr_fshandler_vfs_fchownat)
	},
	[__fs_method_vfs_fchown] = {
		.p__actvbridgehdlr_fshandler_vfs_fchown = (&__actvbridgehdlr_fshandler_vfs_fchown)
	},
	[__fs_method_vfs_binderfs_mmap] = {
		.p__actvbridgehdlr_fshandler_vfs_binderfs_mmap = (&__actvbridgehdlr_fshandler_vfs_binderfs_mmap)
	},
	[__fs_method_vfs_init_signalfd] = {
		.p__actvbridgehdlr_fshandler_vfs_init_signalfd = (&__actvbridgehdlr_fshandler_vfs_init_signalfd)
	},
	[__fs_method_vfs_epoll_ctl] = {
		.p__actvbridgehdlr_fshandler_vfs_epoll_ctl = (&__actvbridgehdlr_fshandler_vfs_epoll_ctl)
	},
	[__fs_method_vfs_epoll_et_revents] = {
		.p__actvbridgehdlr_fshandler_vfs_epoll_et_revents = (&__actvbridgehdlr_fshandler_vfs_epoll_et_revents)
	},
	[__fs_method_vfs_epoll_reinit] = {
		.p__actvbridgehdlr_fshandler_vfs_epoll_reinit = (&__actvbridgehdlr_fshandler_vfs_epoll_reinit)
	},
	[__fs_method_vfs_signalfd_notify] = {
		.p__actvbridgehdlr_fshandler_vfs_signalfd_notify = (&__actvbridgehdlr_fshandler_vfs_signalfd_notify)
	},
	[__fs_method_vfs_pid_io_stats] = {
		.p__actvbridgehdlr_fshandler_vfs_pid_io_stats = (&__actvbridgehdlr_fshandler_vfs_pid_io_stats)
	},
	[__fs_method_vfs_fallocate] = {
		.p__actvbridgehdlr_fshandler_vfs_fallocate = (&__actvbridgehdlr_fshandler_vfs_fallocate)
	},
	[__fs_method_vfs_set_cwdroot] = {
		.p__actvbridgehdlr_fshandler_vfs_set_cwdroot = (&__actvbridgehdlr_fshandler_vfs_set_cwdroot)
	},
	[__fs_method_vfs_fchdir] = {
		.p__actvbridgehdlr_fshandler_vfs_fchdir = (&__actvbridgehdlr_fshandler_vfs_fchdir)
	},
	[__fs_method_vfs_disable_cwdroot] = {
		.p__actvbridgehdlr_fshandler_vfs_disable_cwdroot = (&__actvbridgehdlr_fshandler_vfs_disable_cwdroot)
	},
	[__fs_method_vfs_update_cwdroot] = {
		.p__actvbridgehdlr_fshandler_vfs_update_cwdroot = (&__actvbridgehdlr_fshandler_vfs_update_cwdroot)
	},
	[__fs_method_vfs_handle_global_locks] = {
		.p__actvbridgehdlr_fshandler_vfs_handle_global_locks = (&__actvbridgehdlr_fshandler_vfs_handle_global_locks)
	},
	[__fs_method_vfs_send_fd] = {
		.p__actvbridgehdlr_fshandler_vfs_send_fd = (&__actvbridgehdlr_fshandler_vfs_send_fd)
	},
	[__fs_method_vfs_recv_fd] = {
		.p__actvbridgehdlr_fshandler_vfs_recv_fd = (&__actvbridgehdlr_fshandler_vfs_recv_fd)
	},
	[__fs_method_vfs_get_buffer_wrapper] = {
		.p__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper = (&__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper)
	},
	[__fs_method_vfs_get_pathname_by_me_idx] = {
		.p__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx = (&__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx)
	},
	[__fs_method_vfs_sfile_put] = {
		.p__actvbridgehdlr_fshandler_vfs_sfile_put = (&__actvbridgehdlr_fshandler_vfs_sfile_put)
	},
	[__fs_method_vfs_readlinkat] = {
		.p__actvbridgehdlr_fshandler_vfs_readlinkat = (&__actvbridgehdlr_fshandler_vfs_readlinkat)
	},
	[__fs_method_vfs_get_slabinfo] = {
		.p__actvbridgehdlr_fshandler_vfs_get_slabinfo = (&__actvbridgehdlr_fshandler_vfs_get_slabinfo)
	},
	[__fs_method_vfs_do_get_slabinfo] = {
		.p__actvbridgehdlr_fshandler_vfs_do_get_slabinfo = (&__actvbridgehdlr_fshandler_vfs_do_get_slabinfo)
	},
	[__fs_method_vfs_fscache_print_info] = {
		.p__actvbridgehdlr_fshandler_vfs_fscache_print_info = (&__actvbridgehdlr_fshandler_vfs_fscache_print_info)
	},
	[__fs_method_vfs_alloc_fs_handle_for_same_device] = {
		.p__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device = (&__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device)
	},
	[__fs_method_vfs_free_fs_handle_for_same_device] = {
		.p__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device = (&__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device)
	},
	[__fs_method_vfs_memfd_create] = {
		.p__actvbridgehdlr_fshandler_vfs_memfd_create = (&__actvbridgehdlr_fshandler_vfs_memfd_create)
	},
	[__fs_method_vfs_mknod] = {
		.p__actvbridgehdlr_fshandler_vfs_mknod = (&__actvbridgehdlr_fshandler_vfs_mknod)
	},
	[__fs_method_vfs_rename] = {
		.p__actvbridgehdlr_fshandler_vfs_rename = (&__actvbridgehdlr_fshandler_vfs_rename)
	},
	[__fs_method_vfs_mkdirat] = {
		.p__actvbridgehdlr_fshandler_vfs_mkdirat = (&__actvbridgehdlr_fshandler_vfs_mkdirat)
	},
	[__fs_method_vfs_link] = {
		.p__actvbridgehdlr_fshandler_vfs_link = (&__actvbridgehdlr_fshandler_vfs_link)
	},
	[__fs_method_vfs_unlink] = {
		.p__actvbridgehdlr_fshandler_vfs_unlink = (&__actvbridgehdlr_fshandler_vfs_unlink)
	},
	[__fs_method_vfs_symlink] = {
		.p__actvbridgehdlr_fshandler_vfs_symlink = (&__actvbridgehdlr_fshandler_vfs_symlink)
	},
	[__fs_method_vfs_getxattr] = {
		.p__actvbridgehdlr_fshandler_vfs_getxattr = (&__actvbridgehdlr_fshandler_vfs_getxattr)
	},
	[__fs_method_vfs_fgetxattr] = {
		.p__actvbridgehdlr_fshandler_vfs_fgetxattr = (&__actvbridgehdlr_fshandler_vfs_fgetxattr)
	},
	[__fs_method_vfs_setxattr] = {
		.p__actvbridgehdlr_fshandler_vfs_setxattr = (&__actvbridgehdlr_fshandler_vfs_setxattr)
	},
	[__fs_method_vfs_fsetxattr] = {
		.p__actvbridgehdlr_fshandler_vfs_fsetxattr = (&__actvbridgehdlr_fshandler_vfs_fsetxattr)
	},
	[__fs_method_vfs_listxattr] = {
		.p__actvbridgehdlr_fshandler_vfs_listxattr = (&__actvbridgehdlr_fshandler_vfs_listxattr)
	},
	[__fs_method_vfs_flistxattr] = {
		.p__actvbridgehdlr_fshandler_vfs_flistxattr = (&__actvbridgehdlr_fshandler_vfs_flistxattr)
	},
	[__fs_method_vfs_removexattr] = {
		.p__actvbridgehdlr_fshandler_vfs_removexattr = (&__actvbridgehdlr_fshandler_vfs_removexattr)
	},
	[__fs_method_vfs_fremovexattr] = {
		.p__actvbridgehdlr_fshandler_vfs_fremovexattr = (&__actvbridgehdlr_fshandler_vfs_fremovexattr)
	},
	[__fs_method_vfs_iommap] = {
		.p__actvbridgehdlr_fshandler_vfs_iommap = (&__actvbridgehdlr_fshandler_vfs_iommap)
	},
	[__fs_method_vfs_mmap_create] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_create = (&__actvbridgehdlr_fshandler_vfs_mmap_create)
	},
	[__fs_method_vfs_mmap_release_file] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_release_file = (&__actvbridgehdlr_fshandler_vfs_mmap_release_file)
	},
	[__fs_method_vfs_mmap_change] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_change = (&__actvbridgehdlr_fshandler_vfs_mmap_change)
	},
	[__fs_method_vfs_mmap_fill_page] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_fill_page = (&__actvbridgehdlr_fshandler_vfs_mmap_fill_page)
	},
	[__fs_method_vfs_mmap_fetch_page] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_fetch_page = (&__actvbridgehdlr_fshandler_vfs_mmap_fetch_page)
	},
	[__fs_method_vfs_mmap_change_page] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_change_page = (&__actvbridgehdlr_fshandler_vfs_mmap_change_page)
	},
	[__fs_method_vfs_mmap_fallocate] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_fallocate = (&__actvbridgehdlr_fshandler_vfs_mmap_fallocate)
	},
	[__fs_method_vfs_gfd_table_update] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_update = (&__actvbridgehdlr_fshandler_vfs_gfd_table_update)
	},
	[__fs_method_vfs_gfd_table_remove] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_remove = (&__actvbridgehdlr_fshandler_vfs_gfd_table_remove)
	},
	[__fs_method_vfs_gfd_table_expand] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_expand = (&__actvbridgehdlr_fshandler_vfs_gfd_table_expand)
	},
	[__fs_method_vfs_gfd_table_acquire] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_acquire = (&__actvbridgehdlr_fshandler_vfs_gfd_table_acquire)
	},
	[__fs_method_vfs_gfd_table_release] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_release = (&__actvbridgehdlr_fshandler_vfs_gfd_table_release)
	},
	[__fs_method_vfs_gfd_table_replace] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_replace = (&__actvbridgehdlr_fshandler_vfs_gfd_table_replace)
	},
	[__fs_method_vfs_gfd_table_fault] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_fault = (&__actvbridgehdlr_fshandler_vfs_gfd_table_fault)
	},
	[__fs_method_vfs_anon_register_devhost] = {
		.p__actvbridgehdlr_fshandler_vfs_anon_register_devhost = (&__actvbridgehdlr_fshandler_vfs_anon_register_devhost)
	},
	[__fs_method_vfs_get_unused_fd] = {
		.p__actvbridgehdlr_fshandler_vfs_get_unused_fd = (&__actvbridgehdlr_fshandler_vfs_get_unused_fd)
	},
	[__fs_method_vfs_put_unused_fd] = {
		.p__actvbridgehdlr_fshandler_vfs_put_unused_fd = (&__actvbridgehdlr_fshandler_vfs_put_unused_fd)
	},
	[__fs_method_vfs_fd_info_update] = {
		.p__actvbridgehdlr_fshandler_vfs_fd_info_update = (&__actvbridgehdlr_fshandler_vfs_fd_info_update)
	},
	[__fs_method_vfs_get_root_path] = {
		.p__actvbridgehdlr_fshandler_vfs_get_root_path = (&__actvbridgehdlr_fshandler_vfs_get_root_path)
	},
	[__fs_method_vfs_transfs_fget] = {
		.p__actvbridgehdlr_fshandler_vfs_transfs_fget = (&__actvbridgehdlr_fshandler_vfs_transfs_fget)
	},
	[__fs_method_vfs_do_trans_fget] = {
		.p__actvbridgehdlr_fshandler_vfs_do_trans_fget = (&__actvbridgehdlr_fshandler_vfs_do_trans_fget)
	},
	[__fs_method_vfs_transfs_fput] = {
		.p__actvbridgehdlr_fshandler_vfs_transfs_fput = (&__actvbridgehdlr_fshandler_vfs_transfs_fput)
	},
	[__fs_method_vfs_do_trans_fput] = {
		.p__actvbridgehdlr_fshandler_vfs_do_trans_fput = (&__actvbridgehdlr_fshandler_vfs_do_trans_fput)
	},
	[__fs_method_vfs_read_mounts] = {
		.p__actvbridgehdlr_fshandler_vfs_read_mounts = (&__actvbridgehdlr_fshandler_vfs_read_mounts)
	}
};

union fs_hdlrs_union sysif_fs_actvcapcallhdlr_table[__fs_method_MAX] = {
	[0 ... __ACTV_UPCALL_POOL_GRANT_CHANGE - 1U] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_default_handler)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE] = {
		.p_sysif_handle_kcall_entry = (&sysif_actv_pool_handle_grant_change)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE + 1U ... __fs_method_MIN] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_default_handler)
	},
	[__fs_method_procfs_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_create_data] = {
		.p__actvbridgecapcallhdlr_fshandler_procfs_create_data = (&__actvbridgecapcallhdlr_fshandler_procfs_create_data)
	},
	[__fs_method_procfs_delete_data] = {
		.p__actvbridgecapcallhdlr_fshandler_procfs_delete_data = (&__actvbridgecapcallhdlr_fshandler_procfs_delete_data)
	},
	[__fs_method_procfs_get_process_fds] = {
		.p__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds = (&__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds)
	},
	[__fs_method_procfs_get_fd_mode] = {
		.p__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode = (&__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode)
	},
	[__fs_method_sysfs_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_create_file] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_create_file = (&__actvbridgecapcallhdlr_fshandler_sysfs_create_file)
	},
	[__fs_method_sysfs_create_dir] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_create_dir = (&__actvbridgecapcallhdlr_fshandler_sysfs_create_dir)
	},
	[__fs_method_sysfs_create_symlink] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink = (&__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink)
	},
	[__fs_method_sysfs_delete] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_delete = (&__actvbridgecapcallhdlr_fshandler_sysfs_delete)
	},
	[__fs_method_sysfs_notify] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_notify = (&__actvbridgecapcallhdlr_fshandler_sysfs_notify)
	},
	[__fs_method_clock_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_settime] = {
		.p__actvbridgecapcallhdlr_fshandler_clock_settime = (&__actvbridgecapcallhdlr_fshandler_clock_settime)
	},
	[__fs_method_clock_gettime] = {
		.p__actvbridgecapcallhdlr_fshandler_clock_gettime = (&__actvbridgecapcallhdlr_fshandler_clock_gettime)
	},
	[__fs_method_clock_getres] = {
		.p__actvbridgecapcallhdlr_fshandler_clock_getres = (&__actvbridgecapcallhdlr_fshandler_clock_getres)
	},
	[__fs_method_clock_adjtime] = {
		.p__actvbridgecapcallhdlr_fshandler_clock_adjtime = (&__actvbridgecapcallhdlr_fshandler_clock_adjtime)
	},
	[__fs_method_inotify_rsvd_9] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_8] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_init1] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_init1 = (&__actvbridgecapcallhdlr_fshandler_inotify_init1)
	},
	[__fs_method_inotify_add_watch] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_add_watch = (&__actvbridgecapcallhdlr_fshandler_inotify_add_watch)
	},
	[__fs_method_inotify_rm_watch] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch = (&__actvbridgecapcallhdlr_fshandler_inotify_rm_watch)
	},
	[__fs_method_inotify_add_watch_internal] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal = (&__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal)
	},
	[__fs_method_inotify_rm_watch_internal] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal = (&__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal)
	},
	[__fs_method_inotify_notify] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_notify = (&__actvbridgecapcallhdlr_fshandler_inotify_notify)
	},
	[__fs_method_inotify_inode_destroyed] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed = (&__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed)
	},
	[__fs_method_fanotify_rsvd_9] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_8] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_init] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_init = (&__actvbridgecapcallhdlr_fshandler_fanotify_init)
	},
	[__fs_method_fanotify_mark] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_mark = (&__actvbridgecapcallhdlr_fshandler_fanotify_mark)
	},
	[__fs_method_fanotify_mark_internal] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal = (&__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal)
	},
	[__fs_method_fanotify_rm_watch_internal] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal = (&__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal)
	},
	[__fs_method_fanotify_notify] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_notify = (&__actvbridgecapcallhdlr_fshandler_fanotify_notify)
	},
	[__fs_method_fanotify_destroyed] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_destroyed = (&__actvbridgecapcallhdlr_fshandler_fanotify_destroyed)
	},
	[__fs_method_fanotify_open] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_open = (&__actvbridgecapcallhdlr_fshandler_fanotify_open)
	},
	[__fs_method_endio_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_io_done] = {
		.p__actvbridgecapcallhdlr_fshandler_endio_io_done = (&__actvbridgecapcallhdlr_fshandler_endio_io_done)
	},
	[__fs_method_sec_rsvd_8] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_set_label] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_set_label = (&__actvbridgecapcallhdlr_fshandler_vfs_set_label)
	},
	[__fs_method_vfs_set_label_by_path] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path = (&__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path)
	},
	[__fs_method_vfs_get_label] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_label = (&__actvbridgecapcallhdlr_fshandler_vfs_get_label)
	},
	[__fs_method_vfs_init_audit] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_init_audit = (&__actvbridgecapcallhdlr_fshandler_vfs_init_audit)
	},
	[__fs_method_vfs_add_audit_rule] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule = (&__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule)
	},
	[__fs_method_vfs_del_audit_rule] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule = (&__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule)
	},
	[__fs_method_vfs_match_audit_watch_file] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file = (&__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file)
	},
	[__fs_method_vfs_match_audit_watch_dir] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir = (&__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir)
	},
	[__fs_method_vfs_rsvd_121] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_120] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_119] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_118] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_117] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_116] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_115] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_114] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_113] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_112] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_111] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_110] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_109] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_108] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_107] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_106] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_105] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_104] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_103] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_102] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_101] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_100] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_99] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_98] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_97] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_96] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_95] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_94] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_93] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_92] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_91] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_90] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_89] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_88] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_87] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_86] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_85] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_84] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_83] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_82] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_81] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_80] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_79] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_78] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_77] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_76] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_75] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_74] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_73] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_72] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_71] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_70] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_69] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_68] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_67] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_66] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_65] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_64] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_63] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_62] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_61] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_60] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_59] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_58] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_57] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_56] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_55] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_54] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_53] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_52] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_51] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_50] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_49] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_48] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_47] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_46] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_45] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_44] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_43] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_42] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_41] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_40] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_39] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_38] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_37] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_36] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_35] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_34] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_33] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_32] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_31] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_30] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_29] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_28] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_27] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_26] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_25] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_24] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_23] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_22] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_21] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_20] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_19] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_18] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_17] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_16] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_15] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_14] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_13] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_12] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_11] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_10] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_9] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_8] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_7] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_6] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_5] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_4] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_3] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_client_init] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_client_init = (&__actvbridgecapcallhdlr_fshandler_vfs_client_init)
	},
	[__fs_method_vfs_bind_update] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_bind_update = (&__actvbridgecapcallhdlr_fshandler_vfs_bind_update)
	},
	[__fs_method_vfs_clone] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_clone = (&__actvbridgecapcallhdlr_fshandler_vfs_clone)
	},
	[__fs_method_vfs_close] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_close = (&__actvbridgecapcallhdlr_fshandler_vfs_close)
	},
	[__fs_method_vfs_mount] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mount = (&__actvbridgecapcallhdlr_fshandler_vfs_mount)
	},
	[__fs_method_vfs_clone_mount_entry] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry = (&__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry)
	},
	[__fs_method_vfs_clone_mount_entry_from_orig_parent] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent = (&__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent = (&__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry = (&__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry)
	},
	[__fs_method_vfs_check_mount] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_check_mount = (&__actvbridgecapcallhdlr_fshandler_vfs_check_mount)
	},
	[__fs_method_vfs_mountpoint_del_mount] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount = (&__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount)
	},
	[__fs_method_vfs_open] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_open = (&__actvbridgecapcallhdlr_fshandler_vfs_open)
	},
	[__fs_method_vfs_ftruncate] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_ftruncate = (&__actvbridgecapcallhdlr_fshandler_vfs_ftruncate)
	},
	[__fs_method_vfs_fstat] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fstat = (&__actvbridgecapcallhdlr_fshandler_vfs_fstat)
	},
	[__fs_method_vfs_stat] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_stat = (&__actvbridgecapcallhdlr_fshandler_vfs_stat)
	},
	[__fs_method_vfs_statfs] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_statfs = (&__actvbridgecapcallhdlr_fshandler_vfs_statfs)
	},
	[__fs_method_vfs_fstatfs] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fstatfs = (&__actvbridgecapcallhdlr_fshandler_vfs_fstatfs)
	},
	[__fs_method_vfs_fsync] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fsync = (&__actvbridgecapcallhdlr_fshandler_vfs_fsync)
	},
	[__fs_method_vfs_unmount] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_unmount = (&__actvbridgecapcallhdlr_fshandler_vfs_unmount)
	},
	[__fs_method_vfs_unmount_from_server] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server = (&__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server)
	},
	[__fs_method_vfs_unmount_child] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_unmount_child = (&__actvbridgecapcallhdlr_fshandler_vfs_unmount_child)
	},
	[__fs_method_vfs_truncate] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_truncate = (&__actvbridgecapcallhdlr_fshandler_vfs_truncate)
	},
	[__fs_method_vfs_fs_fork] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fs_fork = (&__actvbridgecapcallhdlr_fshandler_vfs_fs_fork)
	},
	[__fs_method_vfs_query_info] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_query_info = (&__actvbridgecapcallhdlr_fshandler_vfs_query_info)
	},
	[__fs_method_vfs_lseek] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_lseek = (&__actvbridgecapcallhdlr_fshandler_vfs_lseek)
	},
	[__fs_method_vfs_trans] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_trans = (&__actvbridgecapcallhdlr_fshandler_vfs_trans)
	},
	[__fs_method_vfs_pipe2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_pipe2 = (&__actvbridgecapcallhdlr_fshandler_vfs_pipe2)
	},
	[__fs_method_vfs_tee] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_tee = (&__actvbridgecapcallhdlr_fshandler_vfs_tee)
	},
	[__fs_method_vfs_splice] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_splice = (&__actvbridgecapcallhdlr_fshandler_vfs_splice)
	},
	[__fs_method_vfs_do_splice_srvs] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs = (&__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs)
	},
	[__fs_method_vfs_revoke_process] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_revoke_process = (&__actvbridgecapcallhdlr_fshandler_vfs_revoke_process)
	},
	[__fs_method_vfs_setrlimit] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_setrlimit = (&__actvbridgecapcallhdlr_fshandler_vfs_setrlimit)
	},
	[__fs_method_vfs_get_ns] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_ns = (&__actvbridgecapcallhdlr_fshandler_vfs_get_ns)
	},
	[__fs_method_vfs_put_ns] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_put_ns = (&__actvbridgecapcallhdlr_fshandler_vfs_put_ns)
	},
	[__fs_method_vfs_init_eventfd] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd = (&__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd)
	},
	[__fs_method_vfs_write_eventfd] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd = (&__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd)
	},
	[__fs_method_vfs_timerfd_create] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create = (&__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create)
	},
	[__fs_method_vfs_timerfd_settime] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime = (&__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime)
	},
	[__fs_method_vfs_timerfd_gettime] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime = (&__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime)
	},
	[__fs_method_vfs_open_exec] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_open_exec = (&__actvbridgecapcallhdlr_fshandler_vfs_open_exec)
	},
	[__fs_method_vfs_close_exec] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_close_exec = (&__actvbridgecapcallhdlr_fshandler_vfs_close_exec)
	},
	[__fs_method_vfs_set_elf_file] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file = (&__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file)
	},
	[__fs_method_vfs_ioctl] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_ioctl = (&__actvbridgecapcallhdlr_fshandler_vfs_ioctl)
	},
	[__fs_method_vfs_read] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_read = (&__actvbridgecapcallhdlr_fshandler_vfs_read)
	},
	[__fs_method_vfs_readv] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_readv = (&__actvbridgecapcallhdlr_fshandler_vfs_readv)
	},
	[__fs_method_vfs_getcwd] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_getcwd = (&__actvbridgecapcallhdlr_fshandler_vfs_getcwd)
	},
	[__fs_method_vfs_get_process_cwdrootexe] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe = (&__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe)
	},
	[__fs_method_vfs_readdir] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_readdir = (&__actvbridgecapcallhdlr_fshandler_vfs_readdir)
	},
	[__fs_method_vfs_write] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_write = (&__actvbridgecapcallhdlr_fshandler_vfs_write)
	},
	[__fs_method_vfs_writev] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_writev = (&__actvbridgecapcallhdlr_fshandler_vfs_writev)
	},
	[__fs_method_vfs_sync] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_sync = (&__actvbridgecapcallhdlr_fshandler_vfs_sync)
	},
	[__fs_method_vfs_do_sync] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_sync = (&__actvbridgecapcallhdlr_fshandler_vfs_do_sync)
	},
	[__fs_method_vfs_utimensat] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_utimensat = (&__actvbridgecapcallhdlr_fshandler_vfs_utimensat)
	},
	[__fs_method_vfs_futimens] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_futimens = (&__actvbridgecapcallhdlr_fshandler_vfs_futimens)
	},
	[__fs_method_vfs_fchmodat] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchmodat = (&__actvbridgecapcallhdlr_fshandler_vfs_fchmodat)
	},
	[__fs_method_vfs_fchmod] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchmod = (&__actvbridgecapcallhdlr_fshandler_vfs_fchmod)
	},
	[__fs_method_vfs_drop_caches] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_drop_caches = (&__actvbridgecapcallhdlr_fshandler_vfs_drop_caches)
	},
	[__fs_method_vfs_do_drop_caches] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches = (&__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches)
	},
	[__fs_method_vfs_fadvise] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fadvise = (&__actvbridgecapcallhdlr_fshandler_vfs_fadvise)
	},
	[__fs_method_vfs_readahead] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_readahead = (&__actvbridgecapcallhdlr_fshandler_vfs_readahead)
	},
	[__fs_method_vfs_get_fd_path] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path = (&__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path)
	},
	[__fs_method_vfs_sysmgr_get_fd_path] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path = (&__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path)
	},
	[__fs_method_vfs_fcntl] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fcntl = (&__actvbridgecapcallhdlr_fshandler_vfs_fcntl)
	},
	[__fs_method_vfs_device_mounted] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_device_mounted = (&__actvbridgecapcallhdlr_fshandler_vfs_device_mounted)
	},
	[__fs_method_vfs_quotactl] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_quotactl = (&__actvbridgecapcallhdlr_fshandler_vfs_quotactl)
	},
	[__fs_method_vfs_copy_file_range] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range = (&__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range)
	},
	[__fs_method_vfs_same_file] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_same_file = (&__actvbridgecapcallhdlr_fshandler_vfs_same_file)
	},
	[__fs_method_vfs_access] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_access = (&__actvbridgecapcallhdlr_fshandler_vfs_access)
	},
	[__fs_method_vfs_flock] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_flock = (&__actvbridgecapcallhdlr_fshandler_vfs_flock)
	},
	[__fs_method_vfs_fchownat] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchownat = (&__actvbridgecapcallhdlr_fshandler_vfs_fchownat)
	},
	[__fs_method_vfs_fchown] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchown = (&__actvbridgecapcallhdlr_fshandler_vfs_fchown)
	},
	[__fs_method_vfs_binderfs_mmap] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap = (&__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap)
	},
	[__fs_method_vfs_init_signalfd] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd = (&__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd)
	},
	[__fs_method_vfs_epoll_ctl] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl = (&__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl)
	},
	[__fs_method_vfs_epoll_et_revents] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents = (&__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents)
	},
	[__fs_method_vfs_epoll_reinit] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit = (&__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit)
	},
	[__fs_method_vfs_signalfd_notify] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify = (&__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify)
	},
	[__fs_method_vfs_pid_io_stats] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats = (&__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats)
	},
	[__fs_method_vfs_fallocate] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fallocate = (&__actvbridgecapcallhdlr_fshandler_vfs_fallocate)
	},
	[__fs_method_vfs_set_cwdroot] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot = (&__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot)
	},
	[__fs_method_vfs_fchdir] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchdir = (&__actvbridgecapcallhdlr_fshandler_vfs_fchdir)
	},
	[__fs_method_vfs_disable_cwdroot] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot = (&__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot)
	},
	[__fs_method_vfs_update_cwdroot] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot = (&__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot)
	},
	[__fs_method_vfs_handle_global_locks] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks = (&__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks)
	},
	[__fs_method_vfs_send_fd] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_send_fd = (&__actvbridgecapcallhdlr_fshandler_vfs_send_fd)
	},
	[__fs_method_vfs_recv_fd] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_recv_fd = (&__actvbridgecapcallhdlr_fshandler_vfs_recv_fd)
	},
	[__fs_method_vfs_get_buffer_wrapper] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper = (&__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper)
	},
	[__fs_method_vfs_get_pathname_by_me_idx] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx = (&__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx)
	},
	[__fs_method_vfs_sfile_put] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_sfile_put = (&__actvbridgecapcallhdlr_fshandler_vfs_sfile_put)
	},
	[__fs_method_vfs_readlinkat] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_readlinkat = (&__actvbridgecapcallhdlr_fshandler_vfs_readlinkat)
	},
	[__fs_method_vfs_get_slabinfo] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo = (&__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo)
	},
	[__fs_method_vfs_do_get_slabinfo] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo = (&__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo)
	},
	[__fs_method_vfs_fscache_print_info] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info = (&__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info)
	},
	[__fs_method_vfs_alloc_fs_handle_for_same_device] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device = (&__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device)
	},
	[__fs_method_vfs_free_fs_handle_for_same_device] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device = (&__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device)
	},
	[__fs_method_vfs_memfd_create] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_memfd_create = (&__actvbridgecapcallhdlr_fshandler_vfs_memfd_create)
	},
	[__fs_method_vfs_mknod] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mknod = (&__actvbridgecapcallhdlr_fshandler_vfs_mknod)
	},
	[__fs_method_vfs_rename] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_rename = (&__actvbridgecapcallhdlr_fshandler_vfs_rename)
	},
	[__fs_method_vfs_mkdirat] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mkdirat = (&__actvbridgecapcallhdlr_fshandler_vfs_mkdirat)
	},
	[__fs_method_vfs_link] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_link = (&__actvbridgecapcallhdlr_fshandler_vfs_link)
	},
	[__fs_method_vfs_unlink] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_unlink = (&__actvbridgecapcallhdlr_fshandler_vfs_unlink)
	},
	[__fs_method_vfs_symlink] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_symlink = (&__actvbridgecapcallhdlr_fshandler_vfs_symlink)
	},
	[__fs_method_vfs_getxattr] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_getxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_getxattr)
	},
	[__fs_method_vfs_fgetxattr] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr)
	},
	[__fs_method_vfs_setxattr] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_setxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_setxattr)
	},
	[__fs_method_vfs_fsetxattr] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr)
	},
	[__fs_method_vfs_listxattr] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_listxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_listxattr)
	},
	[__fs_method_vfs_flistxattr] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_flistxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_flistxattr)
	},
	[__fs_method_vfs_removexattr] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_removexattr = (&__actvbridgecapcallhdlr_fshandler_vfs_removexattr)
	},
	[__fs_method_vfs_fremovexattr] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr = (&__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr)
	},
	[__fs_method_vfs_iommap] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_iommap = (&__actvbridgecapcallhdlr_fshandler_vfs_iommap)
	},
	[__fs_method_vfs_mmap_create] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_create = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_create)
	},
	[__fs_method_vfs_mmap_release_file] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file)
	},
	[__fs_method_vfs_mmap_change] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_change)
	},
	[__fs_method_vfs_mmap_fill_page] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page)
	},
	[__fs_method_vfs_mmap_fetch_page] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page)
	},
	[__fs_method_vfs_mmap_change_page] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page)
	},
	[__fs_method_vfs_mmap_fallocate] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate)
	},
	[__fs_method_vfs_gfd_table_update] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update)
	},
	[__fs_method_vfs_gfd_table_remove] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove)
	},
	[__fs_method_vfs_gfd_table_expand] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand)
	},
	[__fs_method_vfs_gfd_table_acquire] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire)
	},
	[__fs_method_vfs_gfd_table_release] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release)
	},
	[__fs_method_vfs_gfd_table_replace] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace)
	},
	[__fs_method_vfs_gfd_table_fault] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault)
	},
	[__fs_method_vfs_anon_register_devhost] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost = (&__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost)
	},
	[__fs_method_vfs_get_unused_fd] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd = (&__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd)
	},
	[__fs_method_vfs_put_unused_fd] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd = (&__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd)
	},
	[__fs_method_vfs_fd_info_update] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update = (&__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update)
	},
	[__fs_method_vfs_get_root_path] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_root_path = (&__actvbridgecapcallhdlr_fshandler_vfs_get_root_path)
	},
	[__fs_method_vfs_transfs_fget] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget = (&__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget)
	},
	[__fs_method_vfs_do_trans_fget] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget = (&__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget)
	},
	[__fs_method_vfs_transfs_fput] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput = (&__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput)
	},
	[__fs_method_vfs_do_trans_fput] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput = (&__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput)
	},
	[__fs_method_vfs_read_mounts] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_read_mounts = (&__actvbridgecapcallhdlr_fshandler_vfs_read_mounts)
	}
};

#else
#ifndef __ARCH_RPC_REQUIRE_BRIDGE_HDLR
#error "Only support 64-bit server, build for aarch64 please!"
#else
union fs_hdlrs_union sysif_fs_actvhdlr_table[__fs_method_MAX] = {
	[0 ... __ACTV_UPCALL_POOL_GRANT_CHANGE * 2U - 1U] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_default_handler)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE * 2U] = {
		.p_sysif_handle_kcall_entry = (&sysif_actv_pool_handle_grant_change)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE * 2U + 1U] = {
		.p_sysif_handle_kcall_entry = (&sysif_actv_pool_handle_grant_change)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE * 2U + 2U ... __fs_method_MIN * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_default_handler)
	},
	[__fs_method_procfs_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_create_data * 2] = {
		.p__actvbridgehdlr_fshandler_procfs_create_data = (&__actvbridgehdlr_fshandler_procfs_create_data)
	},
	[__fs_method_procfs_create_data * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_procfs_create_data = (&__actvbridgehdlr_fshandler_compat_procfs_create_data)
	},
	[__fs_method_procfs_delete_data * 2] = {
		.p__actvbridgehdlr_fshandler_procfs_delete_data = (&__actvbridgehdlr_fshandler_procfs_delete_data)
	},
	[__fs_method_procfs_delete_data * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_procfs_delete_data = (&__actvbridgehdlr_fshandler_compat_procfs_delete_data)
	},
	[__fs_method_procfs_get_process_fds * 2] = {
		.p__actvbridgehdlr_fshandler_procfs_get_process_fds = (&__actvbridgehdlr_fshandler_procfs_get_process_fds)
	},
	[__fs_method_procfs_get_process_fds * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_procfs_get_process_fds = (&__actvbridgehdlr_fshandler_compat_procfs_get_process_fds)
	},
	[__fs_method_procfs_get_fd_mode * 2] = {
		.p__actvbridgehdlr_fshandler_procfs_get_fd_mode = (&__actvbridgehdlr_fshandler_procfs_get_fd_mode)
	},
	[__fs_method_procfs_get_fd_mode * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_procfs_get_fd_mode = (&__actvbridgehdlr_fshandler_compat_procfs_get_fd_mode)
	},
	[__fs_method_sysfs_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_create_file * 2] = {
		.p__actvbridgehdlr_fshandler_sysfs_create_file = (&__actvbridgehdlr_fshandler_sysfs_create_file)
	},
	[__fs_method_sysfs_create_file * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_sysfs_create_file = (&__actvbridgehdlr_fshandler_compat_sysfs_create_file)
	},
	[__fs_method_sysfs_create_dir * 2] = {
		.p__actvbridgehdlr_fshandler_sysfs_create_dir = (&__actvbridgehdlr_fshandler_sysfs_create_dir)
	},
	[__fs_method_sysfs_create_dir * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_sysfs_create_dir = (&__actvbridgehdlr_fshandler_compat_sysfs_create_dir)
	},
	[__fs_method_sysfs_create_symlink * 2] = {
		.p__actvbridgehdlr_fshandler_sysfs_create_symlink = (&__actvbridgehdlr_fshandler_sysfs_create_symlink)
	},
	[__fs_method_sysfs_create_symlink * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_sysfs_create_symlink = (&__actvbridgehdlr_fshandler_compat_sysfs_create_symlink)
	},
	[__fs_method_sysfs_delete * 2] = {
		.p__actvbridgehdlr_fshandler_sysfs_delete = (&__actvbridgehdlr_fshandler_sysfs_delete)
	},
	[__fs_method_sysfs_delete * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_sysfs_delete = (&__actvbridgehdlr_fshandler_compat_sysfs_delete)
	},
	[__fs_method_sysfs_notify * 2] = {
		.p__actvbridgehdlr_fshandler_sysfs_notify = (&__actvbridgehdlr_fshandler_sysfs_notify)
	},
	[__fs_method_sysfs_notify * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_sysfs_notify = (&__actvbridgehdlr_fshandler_compat_sysfs_notify)
	},
	[__fs_method_clock_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_settime * 2] = {
		.p__actvbridgehdlr_fshandler_clock_settime = (&__actvbridgehdlr_fshandler_clock_settime)
	},
	[__fs_method_clock_settime * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_clock_settime = (&__actvbridgehdlr_fshandler_compat_clock_settime)
	},
	[__fs_method_clock_gettime * 2] = {
		.p__actvbridgehdlr_fshandler_clock_gettime = (&__actvbridgehdlr_fshandler_clock_gettime)
	},
	[__fs_method_clock_gettime * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_clock_gettime = (&__actvbridgehdlr_fshandler_compat_clock_gettime)
	},
	[__fs_method_clock_getres * 2] = {
		.p__actvbridgehdlr_fshandler_clock_getres = (&__actvbridgehdlr_fshandler_clock_getres)
	},
	[__fs_method_clock_getres * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_clock_getres = (&__actvbridgehdlr_fshandler_compat_clock_getres)
	},
	[__fs_method_clock_adjtime * 2] = {
		.p__actvbridgehdlr_fshandler_clock_adjtime = (&__actvbridgehdlr_fshandler_clock_adjtime)
	},
	[__fs_method_clock_adjtime * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_clock_adjtime = (&__actvbridgehdlr_fshandler_compat_clock_adjtime)
	},
	[__fs_method_inotify_rsvd_9 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_8 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_9 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_8 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_init1 * 2] = {
		.p__actvbridgehdlr_fshandler_inotify_init1 = (&__actvbridgehdlr_fshandler_inotify_init1)
	},
	[__fs_method_inotify_init1 * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_inotify_init1 = (&__actvbridgehdlr_fshandler_compat_inotify_init1)
	},
	[__fs_method_inotify_add_watch * 2] = {
		.p__actvbridgehdlr_fshandler_inotify_add_watch = (&__actvbridgehdlr_fshandler_inotify_add_watch)
	},
	[__fs_method_inotify_add_watch * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_inotify_add_watch = (&__actvbridgehdlr_fshandler_compat_inotify_add_watch)
	},
	[__fs_method_inotify_rm_watch * 2] = {
		.p__actvbridgehdlr_fshandler_inotify_rm_watch = (&__actvbridgehdlr_fshandler_inotify_rm_watch)
	},
	[__fs_method_inotify_rm_watch * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_inotify_rm_watch = (&__actvbridgehdlr_fshandler_compat_inotify_rm_watch)
	},
	[__fs_method_inotify_add_watch_internal * 2] = {
		.p__actvbridgehdlr_fshandler_inotify_add_watch_internal = (&__actvbridgehdlr_fshandler_inotify_add_watch_internal)
	},
	[__fs_method_inotify_add_watch_internal * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_inotify_add_watch_internal = (&__actvbridgehdlr_fshandler_compat_inotify_add_watch_internal)
	},
	[__fs_method_inotify_rm_watch_internal * 2] = {
		.p__actvbridgehdlr_fshandler_inotify_rm_watch_internal = (&__actvbridgehdlr_fshandler_inotify_rm_watch_internal)
	},
	[__fs_method_inotify_rm_watch_internal * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_inotify_rm_watch_internal = (&__actvbridgehdlr_fshandler_compat_inotify_rm_watch_internal)
	},
	[__fs_method_inotify_notify * 2] = {
		.p__actvbridgehdlr_fshandler_inotify_notify = (&__actvbridgehdlr_fshandler_inotify_notify)
	},
	[__fs_method_inotify_notify * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_inotify_notify = (&__actvbridgehdlr_fshandler_compat_inotify_notify)
	},
	[__fs_method_inotify_inode_destroyed * 2] = {
		.p__actvbridgehdlr_fshandler_inotify_inode_destroyed = (&__actvbridgehdlr_fshandler_inotify_inode_destroyed)
	},
	[__fs_method_inotify_inode_destroyed * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_inotify_inode_destroyed = (&__actvbridgehdlr_fshandler_compat_inotify_inode_destroyed)
	},
	[__fs_method_fanotify_rsvd_9 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_8 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_9 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_8 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_init * 2] = {
		.p__actvbridgehdlr_fshandler_fanotify_init = (&__actvbridgehdlr_fshandler_fanotify_init)
	},
	[__fs_method_fanotify_init * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_fanotify_init = (&__actvbridgehdlr_fshandler_compat_fanotify_init)
	},
	[__fs_method_fanotify_mark * 2] = {
		.p__actvbridgehdlr_fshandler_fanotify_mark = (&__actvbridgehdlr_fshandler_fanotify_mark)
	},
	[__fs_method_fanotify_mark * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_fanotify_mark = (&__actvbridgehdlr_fshandler_compat_fanotify_mark)
	},
	[__fs_method_fanotify_mark_internal * 2] = {
		.p__actvbridgehdlr_fshandler_fanotify_mark_internal = (&__actvbridgehdlr_fshandler_fanotify_mark_internal)
	},
	[__fs_method_fanotify_mark_internal * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_fanotify_mark_internal = (&__actvbridgehdlr_fshandler_compat_fanotify_mark_internal)
	},
	[__fs_method_fanotify_rm_watch_internal * 2] = {
		.p__actvbridgehdlr_fshandler_fanotify_rm_watch_internal = (&__actvbridgehdlr_fshandler_fanotify_rm_watch_internal)
	},
	[__fs_method_fanotify_rm_watch_internal * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_fanotify_rm_watch_internal = (&__actvbridgehdlr_fshandler_compat_fanotify_rm_watch_internal)
	},
	[__fs_method_fanotify_notify * 2] = {
		.p__actvbridgehdlr_fshandler_fanotify_notify = (&__actvbridgehdlr_fshandler_fanotify_notify)
	},
	[__fs_method_fanotify_notify * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_fanotify_notify = (&__actvbridgehdlr_fshandler_compat_fanotify_notify)
	},
	[__fs_method_fanotify_destroyed * 2] = {
		.p__actvbridgehdlr_fshandler_fanotify_destroyed = (&__actvbridgehdlr_fshandler_fanotify_destroyed)
	},
	[__fs_method_fanotify_destroyed * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_fanotify_destroyed = (&__actvbridgehdlr_fshandler_compat_fanotify_destroyed)
	},
	[__fs_method_fanotify_open * 2] = {
		.p__actvbridgehdlr_fshandler_fanotify_open = (&__actvbridgehdlr_fshandler_fanotify_open)
	},
	[__fs_method_fanotify_open * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_fanotify_open = (&__actvbridgehdlr_fshandler_compat_fanotify_open)
	},
	[__fs_method_endio_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_io_done * 2] = {
		.p__actvbridgehdlr_fshandler_endio_io_done = (&__actvbridgehdlr_fshandler_endio_io_done)
	},
	[__fs_method_endio_io_done * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_endio_io_done = (&__actvbridgehdlr_fshandler_compat_endio_io_done)
	},
	[__fs_method_sec_rsvd_8 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_8 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_set_label * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_set_label = (&__actvbridgehdlr_fshandler_vfs_set_label)
	},
	[__fs_method_vfs_set_label * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_set_label = (&__actvbridgehdlr_fshandler_compat_vfs_set_label)
	},
	[__fs_method_vfs_set_label_by_path * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_set_label_by_path = (&__actvbridgehdlr_fshandler_vfs_set_label_by_path)
	},
	[__fs_method_vfs_set_label_by_path * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_set_label_by_path = (&__actvbridgehdlr_fshandler_compat_vfs_set_label_by_path)
	},
	[__fs_method_vfs_get_label * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_label = (&__actvbridgehdlr_fshandler_vfs_get_label)
	},
	[__fs_method_vfs_get_label * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_label = (&__actvbridgehdlr_fshandler_compat_vfs_get_label)
	},
	[__fs_method_vfs_init_audit * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_init_audit = (&__actvbridgehdlr_fshandler_vfs_init_audit)
	},
	[__fs_method_vfs_init_audit * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_init_audit = (&__actvbridgehdlr_fshandler_compat_vfs_init_audit)
	},
	[__fs_method_vfs_add_audit_rule * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_add_audit_rule = (&__actvbridgehdlr_fshandler_vfs_add_audit_rule)
	},
	[__fs_method_vfs_add_audit_rule * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_add_audit_rule = (&__actvbridgehdlr_fshandler_compat_vfs_add_audit_rule)
	},
	[__fs_method_vfs_del_audit_rule * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_del_audit_rule = (&__actvbridgehdlr_fshandler_vfs_del_audit_rule)
	},
	[__fs_method_vfs_del_audit_rule * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_del_audit_rule = (&__actvbridgehdlr_fshandler_compat_vfs_del_audit_rule)
	},
	[__fs_method_vfs_match_audit_watch_file * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_match_audit_watch_file = (&__actvbridgehdlr_fshandler_vfs_match_audit_watch_file)
	},
	[__fs_method_vfs_match_audit_watch_file * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_file = (&__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_file)
	},
	[__fs_method_vfs_match_audit_watch_dir * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir = (&__actvbridgehdlr_fshandler_vfs_match_audit_watch_dir)
	},
	[__fs_method_vfs_match_audit_watch_dir * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_dir = (&__actvbridgehdlr_fshandler_compat_vfs_match_audit_watch_dir)
	},
	[__fs_method_vfs_rsvd_121 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_120 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_119 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_118 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_117 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_116 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_115 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_114 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_113 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_112 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_111 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_110 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_109 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_108 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_107 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_106 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_105 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_104 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_103 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_102 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_101 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_100 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_99 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_98 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_97 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_96 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_95 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_94 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_93 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_92 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_91 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_90 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_89 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_88 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_87 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_86 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_85 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_84 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_83 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_82 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_81 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_80 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_79 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_78 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_77 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_76 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_75 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_74 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_73 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_72 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_71 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_70 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_69 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_68 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_67 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_66 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_65 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_64 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_63 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_62 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_61 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_60 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_59 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_58 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_57 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_56 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_55 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_54 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_53 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_52 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_51 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_50 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_49 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_48 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_47 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_46 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_45 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_44 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_43 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_42 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_41 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_40 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_39 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_38 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_37 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_36 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_35 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_34 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_33 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_32 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_31 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_30 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_29 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_28 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_27 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_26 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_25 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_24 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_23 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_22 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_21 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_20 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_19 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_18 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_17 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_16 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_15 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_14 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_13 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_12 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_11 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_10 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_9 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_8 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_121 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_120 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_119 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_118 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_117 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_116 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_115 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_114 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_113 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_112 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_111 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_110 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_109 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_108 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_107 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_106 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_105 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_104 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_103 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_102 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_101 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_100 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_99 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_98 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_97 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_96 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_95 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_94 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_93 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_92 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_91 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_90 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_89 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_88 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_87 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_86 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_85 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_84 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_83 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_82 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_81 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_80 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_79 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_78 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_77 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_76 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_75 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_74 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_73 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_72 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_71 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_70 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_69 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_68 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_67 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_66 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_65 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_64 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_63 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_62 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_61 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_60 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_59 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_58 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_57 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_56 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_55 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_54 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_53 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_52 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_51 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_50 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_49 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_48 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_47 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_46 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_45 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_44 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_43 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_42 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_41 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_40 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_39 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_38 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_37 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_36 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_35 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_34 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_33 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_32 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_31 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_30 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_29 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_28 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_27 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_26 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_25 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_24 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_23 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_22 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_21 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_20 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_19 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_18 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_17 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_16 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_15 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_14 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_13 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_12 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_11 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_10 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_9 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_8 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_client_init * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_client_init = (&__actvbridgehdlr_fshandler_vfs_client_init)
	},
	[__fs_method_vfs_client_init * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_client_init = (&__actvbridgehdlr_fshandler_compat_vfs_client_init)
	},
	[__fs_method_vfs_bind_update * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_bind_update = (&__actvbridgehdlr_fshandler_vfs_bind_update)
	},
	[__fs_method_vfs_bind_update * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_bind_update = (&__actvbridgehdlr_fshandler_compat_vfs_bind_update)
	},
	[__fs_method_vfs_clone * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_clone = (&__actvbridgehdlr_fshandler_vfs_clone)
	},
	[__fs_method_vfs_clone * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_clone = (&__actvbridgehdlr_fshandler_compat_vfs_clone)
	},
	[__fs_method_vfs_close * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_close = (&__actvbridgehdlr_fshandler_vfs_close)
	},
	[__fs_method_vfs_close * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_close = (&__actvbridgehdlr_fshandler_compat_vfs_close)
	},
	[__fs_method_vfs_mount * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mount = (&__actvbridgehdlr_fshandler_vfs_mount)
	},
	[__fs_method_vfs_mount * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mount = (&__actvbridgehdlr_fshandler_compat_vfs_mount)
	},
	[__fs_method_vfs_clone_mount_entry * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_clone_mount_entry = (&__actvbridgehdlr_fshandler_vfs_clone_mount_entry)
	},
	[__fs_method_vfs_clone_mount_entry * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry = (&__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry)
	},
	[__fs_method_vfs_clone_mount_entry_from_orig_parent * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent = (&__actvbridgehdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_clone_mount_entry_from_orig_parent * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent = (&__actvbridgehdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent = (&__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent = (&__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry = (&__actvbridgehdlr_fshandler_vfs_destroy_cloned_mount_entry)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry = (&__actvbridgehdlr_fshandler_compat_vfs_destroy_cloned_mount_entry)
	},
	[__fs_method_vfs_check_mount * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_check_mount = (&__actvbridgehdlr_fshandler_vfs_check_mount)
	},
	[__fs_method_vfs_check_mount * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_check_mount = (&__actvbridgehdlr_fshandler_compat_vfs_check_mount)
	},
	[__fs_method_vfs_mountpoint_del_mount * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount = (&__actvbridgehdlr_fshandler_vfs_mountpoint_del_mount)
	},
	[__fs_method_vfs_mountpoint_del_mount * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mountpoint_del_mount = (&__actvbridgehdlr_fshandler_compat_vfs_mountpoint_del_mount)
	},
	[__fs_method_vfs_open * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_open = (&__actvbridgehdlr_fshandler_vfs_open)
	},
	[__fs_method_vfs_open * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_open = (&__actvbridgehdlr_fshandler_compat_vfs_open)
	},
	[__fs_method_vfs_ftruncate * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_ftruncate = (&__actvbridgehdlr_fshandler_vfs_ftruncate)
	},
	[__fs_method_vfs_ftruncate * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_ftruncate = (&__actvbridgehdlr_fshandler_compat_vfs_ftruncate)
	},
	[__fs_method_vfs_fstat * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fstat = (&__actvbridgehdlr_fshandler_vfs_fstat)
	},
	[__fs_method_vfs_fstat * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fstat = (&__actvbridgehdlr_fshandler_compat_vfs_fstat)
	},
	[__fs_method_vfs_stat * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_stat = (&__actvbridgehdlr_fshandler_vfs_stat)
	},
	[__fs_method_vfs_stat * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_stat = (&__actvbridgehdlr_fshandler_compat_vfs_stat)
	},
	[__fs_method_vfs_statfs * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_statfs = (&__actvbridgehdlr_fshandler_vfs_statfs)
	},
	[__fs_method_vfs_statfs * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_statfs = (&__actvbridgehdlr_fshandler_compat_vfs_statfs)
	},
	[__fs_method_vfs_fstatfs * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fstatfs = (&__actvbridgehdlr_fshandler_vfs_fstatfs)
	},
	[__fs_method_vfs_fstatfs * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fstatfs = (&__actvbridgehdlr_fshandler_compat_vfs_fstatfs)
	},
	[__fs_method_vfs_fsync * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fsync = (&__actvbridgehdlr_fshandler_vfs_fsync)
	},
	[__fs_method_vfs_fsync * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fsync = (&__actvbridgehdlr_fshandler_compat_vfs_fsync)
	},
	[__fs_method_vfs_unmount * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_unmount = (&__actvbridgehdlr_fshandler_vfs_unmount)
	},
	[__fs_method_vfs_unmount * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_unmount = (&__actvbridgehdlr_fshandler_compat_vfs_unmount)
	},
	[__fs_method_vfs_unmount_from_server * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_unmount_from_server = (&__actvbridgehdlr_fshandler_vfs_unmount_from_server)
	},
	[__fs_method_vfs_unmount_from_server * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_unmount_from_server = (&__actvbridgehdlr_fshandler_compat_vfs_unmount_from_server)
	},
	[__fs_method_vfs_unmount_child * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_unmount_child = (&__actvbridgehdlr_fshandler_vfs_unmount_child)
	},
	[__fs_method_vfs_unmount_child * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_unmount_child = (&__actvbridgehdlr_fshandler_compat_vfs_unmount_child)
	},
	[__fs_method_vfs_truncate * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_truncate = (&__actvbridgehdlr_fshandler_vfs_truncate)
	},
	[__fs_method_vfs_truncate * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_truncate = (&__actvbridgehdlr_fshandler_compat_vfs_truncate)
	},
	[__fs_method_vfs_fs_fork * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fs_fork = (&__actvbridgehdlr_fshandler_vfs_fs_fork)
	},
	[__fs_method_vfs_fs_fork * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fs_fork = (&__actvbridgehdlr_fshandler_compat_vfs_fs_fork)
	},
	[__fs_method_vfs_query_info * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_query_info = (&__actvbridgehdlr_fshandler_vfs_query_info)
	},
	[__fs_method_vfs_query_info * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_query_info = (&__actvbridgehdlr_fshandler_compat_vfs_query_info)
	},
	[__fs_method_vfs_lseek * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_lseek = (&__actvbridgehdlr_fshandler_vfs_lseek)
	},
	[__fs_method_vfs_lseek * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_lseek = (&__actvbridgehdlr_fshandler_compat_vfs_lseek)
	},
	[__fs_method_vfs_trans * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_trans = (&__actvbridgehdlr_fshandler_vfs_trans)
	},
	[__fs_method_vfs_trans * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_trans = (&__actvbridgehdlr_fshandler_compat_vfs_trans)
	},
	[__fs_method_vfs_pipe2 * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_pipe2 = (&__actvbridgehdlr_fshandler_vfs_pipe2)
	},
	[__fs_method_vfs_pipe2 * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_pipe2 = (&__actvbridgehdlr_fshandler_compat_vfs_pipe2)
	},
	[__fs_method_vfs_tee * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_tee = (&__actvbridgehdlr_fshandler_vfs_tee)
	},
	[__fs_method_vfs_tee * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_tee = (&__actvbridgehdlr_fshandler_compat_vfs_tee)
	},
	[__fs_method_vfs_splice * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_splice = (&__actvbridgehdlr_fshandler_vfs_splice)
	},
	[__fs_method_vfs_splice * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_splice = (&__actvbridgehdlr_fshandler_compat_vfs_splice)
	},
	[__fs_method_vfs_do_splice_srvs * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_do_splice_srvs = (&__actvbridgehdlr_fshandler_vfs_do_splice_srvs)
	},
	[__fs_method_vfs_do_splice_srvs * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_do_splice_srvs = (&__actvbridgehdlr_fshandler_compat_vfs_do_splice_srvs)
	},
	[__fs_method_vfs_revoke_process * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_revoke_process = (&__actvbridgehdlr_fshandler_vfs_revoke_process)
	},
	[__fs_method_vfs_revoke_process * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_revoke_process = (&__actvbridgehdlr_fshandler_compat_vfs_revoke_process)
	},
	[__fs_method_vfs_setrlimit * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_setrlimit = (&__actvbridgehdlr_fshandler_vfs_setrlimit)
	},
	[__fs_method_vfs_setrlimit * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_setrlimit = (&__actvbridgehdlr_fshandler_compat_vfs_setrlimit)
	},
	[__fs_method_vfs_get_ns * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_ns = (&__actvbridgehdlr_fshandler_vfs_get_ns)
	},
	[__fs_method_vfs_get_ns * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_ns = (&__actvbridgehdlr_fshandler_compat_vfs_get_ns)
	},
	[__fs_method_vfs_put_ns * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_put_ns = (&__actvbridgehdlr_fshandler_vfs_put_ns)
	},
	[__fs_method_vfs_put_ns * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_put_ns = (&__actvbridgehdlr_fshandler_compat_vfs_put_ns)
	},
	[__fs_method_vfs_init_eventfd * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_init_eventfd = (&__actvbridgehdlr_fshandler_vfs_init_eventfd)
	},
	[__fs_method_vfs_init_eventfd * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_init_eventfd = (&__actvbridgehdlr_fshandler_compat_vfs_init_eventfd)
	},
	[__fs_method_vfs_write_eventfd * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_write_eventfd = (&__actvbridgehdlr_fshandler_vfs_write_eventfd)
	},
	[__fs_method_vfs_write_eventfd * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_write_eventfd = (&__actvbridgehdlr_fshandler_compat_vfs_write_eventfd)
	},
	[__fs_method_vfs_timerfd_create * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_timerfd_create = (&__actvbridgehdlr_fshandler_vfs_timerfd_create)
	},
	[__fs_method_vfs_timerfd_create * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_timerfd_create = (&__actvbridgehdlr_fshandler_compat_vfs_timerfd_create)
	},
	[__fs_method_vfs_timerfd_settime * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_timerfd_settime = (&__actvbridgehdlr_fshandler_vfs_timerfd_settime)
	},
	[__fs_method_vfs_timerfd_settime * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_timerfd_settime = (&__actvbridgehdlr_fshandler_compat_vfs_timerfd_settime)
	},
	[__fs_method_vfs_timerfd_gettime * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_timerfd_gettime = (&__actvbridgehdlr_fshandler_vfs_timerfd_gettime)
	},
	[__fs_method_vfs_timerfd_gettime * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_timerfd_gettime = (&__actvbridgehdlr_fshandler_compat_vfs_timerfd_gettime)
	},
	[__fs_method_vfs_open_exec * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_open_exec = (&__actvbridgehdlr_fshandler_vfs_open_exec)
	},
	[__fs_method_vfs_open_exec * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_open_exec = (&__actvbridgehdlr_fshandler_compat_vfs_open_exec)
	},
	[__fs_method_vfs_close_exec * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_close_exec = (&__actvbridgehdlr_fshandler_vfs_close_exec)
	},
	[__fs_method_vfs_close_exec * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_close_exec = (&__actvbridgehdlr_fshandler_compat_vfs_close_exec)
	},
	[__fs_method_vfs_set_elf_file * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_set_elf_file = (&__actvbridgehdlr_fshandler_vfs_set_elf_file)
	},
	[__fs_method_vfs_set_elf_file * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_set_elf_file = (&__actvbridgehdlr_fshandler_compat_vfs_set_elf_file)
	},
	[__fs_method_vfs_ioctl * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_ioctl = (&__actvbridgehdlr_fshandler_vfs_ioctl)
	},
	[__fs_method_vfs_ioctl * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_ioctl = (&__actvbridgehdlr_fshandler_compat_vfs_ioctl)
	},
	[__fs_method_vfs_read * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_read = (&__actvbridgehdlr_fshandler_vfs_read)
	},
	[__fs_method_vfs_read * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_read = (&__actvbridgehdlr_fshandler_compat_vfs_read)
	},
	[__fs_method_vfs_readv * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_readv = (&__actvbridgehdlr_fshandler_vfs_readv)
	},
	[__fs_method_vfs_readv * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_readv = (&__actvbridgehdlr_fshandler_compat_vfs_readv)
	},
	[__fs_method_vfs_getcwd * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_getcwd = (&__actvbridgehdlr_fshandler_vfs_getcwd)
	},
	[__fs_method_vfs_getcwd * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_getcwd = (&__actvbridgehdlr_fshandler_compat_vfs_getcwd)
	},
	[__fs_method_vfs_get_process_cwdrootexe * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe = (&__actvbridgehdlr_fshandler_vfs_get_process_cwdrootexe)
	},
	[__fs_method_vfs_get_process_cwdrootexe * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_process_cwdrootexe = (&__actvbridgehdlr_fshandler_compat_vfs_get_process_cwdrootexe)
	},
	[__fs_method_vfs_readdir * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_readdir = (&__actvbridgehdlr_fshandler_vfs_readdir)
	},
	[__fs_method_vfs_readdir * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_readdir = (&__actvbridgehdlr_fshandler_compat_vfs_readdir)
	},
	[__fs_method_vfs_write * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_write = (&__actvbridgehdlr_fshandler_vfs_write)
	},
	[__fs_method_vfs_write * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_write = (&__actvbridgehdlr_fshandler_compat_vfs_write)
	},
	[__fs_method_vfs_writev * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_writev = (&__actvbridgehdlr_fshandler_vfs_writev)
	},
	[__fs_method_vfs_writev * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_writev = (&__actvbridgehdlr_fshandler_compat_vfs_writev)
	},
	[__fs_method_vfs_sync * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_sync = (&__actvbridgehdlr_fshandler_vfs_sync)
	},
	[__fs_method_vfs_sync * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_sync = (&__actvbridgehdlr_fshandler_compat_vfs_sync)
	},
	[__fs_method_vfs_do_sync * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_do_sync = (&__actvbridgehdlr_fshandler_vfs_do_sync)
	},
	[__fs_method_vfs_do_sync * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_do_sync = (&__actvbridgehdlr_fshandler_compat_vfs_do_sync)
	},
	[__fs_method_vfs_utimensat * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_utimensat = (&__actvbridgehdlr_fshandler_vfs_utimensat)
	},
	[__fs_method_vfs_utimensat * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_utimensat = (&__actvbridgehdlr_fshandler_compat_vfs_utimensat)
	},
	[__fs_method_vfs_futimens * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_futimens = (&__actvbridgehdlr_fshandler_vfs_futimens)
	},
	[__fs_method_vfs_futimens * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_futimens = (&__actvbridgehdlr_fshandler_compat_vfs_futimens)
	},
	[__fs_method_vfs_fchmodat * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fchmodat = (&__actvbridgehdlr_fshandler_vfs_fchmodat)
	},
	[__fs_method_vfs_fchmodat * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fchmodat = (&__actvbridgehdlr_fshandler_compat_vfs_fchmodat)
	},
	[__fs_method_vfs_fchmod * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fchmod = (&__actvbridgehdlr_fshandler_vfs_fchmod)
	},
	[__fs_method_vfs_fchmod * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fchmod = (&__actvbridgehdlr_fshandler_compat_vfs_fchmod)
	},
	[__fs_method_vfs_drop_caches * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_drop_caches = (&__actvbridgehdlr_fshandler_vfs_drop_caches)
	},
	[__fs_method_vfs_drop_caches * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_drop_caches = (&__actvbridgehdlr_fshandler_compat_vfs_drop_caches)
	},
	[__fs_method_vfs_do_drop_caches * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_do_drop_caches = (&__actvbridgehdlr_fshandler_vfs_do_drop_caches)
	},
	[__fs_method_vfs_do_drop_caches * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_do_drop_caches = (&__actvbridgehdlr_fshandler_compat_vfs_do_drop_caches)
	},
	[__fs_method_vfs_fadvise * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fadvise = (&__actvbridgehdlr_fshandler_vfs_fadvise)
	},
	[__fs_method_vfs_fadvise * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fadvise = (&__actvbridgehdlr_fshandler_compat_vfs_fadvise)
	},
	[__fs_method_vfs_readahead * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_readahead = (&__actvbridgehdlr_fshandler_vfs_readahead)
	},
	[__fs_method_vfs_readahead * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_readahead = (&__actvbridgehdlr_fshandler_compat_vfs_readahead)
	},
	[__fs_method_vfs_get_fd_path * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_fd_path = (&__actvbridgehdlr_fshandler_vfs_get_fd_path)
	},
	[__fs_method_vfs_get_fd_path * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_fd_path = (&__actvbridgehdlr_fshandler_compat_vfs_get_fd_path)
	},
	[__fs_method_vfs_sysmgr_get_fd_path * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path = (&__actvbridgehdlr_fshandler_vfs_sysmgr_get_fd_path)
	},
	[__fs_method_vfs_sysmgr_get_fd_path * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_sysmgr_get_fd_path = (&__actvbridgehdlr_fshandler_compat_vfs_sysmgr_get_fd_path)
	},
	[__fs_method_vfs_fcntl * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fcntl = (&__actvbridgehdlr_fshandler_vfs_fcntl)
	},
	[__fs_method_vfs_fcntl * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fcntl = (&__actvbridgehdlr_fshandler_compat_vfs_fcntl)
	},
	[__fs_method_vfs_device_mounted * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_device_mounted = (&__actvbridgehdlr_fshandler_vfs_device_mounted)
	},
	[__fs_method_vfs_device_mounted * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_device_mounted = (&__actvbridgehdlr_fshandler_compat_vfs_device_mounted)
	},
	[__fs_method_vfs_quotactl * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_quotactl = (&__actvbridgehdlr_fshandler_vfs_quotactl)
	},
	[__fs_method_vfs_quotactl * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_quotactl = (&__actvbridgehdlr_fshandler_compat_vfs_quotactl)
	},
	[__fs_method_vfs_copy_file_range * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_copy_file_range = (&__actvbridgehdlr_fshandler_vfs_copy_file_range)
	},
	[__fs_method_vfs_copy_file_range * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_copy_file_range = (&__actvbridgehdlr_fshandler_compat_vfs_copy_file_range)
	},
	[__fs_method_vfs_same_file * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_same_file = (&__actvbridgehdlr_fshandler_vfs_same_file)
	},
	[__fs_method_vfs_same_file * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_same_file = (&__actvbridgehdlr_fshandler_compat_vfs_same_file)
	},
	[__fs_method_vfs_access * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_access = (&__actvbridgehdlr_fshandler_vfs_access)
	},
	[__fs_method_vfs_access * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_access = (&__actvbridgehdlr_fshandler_compat_vfs_access)
	},
	[__fs_method_vfs_flock * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_flock = (&__actvbridgehdlr_fshandler_vfs_flock)
	},
	[__fs_method_vfs_flock * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_flock = (&__actvbridgehdlr_fshandler_compat_vfs_flock)
	},
	[__fs_method_vfs_fchownat * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fchownat = (&__actvbridgehdlr_fshandler_vfs_fchownat)
	},
	[__fs_method_vfs_fchownat * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fchownat = (&__actvbridgehdlr_fshandler_compat_vfs_fchownat)
	},
	[__fs_method_vfs_fchown * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fchown = (&__actvbridgehdlr_fshandler_vfs_fchown)
	},
	[__fs_method_vfs_fchown * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fchown = (&__actvbridgehdlr_fshandler_compat_vfs_fchown)
	},
	[__fs_method_vfs_binderfs_mmap * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_binderfs_mmap = (&__actvbridgehdlr_fshandler_vfs_binderfs_mmap)
	},
	[__fs_method_vfs_binderfs_mmap * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_binderfs_mmap = (&__actvbridgehdlr_fshandler_compat_vfs_binderfs_mmap)
	},
	[__fs_method_vfs_init_signalfd * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_init_signalfd = (&__actvbridgehdlr_fshandler_vfs_init_signalfd)
	},
	[__fs_method_vfs_init_signalfd * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_init_signalfd = (&__actvbridgehdlr_fshandler_compat_vfs_init_signalfd)
	},
	[__fs_method_vfs_epoll_ctl * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_epoll_ctl = (&__actvbridgehdlr_fshandler_vfs_epoll_ctl)
	},
	[__fs_method_vfs_epoll_ctl * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_epoll_ctl = (&__actvbridgehdlr_fshandler_compat_vfs_epoll_ctl)
	},
	[__fs_method_vfs_epoll_et_revents * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_epoll_et_revents = (&__actvbridgehdlr_fshandler_vfs_epoll_et_revents)
	},
	[__fs_method_vfs_epoll_et_revents * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_epoll_et_revents = (&__actvbridgehdlr_fshandler_compat_vfs_epoll_et_revents)
	},
	[__fs_method_vfs_epoll_reinit * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_epoll_reinit = (&__actvbridgehdlr_fshandler_vfs_epoll_reinit)
	},
	[__fs_method_vfs_epoll_reinit * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_epoll_reinit = (&__actvbridgehdlr_fshandler_compat_vfs_epoll_reinit)
	},
	[__fs_method_vfs_signalfd_notify * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_signalfd_notify = (&__actvbridgehdlr_fshandler_vfs_signalfd_notify)
	},
	[__fs_method_vfs_signalfd_notify * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_signalfd_notify = (&__actvbridgehdlr_fshandler_compat_vfs_signalfd_notify)
	},
	[__fs_method_vfs_pid_io_stats * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_pid_io_stats = (&__actvbridgehdlr_fshandler_vfs_pid_io_stats)
	},
	[__fs_method_vfs_pid_io_stats * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_pid_io_stats = (&__actvbridgehdlr_fshandler_compat_vfs_pid_io_stats)
	},
	[__fs_method_vfs_fallocate * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fallocate = (&__actvbridgehdlr_fshandler_vfs_fallocate)
	},
	[__fs_method_vfs_fallocate * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fallocate = (&__actvbridgehdlr_fshandler_compat_vfs_fallocate)
	},
	[__fs_method_vfs_set_cwdroot * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_set_cwdroot = (&__actvbridgehdlr_fshandler_vfs_set_cwdroot)
	},
	[__fs_method_vfs_set_cwdroot * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_set_cwdroot = (&__actvbridgehdlr_fshandler_compat_vfs_set_cwdroot)
	},
	[__fs_method_vfs_fchdir * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fchdir = (&__actvbridgehdlr_fshandler_vfs_fchdir)
	},
	[__fs_method_vfs_fchdir * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fchdir = (&__actvbridgehdlr_fshandler_compat_vfs_fchdir)
	},
	[__fs_method_vfs_disable_cwdroot * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_disable_cwdroot = (&__actvbridgehdlr_fshandler_vfs_disable_cwdroot)
	},
	[__fs_method_vfs_disable_cwdroot * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_disable_cwdroot = (&__actvbridgehdlr_fshandler_compat_vfs_disable_cwdroot)
	},
	[__fs_method_vfs_update_cwdroot * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_update_cwdroot = (&__actvbridgehdlr_fshandler_vfs_update_cwdroot)
	},
	[__fs_method_vfs_update_cwdroot * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_update_cwdroot = (&__actvbridgehdlr_fshandler_compat_vfs_update_cwdroot)
	},
	[__fs_method_vfs_handle_global_locks * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_handle_global_locks = (&__actvbridgehdlr_fshandler_vfs_handle_global_locks)
	},
	[__fs_method_vfs_handle_global_locks * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_handle_global_locks = (&__actvbridgehdlr_fshandler_compat_vfs_handle_global_locks)
	},
	[__fs_method_vfs_send_fd * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_send_fd = (&__actvbridgehdlr_fshandler_vfs_send_fd)
	},
	[__fs_method_vfs_send_fd * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_send_fd = (&__actvbridgehdlr_fshandler_compat_vfs_send_fd)
	},
	[__fs_method_vfs_recv_fd * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_recv_fd = (&__actvbridgehdlr_fshandler_vfs_recv_fd)
	},
	[__fs_method_vfs_recv_fd * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_recv_fd = (&__actvbridgehdlr_fshandler_compat_vfs_recv_fd)
	},
	[__fs_method_vfs_get_buffer_wrapper * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper = (&__actvbridgehdlr_fshandler_vfs_get_buffer_wrapper)
	},
	[__fs_method_vfs_get_buffer_wrapper * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_buffer_wrapper = (&__actvbridgehdlr_fshandler_compat_vfs_get_buffer_wrapper)
	},
	[__fs_method_vfs_get_pathname_by_me_idx * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx = (&__actvbridgehdlr_fshandler_vfs_get_pathname_by_me_idx)
	},
	[__fs_method_vfs_get_pathname_by_me_idx * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_pathname_by_me_idx = (&__actvbridgehdlr_fshandler_compat_vfs_get_pathname_by_me_idx)
	},
	[__fs_method_vfs_sfile_put * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_sfile_put = (&__actvbridgehdlr_fshandler_vfs_sfile_put)
	},
	[__fs_method_vfs_sfile_put * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_sfile_put = (&__actvbridgehdlr_fshandler_compat_vfs_sfile_put)
	},
	[__fs_method_vfs_readlinkat * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_readlinkat = (&__actvbridgehdlr_fshandler_vfs_readlinkat)
	},
	[__fs_method_vfs_readlinkat * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_readlinkat = (&__actvbridgehdlr_fshandler_compat_vfs_readlinkat)
	},
	[__fs_method_vfs_get_slabinfo * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_slabinfo = (&__actvbridgehdlr_fshandler_vfs_get_slabinfo)
	},
	[__fs_method_vfs_get_slabinfo * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_slabinfo = (&__actvbridgehdlr_fshandler_compat_vfs_get_slabinfo)
	},
	[__fs_method_vfs_do_get_slabinfo * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_do_get_slabinfo = (&__actvbridgehdlr_fshandler_vfs_do_get_slabinfo)
	},
	[__fs_method_vfs_do_get_slabinfo * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_do_get_slabinfo = (&__actvbridgehdlr_fshandler_compat_vfs_do_get_slabinfo)
	},
	[__fs_method_vfs_fscache_print_info * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fscache_print_info = (&__actvbridgehdlr_fshandler_vfs_fscache_print_info)
	},
	[__fs_method_vfs_fscache_print_info * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fscache_print_info = (&__actvbridgehdlr_fshandler_compat_vfs_fscache_print_info)
	},
	[__fs_method_vfs_alloc_fs_handle_for_same_device * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device = (&__actvbridgehdlr_fshandler_vfs_alloc_fs_handle_for_same_device)
	},
	[__fs_method_vfs_alloc_fs_handle_for_same_device * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device = (&__actvbridgehdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device)
	},
	[__fs_method_vfs_free_fs_handle_for_same_device * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device = (&__actvbridgehdlr_fshandler_vfs_free_fs_handle_for_same_device)
	},
	[__fs_method_vfs_free_fs_handle_for_same_device * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_free_fs_handle_for_same_device = (&__actvbridgehdlr_fshandler_compat_vfs_free_fs_handle_for_same_device)
	},
	[__fs_method_vfs_memfd_create * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_memfd_create = (&__actvbridgehdlr_fshandler_vfs_memfd_create)
	},
	[__fs_method_vfs_memfd_create * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_memfd_create = (&__actvbridgehdlr_fshandler_compat_vfs_memfd_create)
	},
	[__fs_method_vfs_mknod * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mknod = (&__actvbridgehdlr_fshandler_vfs_mknod)
	},
	[__fs_method_vfs_mknod * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mknod = (&__actvbridgehdlr_fshandler_compat_vfs_mknod)
	},
	[__fs_method_vfs_rename * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_rename = (&__actvbridgehdlr_fshandler_vfs_rename)
	},
	[__fs_method_vfs_rename * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_rename = (&__actvbridgehdlr_fshandler_compat_vfs_rename)
	},
	[__fs_method_vfs_mkdirat * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mkdirat = (&__actvbridgehdlr_fshandler_vfs_mkdirat)
	},
	[__fs_method_vfs_mkdirat * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mkdirat = (&__actvbridgehdlr_fshandler_compat_vfs_mkdirat)
	},
	[__fs_method_vfs_link * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_link = (&__actvbridgehdlr_fshandler_vfs_link)
	},
	[__fs_method_vfs_link * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_link = (&__actvbridgehdlr_fshandler_compat_vfs_link)
	},
	[__fs_method_vfs_unlink * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_unlink = (&__actvbridgehdlr_fshandler_vfs_unlink)
	},
	[__fs_method_vfs_unlink * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_unlink = (&__actvbridgehdlr_fshandler_compat_vfs_unlink)
	},
	[__fs_method_vfs_symlink * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_symlink = (&__actvbridgehdlr_fshandler_vfs_symlink)
	},
	[__fs_method_vfs_symlink * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_symlink = (&__actvbridgehdlr_fshandler_compat_vfs_symlink)
	},
	[__fs_method_vfs_getxattr * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_getxattr = (&__actvbridgehdlr_fshandler_vfs_getxattr)
	},
	[__fs_method_vfs_getxattr * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_getxattr = (&__actvbridgehdlr_fshandler_compat_vfs_getxattr)
	},
	[__fs_method_vfs_fgetxattr * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fgetxattr = (&__actvbridgehdlr_fshandler_vfs_fgetxattr)
	},
	[__fs_method_vfs_fgetxattr * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fgetxattr = (&__actvbridgehdlr_fshandler_compat_vfs_fgetxattr)
	},
	[__fs_method_vfs_setxattr * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_setxattr = (&__actvbridgehdlr_fshandler_vfs_setxattr)
	},
	[__fs_method_vfs_setxattr * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_setxattr = (&__actvbridgehdlr_fshandler_compat_vfs_setxattr)
	},
	[__fs_method_vfs_fsetxattr * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fsetxattr = (&__actvbridgehdlr_fshandler_vfs_fsetxattr)
	},
	[__fs_method_vfs_fsetxattr * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fsetxattr = (&__actvbridgehdlr_fshandler_compat_vfs_fsetxattr)
	},
	[__fs_method_vfs_listxattr * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_listxattr = (&__actvbridgehdlr_fshandler_vfs_listxattr)
	},
	[__fs_method_vfs_listxattr * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_listxattr = (&__actvbridgehdlr_fshandler_compat_vfs_listxattr)
	},
	[__fs_method_vfs_flistxattr * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_flistxattr = (&__actvbridgehdlr_fshandler_vfs_flistxattr)
	},
	[__fs_method_vfs_flistxattr * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_flistxattr = (&__actvbridgehdlr_fshandler_compat_vfs_flistxattr)
	},
	[__fs_method_vfs_removexattr * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_removexattr = (&__actvbridgehdlr_fshandler_vfs_removexattr)
	},
	[__fs_method_vfs_removexattr * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_removexattr = (&__actvbridgehdlr_fshandler_compat_vfs_removexattr)
	},
	[__fs_method_vfs_fremovexattr * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fremovexattr = (&__actvbridgehdlr_fshandler_vfs_fremovexattr)
	},
	[__fs_method_vfs_fremovexattr * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fremovexattr = (&__actvbridgehdlr_fshandler_compat_vfs_fremovexattr)
	},
	[__fs_method_vfs_iommap * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_iommap = (&__actvbridgehdlr_fshandler_vfs_iommap)
	},
	[__fs_method_vfs_iommap * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_iommap = (&__actvbridgehdlr_fshandler_compat_vfs_iommap)
	},
	[__fs_method_vfs_mmap_create * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_create = (&__actvbridgehdlr_fshandler_vfs_mmap_create)
	},
	[__fs_method_vfs_mmap_create * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mmap_create = (&__actvbridgehdlr_fshandler_compat_vfs_mmap_create)
	},
	[__fs_method_vfs_mmap_release_file * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_release_file = (&__actvbridgehdlr_fshandler_vfs_mmap_release_file)
	},
	[__fs_method_vfs_mmap_release_file * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mmap_release_file = (&__actvbridgehdlr_fshandler_compat_vfs_mmap_release_file)
	},
	[__fs_method_vfs_mmap_change * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_change = (&__actvbridgehdlr_fshandler_vfs_mmap_change)
	},
	[__fs_method_vfs_mmap_change * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mmap_change = (&__actvbridgehdlr_fshandler_compat_vfs_mmap_change)
	},
	[__fs_method_vfs_mmap_fill_page * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_fill_page = (&__actvbridgehdlr_fshandler_vfs_mmap_fill_page)
	},
	[__fs_method_vfs_mmap_fill_page * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mmap_fill_page = (&__actvbridgehdlr_fshandler_compat_vfs_mmap_fill_page)
	},
	[__fs_method_vfs_mmap_fetch_page * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_fetch_page = (&__actvbridgehdlr_fshandler_vfs_mmap_fetch_page)
	},
	[__fs_method_vfs_mmap_fetch_page * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mmap_fetch_page = (&__actvbridgehdlr_fshandler_compat_vfs_mmap_fetch_page)
	},
	[__fs_method_vfs_mmap_change_page * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_change_page = (&__actvbridgehdlr_fshandler_vfs_mmap_change_page)
	},
	[__fs_method_vfs_mmap_change_page * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mmap_change_page = (&__actvbridgehdlr_fshandler_compat_vfs_mmap_change_page)
	},
	[__fs_method_vfs_mmap_fallocate * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_mmap_fallocate = (&__actvbridgehdlr_fshandler_vfs_mmap_fallocate)
	},
	[__fs_method_vfs_mmap_fallocate * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_mmap_fallocate = (&__actvbridgehdlr_fshandler_compat_vfs_mmap_fallocate)
	},
	[__fs_method_vfs_gfd_table_update * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_update = (&__actvbridgehdlr_fshandler_vfs_gfd_table_update)
	},
	[__fs_method_vfs_gfd_table_update * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_update = (&__actvbridgehdlr_fshandler_compat_vfs_gfd_table_update)
	},
	[__fs_method_vfs_gfd_table_remove * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_remove = (&__actvbridgehdlr_fshandler_vfs_gfd_table_remove)
	},
	[__fs_method_vfs_gfd_table_remove * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_remove = (&__actvbridgehdlr_fshandler_compat_vfs_gfd_table_remove)
	},
	[__fs_method_vfs_gfd_table_expand * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_expand = (&__actvbridgehdlr_fshandler_vfs_gfd_table_expand)
	},
	[__fs_method_vfs_gfd_table_expand * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_expand = (&__actvbridgehdlr_fshandler_compat_vfs_gfd_table_expand)
	},
	[__fs_method_vfs_gfd_table_acquire * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_acquire = (&__actvbridgehdlr_fshandler_vfs_gfd_table_acquire)
	},
	[__fs_method_vfs_gfd_table_acquire * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_acquire = (&__actvbridgehdlr_fshandler_compat_vfs_gfd_table_acquire)
	},
	[__fs_method_vfs_gfd_table_release * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_release = (&__actvbridgehdlr_fshandler_vfs_gfd_table_release)
	},
	[__fs_method_vfs_gfd_table_release * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_release = (&__actvbridgehdlr_fshandler_compat_vfs_gfd_table_release)
	},
	[__fs_method_vfs_gfd_table_replace * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_replace = (&__actvbridgehdlr_fshandler_vfs_gfd_table_replace)
	},
	[__fs_method_vfs_gfd_table_replace * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_replace = (&__actvbridgehdlr_fshandler_compat_vfs_gfd_table_replace)
	},
	[__fs_method_vfs_gfd_table_fault * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_gfd_table_fault = (&__actvbridgehdlr_fshandler_vfs_gfd_table_fault)
	},
	[__fs_method_vfs_gfd_table_fault * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_gfd_table_fault = (&__actvbridgehdlr_fshandler_compat_vfs_gfd_table_fault)
	},
	[__fs_method_vfs_anon_register_devhost * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_anon_register_devhost = (&__actvbridgehdlr_fshandler_vfs_anon_register_devhost)
	},
	[__fs_method_vfs_anon_register_devhost * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_anon_register_devhost = (&__actvbridgehdlr_fshandler_compat_vfs_anon_register_devhost)
	},
	[__fs_method_vfs_get_unused_fd * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_unused_fd = (&__actvbridgehdlr_fshandler_vfs_get_unused_fd)
	},
	[__fs_method_vfs_get_unused_fd * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_unused_fd = (&__actvbridgehdlr_fshandler_compat_vfs_get_unused_fd)
	},
	[__fs_method_vfs_put_unused_fd * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_put_unused_fd = (&__actvbridgehdlr_fshandler_vfs_put_unused_fd)
	},
	[__fs_method_vfs_put_unused_fd * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_put_unused_fd = (&__actvbridgehdlr_fshandler_compat_vfs_put_unused_fd)
	},
	[__fs_method_vfs_fd_info_update * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_fd_info_update = (&__actvbridgehdlr_fshandler_vfs_fd_info_update)
	},
	[__fs_method_vfs_fd_info_update * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_fd_info_update = (&__actvbridgehdlr_fshandler_compat_vfs_fd_info_update)
	},
	[__fs_method_vfs_get_root_path * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_get_root_path = (&__actvbridgehdlr_fshandler_vfs_get_root_path)
	},
	[__fs_method_vfs_get_root_path * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_get_root_path = (&__actvbridgehdlr_fshandler_compat_vfs_get_root_path)
	},
	[__fs_method_vfs_transfs_fget * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_transfs_fget = (&__actvbridgehdlr_fshandler_vfs_transfs_fget)
	},
	[__fs_method_vfs_transfs_fget * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_transfs_fget = (&__actvbridgehdlr_fshandler_compat_vfs_transfs_fget)
	},
	[__fs_method_vfs_do_trans_fget * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_do_trans_fget = (&__actvbridgehdlr_fshandler_vfs_do_trans_fget)
	},
	[__fs_method_vfs_do_trans_fget * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_do_trans_fget = (&__actvbridgehdlr_fshandler_compat_vfs_do_trans_fget)
	},
	[__fs_method_vfs_transfs_fput * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_transfs_fput = (&__actvbridgehdlr_fshandler_vfs_transfs_fput)
	},
	[__fs_method_vfs_transfs_fput * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_transfs_fput = (&__actvbridgehdlr_fshandler_compat_vfs_transfs_fput)
	},
	[__fs_method_vfs_do_trans_fput * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_do_trans_fput = (&__actvbridgehdlr_fshandler_vfs_do_trans_fput)
	},
	[__fs_method_vfs_do_trans_fput * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_do_trans_fput = (&__actvbridgehdlr_fshandler_compat_vfs_do_trans_fput)
	},
	[__fs_method_vfs_read_mounts * 2] = {
		.p__actvbridgehdlr_fshandler_vfs_read_mounts = (&__actvbridgehdlr_fshandler_vfs_read_mounts)
	},
	[__fs_method_vfs_read_mounts * 2 + 1] = {
		.p__actvbridgehdlr_fshandler_compat_vfs_read_mounts = (&__actvbridgehdlr_fshandler_compat_vfs_read_mounts)
	}
};

#endif
union fs_hdlrs_union sysif_fs_actvcapcallhdlr_table[__fs_method_MAX] = {
	[0 ... __ACTV_UPCALL_POOL_GRANT_CHANGE * 2U - 1U] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_default_handler)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE * 2U] = {
		.p_sysif_handle_kcall_entry = (&sysif_actv_pool_handle_grant_change)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE * 2U + 1U] = {
		.p_sysif_handle_kcall_entry = (&sysif_actv_pool_handle_grant_change)
	},
	[__ACTV_UPCALL_POOL_GRANT_CHANGE * 2U + 2U ... __fs_method_MIN * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_default_handler)
	},
	[__fs_method_procfs_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_procfs_create_data * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_procfs_create_data = (&__actvbridgecapcallhdlr_fshandler_procfs_create_data)
	},
	[__fs_method_procfs_create_data * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_procfs_create_data = (&__actvbridgecapcallhdlr_fshandler_compat_procfs_create_data)
	},
	[__fs_method_procfs_delete_data * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_procfs_delete_data = (&__actvbridgecapcallhdlr_fshandler_procfs_delete_data)
	},
	[__fs_method_procfs_delete_data * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_procfs_delete_data = (&__actvbridgecapcallhdlr_fshandler_compat_procfs_delete_data)
	},
	[__fs_method_procfs_get_process_fds * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds = (&__actvbridgecapcallhdlr_fshandler_procfs_get_process_fds)
	},
	[__fs_method_procfs_get_process_fds * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_procfs_get_process_fds = (&__actvbridgecapcallhdlr_fshandler_compat_procfs_get_process_fds)
	},
	[__fs_method_procfs_get_fd_mode * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode = (&__actvbridgecapcallhdlr_fshandler_procfs_get_fd_mode)
	},
	[__fs_method_procfs_get_fd_mode * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_procfs_get_fd_mode = (&__actvbridgecapcallhdlr_fshandler_compat_procfs_get_fd_mode)
	},
	[__fs_method_sysfs_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sysfs_create_file * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_create_file = (&__actvbridgecapcallhdlr_fshandler_sysfs_create_file)
	},
	[__fs_method_sysfs_create_file * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_file = (&__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_file)
	},
	[__fs_method_sysfs_create_dir * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_create_dir = (&__actvbridgecapcallhdlr_fshandler_sysfs_create_dir)
	},
	[__fs_method_sysfs_create_dir * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_dir = (&__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_dir)
	},
	[__fs_method_sysfs_create_symlink * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink = (&__actvbridgecapcallhdlr_fshandler_sysfs_create_symlink)
	},
	[__fs_method_sysfs_create_symlink * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_symlink = (&__actvbridgecapcallhdlr_fshandler_compat_sysfs_create_symlink)
	},
	[__fs_method_sysfs_delete * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_delete = (&__actvbridgecapcallhdlr_fshandler_sysfs_delete)
	},
	[__fs_method_sysfs_delete * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_sysfs_delete = (&__actvbridgecapcallhdlr_fshandler_compat_sysfs_delete)
	},
	[__fs_method_sysfs_notify * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_sysfs_notify = (&__actvbridgecapcallhdlr_fshandler_sysfs_notify)
	},
	[__fs_method_sysfs_notify * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_sysfs_notify = (&__actvbridgecapcallhdlr_fshandler_compat_sysfs_notify)
	},
	[__fs_method_clock_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_clock_settime * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_clock_settime = (&__actvbridgecapcallhdlr_fshandler_clock_settime)
	},
	[__fs_method_clock_settime * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_clock_settime = (&__actvbridgecapcallhdlr_fshandler_compat_clock_settime)
	},
	[__fs_method_clock_gettime * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_clock_gettime = (&__actvbridgecapcallhdlr_fshandler_clock_gettime)
	},
	[__fs_method_clock_gettime * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_clock_gettime = (&__actvbridgecapcallhdlr_fshandler_compat_clock_gettime)
	},
	[__fs_method_clock_getres * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_clock_getres = (&__actvbridgecapcallhdlr_fshandler_clock_getres)
	},
	[__fs_method_clock_getres * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_clock_getres = (&__actvbridgecapcallhdlr_fshandler_compat_clock_getres)
	},
	[__fs_method_clock_adjtime * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_clock_adjtime = (&__actvbridgecapcallhdlr_fshandler_clock_adjtime)
	},
	[__fs_method_clock_adjtime * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_clock_adjtime = (&__actvbridgecapcallhdlr_fshandler_compat_clock_adjtime)
	},
	[__fs_method_inotify_rsvd_9 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_8 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_9 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_8 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_inotify_init1 * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_init1 = (&__actvbridgecapcallhdlr_fshandler_inotify_init1)
	},
	[__fs_method_inotify_init1 * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_inotify_init1 = (&__actvbridgecapcallhdlr_fshandler_compat_inotify_init1)
	},
	[__fs_method_inotify_add_watch * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_add_watch = (&__actvbridgecapcallhdlr_fshandler_inotify_add_watch)
	},
	[__fs_method_inotify_add_watch * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch = (&__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch)
	},
	[__fs_method_inotify_rm_watch * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch = (&__actvbridgecapcallhdlr_fshandler_inotify_rm_watch)
	},
	[__fs_method_inotify_rm_watch * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch = (&__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch)
	},
	[__fs_method_inotify_add_watch_internal * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal = (&__actvbridgecapcallhdlr_fshandler_inotify_add_watch_internal)
	},
	[__fs_method_inotify_add_watch_internal * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch_internal = (&__actvbridgecapcallhdlr_fshandler_compat_inotify_add_watch_internal)
	},
	[__fs_method_inotify_rm_watch_internal * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal = (&__actvbridgecapcallhdlr_fshandler_inotify_rm_watch_internal)
	},
	[__fs_method_inotify_rm_watch_internal * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch_internal = (&__actvbridgecapcallhdlr_fshandler_compat_inotify_rm_watch_internal)
	},
	[__fs_method_inotify_notify * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_notify = (&__actvbridgecapcallhdlr_fshandler_inotify_notify)
	},
	[__fs_method_inotify_notify * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_inotify_notify = (&__actvbridgecapcallhdlr_fshandler_compat_inotify_notify)
	},
	[__fs_method_inotify_inode_destroyed * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed = (&__actvbridgecapcallhdlr_fshandler_inotify_inode_destroyed)
	},
	[__fs_method_inotify_inode_destroyed * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_inotify_inode_destroyed = (&__actvbridgecapcallhdlr_fshandler_compat_inotify_inode_destroyed)
	},
	[__fs_method_fanotify_rsvd_9 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_8 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_9 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_8 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_fanotify_init * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_init = (&__actvbridgecapcallhdlr_fshandler_fanotify_init)
	},
	[__fs_method_fanotify_init * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_fanotify_init = (&__actvbridgecapcallhdlr_fshandler_compat_fanotify_init)
	},
	[__fs_method_fanotify_mark * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_mark = (&__actvbridgecapcallhdlr_fshandler_fanotify_mark)
	},
	[__fs_method_fanotify_mark * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark = (&__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark)
	},
	[__fs_method_fanotify_mark_internal * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal = (&__actvbridgecapcallhdlr_fshandler_fanotify_mark_internal)
	},
	[__fs_method_fanotify_mark_internal * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark_internal = (&__actvbridgecapcallhdlr_fshandler_compat_fanotify_mark_internal)
	},
	[__fs_method_fanotify_rm_watch_internal * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal = (&__actvbridgecapcallhdlr_fshandler_fanotify_rm_watch_internal)
	},
	[__fs_method_fanotify_rm_watch_internal * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_fanotify_rm_watch_internal = (&__actvbridgecapcallhdlr_fshandler_compat_fanotify_rm_watch_internal)
	},
	[__fs_method_fanotify_notify * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_notify = (&__actvbridgecapcallhdlr_fshandler_fanotify_notify)
	},
	[__fs_method_fanotify_notify * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_fanotify_notify = (&__actvbridgecapcallhdlr_fshandler_compat_fanotify_notify)
	},
	[__fs_method_fanotify_destroyed * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_destroyed = (&__actvbridgecapcallhdlr_fshandler_fanotify_destroyed)
	},
	[__fs_method_fanotify_destroyed * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_fanotify_destroyed = (&__actvbridgecapcallhdlr_fshandler_compat_fanotify_destroyed)
	},
	[__fs_method_fanotify_open * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_fanotify_open = (&__actvbridgecapcallhdlr_fshandler_fanotify_open)
	},
	[__fs_method_fanotify_open * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_fanotify_open = (&__actvbridgecapcallhdlr_fshandler_compat_fanotify_open)
	},
	[__fs_method_endio_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_endio_io_done * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_endio_io_done = (&__actvbridgecapcallhdlr_fshandler_endio_io_done)
	},
	[__fs_method_endio_io_done * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_endio_io_done = (&__actvbridgecapcallhdlr_fshandler_compat_endio_io_done)
	},
	[__fs_method_sec_rsvd_8 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_8 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_sec_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_set_label * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_set_label = (&__actvbridgecapcallhdlr_fshandler_vfs_set_label)
	},
	[__fs_method_vfs_set_label * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label)
	},
	[__fs_method_vfs_set_label_by_path * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path = (&__actvbridgecapcallhdlr_fshandler_vfs_set_label_by_path)
	},
	[__fs_method_vfs_set_label_by_path * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label_by_path = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_set_label_by_path)
	},
	[__fs_method_vfs_get_label * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_label = (&__actvbridgecapcallhdlr_fshandler_vfs_get_label)
	},
	[__fs_method_vfs_get_label * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_label = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_label)
	},
	[__fs_method_vfs_init_audit * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_init_audit = (&__actvbridgecapcallhdlr_fshandler_vfs_init_audit)
	},
	[__fs_method_vfs_init_audit * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_audit = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_init_audit)
	},
	[__fs_method_vfs_add_audit_rule * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule = (&__actvbridgecapcallhdlr_fshandler_vfs_add_audit_rule)
	},
	[__fs_method_vfs_add_audit_rule * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_add_audit_rule = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_add_audit_rule)
	},
	[__fs_method_vfs_del_audit_rule * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule = (&__actvbridgecapcallhdlr_fshandler_vfs_del_audit_rule)
	},
	[__fs_method_vfs_del_audit_rule * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_del_audit_rule = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_del_audit_rule)
	},
	[__fs_method_vfs_match_audit_watch_file * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file = (&__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_file)
	},
	[__fs_method_vfs_match_audit_watch_file * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_file = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_file)
	},
	[__fs_method_vfs_match_audit_watch_dir * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir = (&__actvbridgecapcallhdlr_fshandler_vfs_match_audit_watch_dir)
	},
	[__fs_method_vfs_match_audit_watch_dir * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_dir = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_match_audit_watch_dir)
	},
	[__fs_method_vfs_rsvd_121 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_120 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_119 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_118 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_117 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_116 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_115 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_114 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_113 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_112 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_111 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_110 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_109 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_108 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_107 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_106 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_105 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_104 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_103 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_102 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_101 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_100 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_99 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_98 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_97 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_96 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_95 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_94 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_93 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_92 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_91 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_90 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_89 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_88 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_87 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_86 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_85 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_84 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_83 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_82 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_81 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_80 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_79 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_78 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_77 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_76 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_75 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_74 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_73 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_72 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_71 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_70 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_69 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_68 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_67 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_66 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_65 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_64 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_63 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_62 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_61 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_60 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_59 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_58 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_57 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_56 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_55 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_54 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_53 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_52 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_51 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_50 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_49 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_48 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_47 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_46 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_45 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_44 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_43 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_42 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_41 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_40 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_39 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_38 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_37 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_36 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_35 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_34 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_33 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_32 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_31 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_30 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_29 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_28 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_27 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_26 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_25 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_24 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_23 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_22 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_21 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_20 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_19 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_18 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_17 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_16 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_15 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_14 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_13 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_12 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_11 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_10 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_9 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_8 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_7 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_6 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_5 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_4 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_3 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_2 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_1 * 2] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_121 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_120 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_119 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_118 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_117 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_116 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_115 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_114 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_113 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_112 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_111 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_110 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_109 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_108 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_107 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_106 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_105 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_104 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_103 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_102 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_101 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_100 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_99 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_98 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_97 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_96 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_95 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_94 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_93 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_92 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_91 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_90 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_89 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_88 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_87 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_86 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_85 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_84 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_83 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_82 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_81 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_80 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_79 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_78 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_77 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_76 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_75 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_74 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_73 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_72 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_71 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_70 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_69 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_68 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_67 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_66 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_65 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_64 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_63 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_62 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_61 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_60 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_59 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_58 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_57 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_56 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_55 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_54 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_53 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_52 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_51 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_50 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_49 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_48 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_47 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_46 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_45 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_44 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_43 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_42 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_41 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_40 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_39 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_38 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_37 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_36 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_35 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_34 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_33 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_32 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_31 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_30 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_29 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_28 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_27 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_26 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_25 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_24 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_23 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_22 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_21 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_20 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_19 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_18 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_17 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_16 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_15 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_14 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_13 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_12 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_11 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_10 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_9 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_8 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_7 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_6 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_5 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_4 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_3 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_2 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_rsvd_1 * 2 + 1] = {
		.p_sysif_default_handler = (&sysif_actvhdlr_reserved_default_handler)
	},
	[__fs_method_vfs_client_init * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_client_init = (&__actvbridgecapcallhdlr_fshandler_vfs_client_init)
	},
	[__fs_method_vfs_client_init * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_client_init = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_client_init)
	},
	[__fs_method_vfs_bind_update * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_bind_update = (&__actvbridgecapcallhdlr_fshandler_vfs_bind_update)
	},
	[__fs_method_vfs_bind_update * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_bind_update = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_bind_update)
	},
	[__fs_method_vfs_clone * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_clone = (&__actvbridgecapcallhdlr_fshandler_vfs_clone)
	},
	[__fs_method_vfs_clone * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_clone)
	},
	[__fs_method_vfs_close * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_close = (&__actvbridgecapcallhdlr_fshandler_vfs_close)
	},
	[__fs_method_vfs_close * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_close = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_close)
	},
	[__fs_method_vfs_mount * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mount = (&__actvbridgecapcallhdlr_fshandler_vfs_mount)
	},
	[__fs_method_vfs_mount * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mount = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mount)
	},
	[__fs_method_vfs_clone_mount_entry * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry = (&__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry)
	},
	[__fs_method_vfs_clone_mount_entry * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry)
	},
	[__fs_method_vfs_clone_mount_entry_from_orig_parent * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent = (&__actvbridgecapcallhdlr_fshandler_vfs_clone_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_clone_mount_entry_from_orig_parent * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_clone_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent = (&__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry_from_orig_parent)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry = (&__actvbridgecapcallhdlr_fshandler_vfs_destroy_cloned_mount_entry)
	},
	[__fs_method_vfs_destroy_cloned_mount_entry * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_destroy_cloned_mount_entry)
	},
	[__fs_method_vfs_check_mount * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_check_mount = (&__actvbridgecapcallhdlr_fshandler_vfs_check_mount)
	},
	[__fs_method_vfs_check_mount * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_check_mount = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_check_mount)
	},
	[__fs_method_vfs_mountpoint_del_mount * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount = (&__actvbridgecapcallhdlr_fshandler_vfs_mountpoint_del_mount)
	},
	[__fs_method_vfs_mountpoint_del_mount * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mountpoint_del_mount = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mountpoint_del_mount)
	},
	[__fs_method_vfs_open * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_open = (&__actvbridgecapcallhdlr_fshandler_vfs_open)
	},
	[__fs_method_vfs_open * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_open = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_open)
	},
	[__fs_method_vfs_ftruncate * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_ftruncate = (&__actvbridgecapcallhdlr_fshandler_vfs_ftruncate)
	},
	[__fs_method_vfs_ftruncate * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_ftruncate = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_ftruncate)
	},
	[__fs_method_vfs_fstat * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fstat = (&__actvbridgecapcallhdlr_fshandler_vfs_fstat)
	},
	[__fs_method_vfs_fstat * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fstat = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fstat)
	},
	[__fs_method_vfs_stat * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_stat = (&__actvbridgecapcallhdlr_fshandler_vfs_stat)
	},
	[__fs_method_vfs_stat * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_stat = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_stat)
	},
	[__fs_method_vfs_statfs * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_statfs = (&__actvbridgecapcallhdlr_fshandler_vfs_statfs)
	},
	[__fs_method_vfs_statfs * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_statfs = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_statfs)
	},
	[__fs_method_vfs_fstatfs * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fstatfs = (&__actvbridgecapcallhdlr_fshandler_vfs_fstatfs)
	},
	[__fs_method_vfs_fstatfs * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fstatfs = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fstatfs)
	},
	[__fs_method_vfs_fsync * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fsync = (&__actvbridgecapcallhdlr_fshandler_vfs_fsync)
	},
	[__fs_method_vfs_fsync * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fsync = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fsync)
	},
	[__fs_method_vfs_unmount * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_unmount = (&__actvbridgecapcallhdlr_fshandler_vfs_unmount)
	},
	[__fs_method_vfs_unmount * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount)
	},
	[__fs_method_vfs_unmount_from_server * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server = (&__actvbridgecapcallhdlr_fshandler_vfs_unmount_from_server)
	},
	[__fs_method_vfs_unmount_from_server * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_from_server = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_from_server)
	},
	[__fs_method_vfs_unmount_child * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_unmount_child = (&__actvbridgecapcallhdlr_fshandler_vfs_unmount_child)
	},
	[__fs_method_vfs_unmount_child * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_child = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_unmount_child)
	},
	[__fs_method_vfs_truncate * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_truncate = (&__actvbridgecapcallhdlr_fshandler_vfs_truncate)
	},
	[__fs_method_vfs_truncate * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_truncate = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_truncate)
	},
	[__fs_method_vfs_fs_fork * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fs_fork = (&__actvbridgecapcallhdlr_fshandler_vfs_fs_fork)
	},
	[__fs_method_vfs_fs_fork * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fs_fork = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fs_fork)
	},
	[__fs_method_vfs_query_info * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_query_info = (&__actvbridgecapcallhdlr_fshandler_vfs_query_info)
	},
	[__fs_method_vfs_query_info * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_query_info = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_query_info)
	},
	[__fs_method_vfs_lseek * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_lseek = (&__actvbridgecapcallhdlr_fshandler_vfs_lseek)
	},
	[__fs_method_vfs_lseek * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_lseek = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_lseek)
	},
	[__fs_method_vfs_trans * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_trans = (&__actvbridgecapcallhdlr_fshandler_vfs_trans)
	},
	[__fs_method_vfs_trans * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_trans = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_trans)
	},
	[__fs_method_vfs_pipe2 * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_pipe2 = (&__actvbridgecapcallhdlr_fshandler_vfs_pipe2)
	},
	[__fs_method_vfs_pipe2 * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_pipe2 = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_pipe2)
	},
	[__fs_method_vfs_tee * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_tee = (&__actvbridgecapcallhdlr_fshandler_vfs_tee)
	},
	[__fs_method_vfs_tee * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_tee = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_tee)
	},
	[__fs_method_vfs_splice * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_splice = (&__actvbridgecapcallhdlr_fshandler_vfs_splice)
	},
	[__fs_method_vfs_splice * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_splice = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_splice)
	},
	[__fs_method_vfs_do_splice_srvs * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs = (&__actvbridgecapcallhdlr_fshandler_vfs_do_splice_srvs)
	},
	[__fs_method_vfs_do_splice_srvs * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_splice_srvs = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_do_splice_srvs)
	},
	[__fs_method_vfs_revoke_process * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_revoke_process = (&__actvbridgecapcallhdlr_fshandler_vfs_revoke_process)
	},
	[__fs_method_vfs_revoke_process * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_revoke_process = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_revoke_process)
	},
	[__fs_method_vfs_setrlimit * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_setrlimit = (&__actvbridgecapcallhdlr_fshandler_vfs_setrlimit)
	},
	[__fs_method_vfs_setrlimit * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_setrlimit = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_setrlimit)
	},
	[__fs_method_vfs_get_ns * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_ns = (&__actvbridgecapcallhdlr_fshandler_vfs_get_ns)
	},
	[__fs_method_vfs_get_ns * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_ns = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_ns)
	},
	[__fs_method_vfs_put_ns * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_put_ns = (&__actvbridgecapcallhdlr_fshandler_vfs_put_ns)
	},
	[__fs_method_vfs_put_ns * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_put_ns = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_put_ns)
	},
	[__fs_method_vfs_init_eventfd * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd = (&__actvbridgecapcallhdlr_fshandler_vfs_init_eventfd)
	},
	[__fs_method_vfs_init_eventfd * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_eventfd = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_init_eventfd)
	},
	[__fs_method_vfs_write_eventfd * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd = (&__actvbridgecapcallhdlr_fshandler_vfs_write_eventfd)
	},
	[__fs_method_vfs_write_eventfd * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_write_eventfd = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_write_eventfd)
	},
	[__fs_method_vfs_timerfd_create * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create = (&__actvbridgecapcallhdlr_fshandler_vfs_timerfd_create)
	},
	[__fs_method_vfs_timerfd_create * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_create = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_create)
	},
	[__fs_method_vfs_timerfd_settime * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime = (&__actvbridgecapcallhdlr_fshandler_vfs_timerfd_settime)
	},
	[__fs_method_vfs_timerfd_settime * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_settime = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_settime)
	},
	[__fs_method_vfs_timerfd_gettime * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime = (&__actvbridgecapcallhdlr_fshandler_vfs_timerfd_gettime)
	},
	[__fs_method_vfs_timerfd_gettime * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_gettime = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_timerfd_gettime)
	},
	[__fs_method_vfs_open_exec * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_open_exec = (&__actvbridgecapcallhdlr_fshandler_vfs_open_exec)
	},
	[__fs_method_vfs_open_exec * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_open_exec = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_open_exec)
	},
	[__fs_method_vfs_close_exec * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_close_exec = (&__actvbridgecapcallhdlr_fshandler_vfs_close_exec)
	},
	[__fs_method_vfs_close_exec * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_close_exec = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_close_exec)
	},
	[__fs_method_vfs_set_elf_file * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file = (&__actvbridgecapcallhdlr_fshandler_vfs_set_elf_file)
	},
	[__fs_method_vfs_set_elf_file * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_elf_file = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_set_elf_file)
	},
	[__fs_method_vfs_ioctl * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_ioctl = (&__actvbridgecapcallhdlr_fshandler_vfs_ioctl)
	},
	[__fs_method_vfs_ioctl * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_ioctl = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_ioctl)
	},
	[__fs_method_vfs_read * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_read = (&__actvbridgecapcallhdlr_fshandler_vfs_read)
	},
	[__fs_method_vfs_read * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_read = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_read)
	},
	[__fs_method_vfs_readv * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_readv = (&__actvbridgecapcallhdlr_fshandler_vfs_readv)
	},
	[__fs_method_vfs_readv * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_readv = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_readv)
	},
	[__fs_method_vfs_getcwd * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_getcwd = (&__actvbridgecapcallhdlr_fshandler_vfs_getcwd)
	},
	[__fs_method_vfs_getcwd * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_getcwd = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_getcwd)
	},
	[__fs_method_vfs_get_process_cwdrootexe * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe = (&__actvbridgecapcallhdlr_fshandler_vfs_get_process_cwdrootexe)
	},
	[__fs_method_vfs_get_process_cwdrootexe * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_process_cwdrootexe = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_process_cwdrootexe)
	},
	[__fs_method_vfs_readdir * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_readdir = (&__actvbridgecapcallhdlr_fshandler_vfs_readdir)
	},
	[__fs_method_vfs_readdir * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_readdir = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_readdir)
	},
	[__fs_method_vfs_write * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_write = (&__actvbridgecapcallhdlr_fshandler_vfs_write)
	},
	[__fs_method_vfs_write * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_write = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_write)
	},
	[__fs_method_vfs_writev * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_writev = (&__actvbridgecapcallhdlr_fshandler_vfs_writev)
	},
	[__fs_method_vfs_writev * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_writev = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_writev)
	},
	[__fs_method_vfs_sync * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_sync = (&__actvbridgecapcallhdlr_fshandler_vfs_sync)
	},
	[__fs_method_vfs_sync * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_sync = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_sync)
	},
	[__fs_method_vfs_do_sync * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_sync = (&__actvbridgecapcallhdlr_fshandler_vfs_do_sync)
	},
	[__fs_method_vfs_do_sync * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_sync = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_do_sync)
	},
	[__fs_method_vfs_utimensat * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_utimensat = (&__actvbridgecapcallhdlr_fshandler_vfs_utimensat)
	},
	[__fs_method_vfs_utimensat * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_utimensat = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_utimensat)
	},
	[__fs_method_vfs_futimens * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_futimens = (&__actvbridgecapcallhdlr_fshandler_vfs_futimens)
	},
	[__fs_method_vfs_futimens * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_futimens = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_futimens)
	},
	[__fs_method_vfs_fchmodat * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchmodat = (&__actvbridgecapcallhdlr_fshandler_vfs_fchmodat)
	},
	[__fs_method_vfs_fchmodat * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmodat = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmodat)
	},
	[__fs_method_vfs_fchmod * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchmod = (&__actvbridgecapcallhdlr_fshandler_vfs_fchmod)
	},
	[__fs_method_vfs_fchmod * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmod = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fchmod)
	},
	[__fs_method_vfs_drop_caches * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_drop_caches = (&__actvbridgecapcallhdlr_fshandler_vfs_drop_caches)
	},
	[__fs_method_vfs_drop_caches * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_drop_caches = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_drop_caches)
	},
	[__fs_method_vfs_do_drop_caches * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches = (&__actvbridgecapcallhdlr_fshandler_vfs_do_drop_caches)
	},
	[__fs_method_vfs_do_drop_caches * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_drop_caches = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_do_drop_caches)
	},
	[__fs_method_vfs_fadvise * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fadvise = (&__actvbridgecapcallhdlr_fshandler_vfs_fadvise)
	},
	[__fs_method_vfs_fadvise * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fadvise = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fadvise)
	},
	[__fs_method_vfs_readahead * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_readahead = (&__actvbridgecapcallhdlr_fshandler_vfs_readahead)
	},
	[__fs_method_vfs_readahead * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_readahead = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_readahead)
	},
	[__fs_method_vfs_get_fd_path * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path = (&__actvbridgecapcallhdlr_fshandler_vfs_get_fd_path)
	},
	[__fs_method_vfs_get_fd_path * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_fd_path = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_fd_path)
	},
	[__fs_method_vfs_sysmgr_get_fd_path * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path = (&__actvbridgecapcallhdlr_fshandler_vfs_sysmgr_get_fd_path)
	},
	[__fs_method_vfs_sysmgr_get_fd_path * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_sysmgr_get_fd_path = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_sysmgr_get_fd_path)
	},
	[__fs_method_vfs_fcntl * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fcntl = (&__actvbridgecapcallhdlr_fshandler_vfs_fcntl)
	},
	[__fs_method_vfs_fcntl * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fcntl = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fcntl)
	},
	[__fs_method_vfs_device_mounted * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_device_mounted = (&__actvbridgecapcallhdlr_fshandler_vfs_device_mounted)
	},
	[__fs_method_vfs_device_mounted * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_device_mounted = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_device_mounted)
	},
	[__fs_method_vfs_quotactl * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_quotactl = (&__actvbridgecapcallhdlr_fshandler_vfs_quotactl)
	},
	[__fs_method_vfs_quotactl * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_quotactl = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_quotactl)
	},
	[__fs_method_vfs_copy_file_range * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range = (&__actvbridgecapcallhdlr_fshandler_vfs_copy_file_range)
	},
	[__fs_method_vfs_copy_file_range * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_copy_file_range = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_copy_file_range)
	},
	[__fs_method_vfs_same_file * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_same_file = (&__actvbridgecapcallhdlr_fshandler_vfs_same_file)
	},
	[__fs_method_vfs_same_file * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_same_file = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_same_file)
	},
	[__fs_method_vfs_access * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_access = (&__actvbridgecapcallhdlr_fshandler_vfs_access)
	},
	[__fs_method_vfs_access * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_access = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_access)
	},
	[__fs_method_vfs_flock * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_flock = (&__actvbridgecapcallhdlr_fshandler_vfs_flock)
	},
	[__fs_method_vfs_flock * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_flock = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_flock)
	},
	[__fs_method_vfs_fchownat * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchownat = (&__actvbridgecapcallhdlr_fshandler_vfs_fchownat)
	},
	[__fs_method_vfs_fchownat * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchownat = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fchownat)
	},
	[__fs_method_vfs_fchown * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchown = (&__actvbridgecapcallhdlr_fshandler_vfs_fchown)
	},
	[__fs_method_vfs_fchown * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchown = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fchown)
	},
	[__fs_method_vfs_binderfs_mmap * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap = (&__actvbridgecapcallhdlr_fshandler_vfs_binderfs_mmap)
	},
	[__fs_method_vfs_binderfs_mmap * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_binderfs_mmap = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_binderfs_mmap)
	},
	[__fs_method_vfs_init_signalfd * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd = (&__actvbridgecapcallhdlr_fshandler_vfs_init_signalfd)
	},
	[__fs_method_vfs_init_signalfd * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_init_signalfd = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_init_signalfd)
	},
	[__fs_method_vfs_epoll_ctl * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl = (&__actvbridgecapcallhdlr_fshandler_vfs_epoll_ctl)
	},
	[__fs_method_vfs_epoll_ctl * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_ctl = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_ctl)
	},
	[__fs_method_vfs_epoll_et_revents * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents = (&__actvbridgecapcallhdlr_fshandler_vfs_epoll_et_revents)
	},
	[__fs_method_vfs_epoll_et_revents * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_et_revents = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_et_revents)
	},
	[__fs_method_vfs_epoll_reinit * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit = (&__actvbridgecapcallhdlr_fshandler_vfs_epoll_reinit)
	},
	[__fs_method_vfs_epoll_reinit * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_reinit = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_epoll_reinit)
	},
	[__fs_method_vfs_signalfd_notify * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify = (&__actvbridgecapcallhdlr_fshandler_vfs_signalfd_notify)
	},
	[__fs_method_vfs_signalfd_notify * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_signalfd_notify = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_signalfd_notify)
	},
	[__fs_method_vfs_pid_io_stats * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats = (&__actvbridgecapcallhdlr_fshandler_vfs_pid_io_stats)
	},
	[__fs_method_vfs_pid_io_stats * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_pid_io_stats = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_pid_io_stats)
	},
	[__fs_method_vfs_fallocate * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fallocate = (&__actvbridgecapcallhdlr_fshandler_vfs_fallocate)
	},
	[__fs_method_vfs_fallocate * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fallocate = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fallocate)
	},
	[__fs_method_vfs_set_cwdroot * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot = (&__actvbridgecapcallhdlr_fshandler_vfs_set_cwdroot)
	},
	[__fs_method_vfs_set_cwdroot * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_set_cwdroot = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_set_cwdroot)
	},
	[__fs_method_vfs_fchdir * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fchdir = (&__actvbridgecapcallhdlr_fshandler_vfs_fchdir)
	},
	[__fs_method_vfs_fchdir * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fchdir = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fchdir)
	},
	[__fs_method_vfs_disable_cwdroot * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot = (&__actvbridgecapcallhdlr_fshandler_vfs_disable_cwdroot)
	},
	[__fs_method_vfs_disable_cwdroot * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_disable_cwdroot = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_disable_cwdroot)
	},
	[__fs_method_vfs_update_cwdroot * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot = (&__actvbridgecapcallhdlr_fshandler_vfs_update_cwdroot)
	},
	[__fs_method_vfs_update_cwdroot * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_update_cwdroot = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_update_cwdroot)
	},
	[__fs_method_vfs_handle_global_locks * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks = (&__actvbridgecapcallhdlr_fshandler_vfs_handle_global_locks)
	},
	[__fs_method_vfs_handle_global_locks * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_handle_global_locks = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_handle_global_locks)
	},
	[__fs_method_vfs_send_fd * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_send_fd = (&__actvbridgecapcallhdlr_fshandler_vfs_send_fd)
	},
	[__fs_method_vfs_send_fd * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_send_fd = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_send_fd)
	},
	[__fs_method_vfs_recv_fd * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_recv_fd = (&__actvbridgecapcallhdlr_fshandler_vfs_recv_fd)
	},
	[__fs_method_vfs_recv_fd * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_recv_fd = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_recv_fd)
	},
	[__fs_method_vfs_get_buffer_wrapper * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper = (&__actvbridgecapcallhdlr_fshandler_vfs_get_buffer_wrapper)
	},
	[__fs_method_vfs_get_buffer_wrapper * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_buffer_wrapper = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_buffer_wrapper)
	},
	[__fs_method_vfs_get_pathname_by_me_idx * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx = (&__actvbridgecapcallhdlr_fshandler_vfs_get_pathname_by_me_idx)
	},
	[__fs_method_vfs_get_pathname_by_me_idx * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_pathname_by_me_idx = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_pathname_by_me_idx)
	},
	[__fs_method_vfs_sfile_put * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_sfile_put = (&__actvbridgecapcallhdlr_fshandler_vfs_sfile_put)
	},
	[__fs_method_vfs_sfile_put * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_sfile_put = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_sfile_put)
	},
	[__fs_method_vfs_readlinkat * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_readlinkat = (&__actvbridgecapcallhdlr_fshandler_vfs_readlinkat)
	},
	[__fs_method_vfs_readlinkat * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_readlinkat = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_readlinkat)
	},
	[__fs_method_vfs_get_slabinfo * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo = (&__actvbridgecapcallhdlr_fshandler_vfs_get_slabinfo)
	},
	[__fs_method_vfs_get_slabinfo * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_slabinfo = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_slabinfo)
	},
	[__fs_method_vfs_do_get_slabinfo * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo = (&__actvbridgecapcallhdlr_fshandler_vfs_do_get_slabinfo)
	},
	[__fs_method_vfs_do_get_slabinfo * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_get_slabinfo = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_do_get_slabinfo)
	},
	[__fs_method_vfs_fscache_print_info * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info = (&__actvbridgecapcallhdlr_fshandler_vfs_fscache_print_info)
	},
	[__fs_method_vfs_fscache_print_info * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fscache_print_info = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fscache_print_info)
	},
	[__fs_method_vfs_alloc_fs_handle_for_same_device * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device = (&__actvbridgecapcallhdlr_fshandler_vfs_alloc_fs_handle_for_same_device)
	},
	[__fs_method_vfs_alloc_fs_handle_for_same_device * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_alloc_fs_handle_for_same_device)
	},
	[__fs_method_vfs_free_fs_handle_for_same_device * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device = (&__actvbridgecapcallhdlr_fshandler_vfs_free_fs_handle_for_same_device)
	},
	[__fs_method_vfs_free_fs_handle_for_same_device * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_free_fs_handle_for_same_device = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_free_fs_handle_for_same_device)
	},
	[__fs_method_vfs_memfd_create * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_memfd_create = (&__actvbridgecapcallhdlr_fshandler_vfs_memfd_create)
	},
	[__fs_method_vfs_memfd_create * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_memfd_create = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_memfd_create)
	},
	[__fs_method_vfs_mknod * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mknod = (&__actvbridgecapcallhdlr_fshandler_vfs_mknod)
	},
	[__fs_method_vfs_mknod * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mknod = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mknod)
	},
	[__fs_method_vfs_rename * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_rename = (&__actvbridgecapcallhdlr_fshandler_vfs_rename)
	},
	[__fs_method_vfs_rename * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_rename = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_rename)
	},
	[__fs_method_vfs_mkdirat * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mkdirat = (&__actvbridgecapcallhdlr_fshandler_vfs_mkdirat)
	},
	[__fs_method_vfs_mkdirat * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mkdirat = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mkdirat)
	},
	[__fs_method_vfs_link * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_link = (&__actvbridgecapcallhdlr_fshandler_vfs_link)
	},
	[__fs_method_vfs_link * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_link = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_link)
	},
	[__fs_method_vfs_unlink * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_unlink = (&__actvbridgecapcallhdlr_fshandler_vfs_unlink)
	},
	[__fs_method_vfs_unlink * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_unlink = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_unlink)
	},
	[__fs_method_vfs_symlink * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_symlink = (&__actvbridgecapcallhdlr_fshandler_vfs_symlink)
	},
	[__fs_method_vfs_symlink * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_symlink = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_symlink)
	},
	[__fs_method_vfs_getxattr * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_getxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_getxattr)
	},
	[__fs_method_vfs_getxattr * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_getxattr = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_getxattr)
	},
	[__fs_method_vfs_fgetxattr * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_fgetxattr)
	},
	[__fs_method_vfs_fgetxattr * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fgetxattr = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fgetxattr)
	},
	[__fs_method_vfs_setxattr * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_setxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_setxattr)
	},
	[__fs_method_vfs_setxattr * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_setxattr = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_setxattr)
	},
	[__fs_method_vfs_fsetxattr * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_fsetxattr)
	},
	[__fs_method_vfs_fsetxattr * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fsetxattr = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fsetxattr)
	},
	[__fs_method_vfs_listxattr * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_listxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_listxattr)
	},
	[__fs_method_vfs_listxattr * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_listxattr = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_listxattr)
	},
	[__fs_method_vfs_flistxattr * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_flistxattr = (&__actvbridgecapcallhdlr_fshandler_vfs_flistxattr)
	},
	[__fs_method_vfs_flistxattr * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_flistxattr = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_flistxattr)
	},
	[__fs_method_vfs_removexattr * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_removexattr = (&__actvbridgecapcallhdlr_fshandler_vfs_removexattr)
	},
	[__fs_method_vfs_removexattr * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_removexattr = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_removexattr)
	},
	[__fs_method_vfs_fremovexattr * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr = (&__actvbridgecapcallhdlr_fshandler_vfs_fremovexattr)
	},
	[__fs_method_vfs_fremovexattr * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fremovexattr = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fremovexattr)
	},
	[__fs_method_vfs_iommap * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_iommap = (&__actvbridgecapcallhdlr_fshandler_vfs_iommap)
	},
	[__fs_method_vfs_iommap * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_iommap = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_iommap)
	},
	[__fs_method_vfs_mmap_create * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_create = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_create)
	},
	[__fs_method_vfs_mmap_create * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_create = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_create)
	},
	[__fs_method_vfs_mmap_release_file * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_release_file)
	},
	[__fs_method_vfs_mmap_release_file * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_release_file = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_release_file)
	},
	[__fs_method_vfs_mmap_change * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_change)
	},
	[__fs_method_vfs_mmap_change * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change)
	},
	[__fs_method_vfs_mmap_fill_page * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_fill_page)
	},
	[__fs_method_vfs_mmap_fill_page * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fill_page = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fill_page)
	},
	[__fs_method_vfs_mmap_fetch_page * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_fetch_page)
	},
	[__fs_method_vfs_mmap_fetch_page * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fetch_page = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fetch_page)
	},
	[__fs_method_vfs_mmap_change_page * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_change_page)
	},
	[__fs_method_vfs_mmap_change_page * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change_page = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_change_page)
	},
	[__fs_method_vfs_mmap_fallocate * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate = (&__actvbridgecapcallhdlr_fshandler_vfs_mmap_fallocate)
	},
	[__fs_method_vfs_mmap_fallocate * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fallocate = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_mmap_fallocate)
	},
	[__fs_method_vfs_gfd_table_update * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_update)
	},
	[__fs_method_vfs_gfd_table_update * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_update = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_update)
	},
	[__fs_method_vfs_gfd_table_remove * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_remove)
	},
	[__fs_method_vfs_gfd_table_remove * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_remove = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_remove)
	},
	[__fs_method_vfs_gfd_table_expand * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_expand)
	},
	[__fs_method_vfs_gfd_table_expand * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_expand = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_expand)
	},
	[__fs_method_vfs_gfd_table_acquire * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_acquire)
	},
	[__fs_method_vfs_gfd_table_acquire * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_acquire = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_acquire)
	},
	[__fs_method_vfs_gfd_table_release * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_release)
	},
	[__fs_method_vfs_gfd_table_release * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_release = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_release)
	},
	[__fs_method_vfs_gfd_table_replace * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_replace)
	},
	[__fs_method_vfs_gfd_table_replace * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_replace = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_replace)
	},
	[__fs_method_vfs_gfd_table_fault * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault = (&__actvbridgecapcallhdlr_fshandler_vfs_gfd_table_fault)
	},
	[__fs_method_vfs_gfd_table_fault * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_fault = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_gfd_table_fault)
	},
	[__fs_method_vfs_anon_register_devhost * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost = (&__actvbridgecapcallhdlr_fshandler_vfs_anon_register_devhost)
	},
	[__fs_method_vfs_anon_register_devhost * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_anon_register_devhost = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_anon_register_devhost)
	},
	[__fs_method_vfs_get_unused_fd * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd = (&__actvbridgecapcallhdlr_fshandler_vfs_get_unused_fd)
	},
	[__fs_method_vfs_get_unused_fd * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_unused_fd = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_unused_fd)
	},
	[__fs_method_vfs_put_unused_fd * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd = (&__actvbridgecapcallhdlr_fshandler_vfs_put_unused_fd)
	},
	[__fs_method_vfs_put_unused_fd * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_put_unused_fd = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_put_unused_fd)
	},
	[__fs_method_vfs_fd_info_update * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update = (&__actvbridgecapcallhdlr_fshandler_vfs_fd_info_update)
	},
	[__fs_method_vfs_fd_info_update * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_fd_info_update = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_fd_info_update)
	},
	[__fs_method_vfs_get_root_path * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_get_root_path = (&__actvbridgecapcallhdlr_fshandler_vfs_get_root_path)
	},
	[__fs_method_vfs_get_root_path * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_get_root_path = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_get_root_path)
	},
	[__fs_method_vfs_transfs_fget * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget = (&__actvbridgecapcallhdlr_fshandler_vfs_transfs_fget)
	},
	[__fs_method_vfs_transfs_fget * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fget = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fget)
	},
	[__fs_method_vfs_do_trans_fget * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget = (&__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fget)
	},
	[__fs_method_vfs_do_trans_fget * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fget = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fget)
	},
	[__fs_method_vfs_transfs_fput * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput = (&__actvbridgecapcallhdlr_fshandler_vfs_transfs_fput)
	},
	[__fs_method_vfs_transfs_fput * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fput = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_transfs_fput)
	},
	[__fs_method_vfs_do_trans_fput * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput = (&__actvbridgecapcallhdlr_fshandler_vfs_do_trans_fput)
	},
	[__fs_method_vfs_do_trans_fput * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fput = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_do_trans_fput)
	},
	[__fs_method_vfs_read_mounts * 2] = {
		.p__actvbridgecapcallhdlr_fshandler_vfs_read_mounts = (&__actvbridgecapcallhdlr_fshandler_vfs_read_mounts)
	},
	[__fs_method_vfs_read_mounts * 2 + 1] = {
		.p__actvbridgecapcallhdlr_fshandler_compat_vfs_read_mounts = (&__actvbridgecapcallhdlr_fshandler_compat_vfs_read_mounts)
	}
};

#endif
void sysif_show_fs_methods(void)
{
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "procfs", "create_data", __fs_method_procfs_create_data);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "procfs", "create_data", __fs_method_procfs_create_data);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "procfs", "delete_data", __fs_method_procfs_delete_data);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "procfs", "delete_data", __fs_method_procfs_delete_data);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "procfs", "get_process_fds", __fs_method_procfs_get_process_fds);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "procfs", "get_process_fds", __fs_method_procfs_get_process_fds);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "procfs", "get_fd_mode", __fs_method_procfs_get_fd_mode);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "procfs", "get_fd_mode", __fs_method_procfs_get_fd_mode);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "sysfs", "create_file", __fs_method_sysfs_create_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "sysfs", "create_file", __fs_method_sysfs_create_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "sysfs", "create_dir", __fs_method_sysfs_create_dir);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "sysfs", "create_dir", __fs_method_sysfs_create_dir);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "sysfs", "create_symlink", __fs_method_sysfs_create_symlink);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "sysfs", "create_symlink", __fs_method_sysfs_create_symlink);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "sysfs", "delete", __fs_method_sysfs_delete);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "sysfs", "delete", __fs_method_sysfs_delete);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "sysfs", "notify", __fs_method_sysfs_notify);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "sysfs", "notify", __fs_method_sysfs_notify);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "clock", "settime", __fs_method_clock_settime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "clock", "settime", __fs_method_clock_settime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "clock", "gettime", __fs_method_clock_gettime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "clock", "gettime", __fs_method_clock_gettime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "clock", "getres", __fs_method_clock_getres);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "clock", "getres", __fs_method_clock_getres);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "clock", "adjtime", __fs_method_clock_adjtime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "clock", "adjtime", __fs_method_clock_adjtime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "inotify", "init1", __fs_method_inotify_init1);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "inotify", "init1", __fs_method_inotify_init1);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "inotify", "add_watch", __fs_method_inotify_add_watch);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "inotify", "add_watch", __fs_method_inotify_add_watch);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "inotify", "rm_watch", __fs_method_inotify_rm_watch);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "inotify", "rm_watch", __fs_method_inotify_rm_watch);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "inotify", "add_watch_internal", __fs_method_inotify_add_watch_internal);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "inotify", "add_watch_internal", __fs_method_inotify_add_watch_internal);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "inotify", "rm_watch_internal", __fs_method_inotify_rm_watch_internal);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "inotify", "rm_watch_internal", __fs_method_inotify_rm_watch_internal);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "inotify", "notify", __fs_method_inotify_notify);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "inotify", "notify", __fs_method_inotify_notify);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "inotify", "inode_destroyed", __fs_method_inotify_inode_destroyed);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "inotify", "inode_destroyed", __fs_method_inotify_inode_destroyed);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "fanotify", "init", __fs_method_fanotify_init);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "fanotify", "init", __fs_method_fanotify_init);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "fanotify", "mark", __fs_method_fanotify_mark);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "fanotify", "mark", __fs_method_fanotify_mark);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "fanotify", "mark_internal", __fs_method_fanotify_mark_internal);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "fanotify", "mark_internal", __fs_method_fanotify_mark_internal);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "fanotify", "rm_watch_internal", __fs_method_fanotify_rm_watch_internal);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "fanotify", "rm_watch_internal", __fs_method_fanotify_rm_watch_internal);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "fanotify", "notify", __fs_method_fanotify_notify);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "fanotify", "notify", __fs_method_fanotify_notify);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "fanotify", "destroyed", __fs_method_fanotify_destroyed);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "fanotify", "destroyed", __fs_method_fanotify_destroyed);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "fanotify", "open", __fs_method_fanotify_open);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "fanotify", "open", __fs_method_fanotify_open);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "endio", "io_done", __fs_method_endio_io_done);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "endio", "io_done", __fs_method_endio_io_done);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "set_label", __fs_method_vfs_set_label);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "set_label", __fs_method_vfs_set_label);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "set_label_by_path", __fs_method_vfs_set_label_by_path);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "set_label_by_path", __fs_method_vfs_set_label_by_path);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_label", __fs_method_vfs_get_label);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_label", __fs_method_vfs_get_label);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "init_audit", __fs_method_vfs_init_audit);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "init_audit", __fs_method_vfs_init_audit);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "add_audit_rule", __fs_method_vfs_add_audit_rule);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "add_audit_rule", __fs_method_vfs_add_audit_rule);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "del_audit_rule", __fs_method_vfs_del_audit_rule);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "del_audit_rule", __fs_method_vfs_del_audit_rule);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "match_audit_watch_file", __fs_method_vfs_match_audit_watch_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "match_audit_watch_file", __fs_method_vfs_match_audit_watch_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "match_audit_watch_dir", __fs_method_vfs_match_audit_watch_dir);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "match_audit_watch_dir", __fs_method_vfs_match_audit_watch_dir);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "client_init", __fs_method_vfs_client_init);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "client_init", __fs_method_vfs_client_init);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "bind_update", __fs_method_vfs_bind_update);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "bind_update", __fs_method_vfs_bind_update);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "clone", __fs_method_vfs_clone);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "clone", __fs_method_vfs_clone);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "close", __fs_method_vfs_close);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "close", __fs_method_vfs_close);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mount", __fs_method_vfs_mount);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mount", __fs_method_vfs_mount);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "clone_mount_entry", __fs_method_vfs_clone_mount_entry);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "clone_mount_entry", __fs_method_vfs_clone_mount_entry);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "clone_mount_entry_from_orig_parent", __fs_method_vfs_clone_mount_entry_from_orig_parent);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "clone_mount_entry_from_orig_parent", __fs_method_vfs_clone_mount_entry_from_orig_parent);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "destroy_cloned_mount_entry_from_orig_parent", __fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "destroy_cloned_mount_entry_from_orig_parent", __fs_method_vfs_destroy_cloned_mount_entry_from_orig_parent);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "destroy_cloned_mount_entry", __fs_method_vfs_destroy_cloned_mount_entry);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "destroy_cloned_mount_entry", __fs_method_vfs_destroy_cloned_mount_entry);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "check_mount", __fs_method_vfs_check_mount);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "check_mount", __fs_method_vfs_check_mount);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mountpoint_del_mount", __fs_method_vfs_mountpoint_del_mount);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mountpoint_del_mount", __fs_method_vfs_mountpoint_del_mount);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "open", __fs_method_vfs_open);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "open", __fs_method_vfs_open);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "ftruncate", __fs_method_vfs_ftruncate);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "ftruncate", __fs_method_vfs_ftruncate);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fstat", __fs_method_vfs_fstat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fstat", __fs_method_vfs_fstat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "stat", __fs_method_vfs_stat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "stat", __fs_method_vfs_stat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "statfs", __fs_method_vfs_statfs);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "statfs", __fs_method_vfs_statfs);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fstatfs", __fs_method_vfs_fstatfs);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fstatfs", __fs_method_vfs_fstatfs);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fsync", __fs_method_vfs_fsync);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fsync", __fs_method_vfs_fsync);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "unmount", __fs_method_vfs_unmount);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "unmount", __fs_method_vfs_unmount);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "unmount_from_server", __fs_method_vfs_unmount_from_server);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "unmount_from_server", __fs_method_vfs_unmount_from_server);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "unmount_child", __fs_method_vfs_unmount_child);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "unmount_child", __fs_method_vfs_unmount_child);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "truncate", __fs_method_vfs_truncate);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "truncate", __fs_method_vfs_truncate);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fs_fork", __fs_method_vfs_fs_fork);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fs_fork", __fs_method_vfs_fs_fork);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "query_info", __fs_method_vfs_query_info);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "query_info", __fs_method_vfs_query_info);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "lseek", __fs_method_vfs_lseek);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "lseek", __fs_method_vfs_lseek);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "trans", __fs_method_vfs_trans);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "trans", __fs_method_vfs_trans);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "pipe2", __fs_method_vfs_pipe2);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "pipe2", __fs_method_vfs_pipe2);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "tee", __fs_method_vfs_tee);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "tee", __fs_method_vfs_tee);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "splice", __fs_method_vfs_splice);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "splice", __fs_method_vfs_splice);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "do_splice_srvs", __fs_method_vfs_do_splice_srvs);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "do_splice_srvs", __fs_method_vfs_do_splice_srvs);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "revoke_process", __fs_method_vfs_revoke_process);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "revoke_process", __fs_method_vfs_revoke_process);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "setrlimit", __fs_method_vfs_setrlimit);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "setrlimit", __fs_method_vfs_setrlimit);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_ns", __fs_method_vfs_get_ns);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_ns", __fs_method_vfs_get_ns);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "put_ns", __fs_method_vfs_put_ns);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "put_ns", __fs_method_vfs_put_ns);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "init_eventfd", __fs_method_vfs_init_eventfd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "init_eventfd", __fs_method_vfs_init_eventfd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "write_eventfd", __fs_method_vfs_write_eventfd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "write_eventfd", __fs_method_vfs_write_eventfd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "timerfd_create", __fs_method_vfs_timerfd_create);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "timerfd_create", __fs_method_vfs_timerfd_create);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "timerfd_settime", __fs_method_vfs_timerfd_settime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "timerfd_settime", __fs_method_vfs_timerfd_settime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "timerfd_gettime", __fs_method_vfs_timerfd_gettime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "timerfd_gettime", __fs_method_vfs_timerfd_gettime);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "open_exec", __fs_method_vfs_open_exec);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "open_exec", __fs_method_vfs_open_exec);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "close_exec", __fs_method_vfs_close_exec);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "close_exec", __fs_method_vfs_close_exec);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "set_elf_file", __fs_method_vfs_set_elf_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "set_elf_file", __fs_method_vfs_set_elf_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "ioctl", __fs_method_vfs_ioctl);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "ioctl", __fs_method_vfs_ioctl);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "read", __fs_method_vfs_read);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "read", __fs_method_vfs_read);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "readv", __fs_method_vfs_readv);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "readv", __fs_method_vfs_readv);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "getcwd", __fs_method_vfs_getcwd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "getcwd", __fs_method_vfs_getcwd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_process_cwdrootexe", __fs_method_vfs_get_process_cwdrootexe);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_process_cwdrootexe", __fs_method_vfs_get_process_cwdrootexe);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "readdir", __fs_method_vfs_readdir);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "readdir", __fs_method_vfs_readdir);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "write", __fs_method_vfs_write);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "write", __fs_method_vfs_write);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "writev", __fs_method_vfs_writev);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "writev", __fs_method_vfs_writev);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "sync", __fs_method_vfs_sync);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "sync", __fs_method_vfs_sync);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "do_sync", __fs_method_vfs_do_sync);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "do_sync", __fs_method_vfs_do_sync);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "utimensat", __fs_method_vfs_utimensat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "utimensat", __fs_method_vfs_utimensat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "futimens", __fs_method_vfs_futimens);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "futimens", __fs_method_vfs_futimens);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fchmodat", __fs_method_vfs_fchmodat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fchmodat", __fs_method_vfs_fchmodat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fchmod", __fs_method_vfs_fchmod);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fchmod", __fs_method_vfs_fchmod);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "drop_caches", __fs_method_vfs_drop_caches);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "drop_caches", __fs_method_vfs_drop_caches);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "do_drop_caches", __fs_method_vfs_do_drop_caches);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "do_drop_caches", __fs_method_vfs_do_drop_caches);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fadvise", __fs_method_vfs_fadvise);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fadvise", __fs_method_vfs_fadvise);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "readahead", __fs_method_vfs_readahead);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "readahead", __fs_method_vfs_readahead);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_fd_path", __fs_method_vfs_get_fd_path);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_fd_path", __fs_method_vfs_get_fd_path);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "sysmgr_get_fd_path", __fs_method_vfs_sysmgr_get_fd_path);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "sysmgr_get_fd_path", __fs_method_vfs_sysmgr_get_fd_path);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fcntl", __fs_method_vfs_fcntl);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fcntl", __fs_method_vfs_fcntl);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "device_mounted", __fs_method_vfs_device_mounted);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "device_mounted", __fs_method_vfs_device_mounted);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "quotactl", __fs_method_vfs_quotactl);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "quotactl", __fs_method_vfs_quotactl);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "copy_file_range", __fs_method_vfs_copy_file_range);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "copy_file_range", __fs_method_vfs_copy_file_range);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "same_file", __fs_method_vfs_same_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "same_file", __fs_method_vfs_same_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "access", __fs_method_vfs_access);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "access", __fs_method_vfs_access);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "flock", __fs_method_vfs_flock);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "flock", __fs_method_vfs_flock);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fchownat", __fs_method_vfs_fchownat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fchownat", __fs_method_vfs_fchownat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fchown", __fs_method_vfs_fchown);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fchown", __fs_method_vfs_fchown);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "binderfs_mmap", __fs_method_vfs_binderfs_mmap);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "binderfs_mmap", __fs_method_vfs_binderfs_mmap);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "init_signalfd", __fs_method_vfs_init_signalfd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "init_signalfd", __fs_method_vfs_init_signalfd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "epoll_ctl", __fs_method_vfs_epoll_ctl);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "epoll_ctl", __fs_method_vfs_epoll_ctl);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "epoll_et_revents", __fs_method_vfs_epoll_et_revents);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "epoll_et_revents", __fs_method_vfs_epoll_et_revents);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "epoll_reinit", __fs_method_vfs_epoll_reinit);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "epoll_reinit", __fs_method_vfs_epoll_reinit);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "signalfd_notify", __fs_method_vfs_signalfd_notify);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "signalfd_notify", __fs_method_vfs_signalfd_notify);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "pid_io_stats", __fs_method_vfs_pid_io_stats);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "pid_io_stats", __fs_method_vfs_pid_io_stats);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fallocate", __fs_method_vfs_fallocate);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fallocate", __fs_method_vfs_fallocate);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "set_cwdroot", __fs_method_vfs_set_cwdroot);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "set_cwdroot", __fs_method_vfs_set_cwdroot);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fchdir", __fs_method_vfs_fchdir);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fchdir", __fs_method_vfs_fchdir);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "disable_cwdroot", __fs_method_vfs_disable_cwdroot);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "disable_cwdroot", __fs_method_vfs_disable_cwdroot);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "update_cwdroot", __fs_method_vfs_update_cwdroot);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "update_cwdroot", __fs_method_vfs_update_cwdroot);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "handle_global_locks", __fs_method_vfs_handle_global_locks);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "handle_global_locks", __fs_method_vfs_handle_global_locks);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "send_fd", __fs_method_vfs_send_fd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "send_fd", __fs_method_vfs_send_fd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "recv_fd", __fs_method_vfs_recv_fd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "recv_fd", __fs_method_vfs_recv_fd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_buffer_wrapper", __fs_method_vfs_get_buffer_wrapper);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_buffer_wrapper", __fs_method_vfs_get_buffer_wrapper);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_pathname_by_me_idx", __fs_method_vfs_get_pathname_by_me_idx);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_pathname_by_me_idx", __fs_method_vfs_get_pathname_by_me_idx);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "sfile_put", __fs_method_vfs_sfile_put);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "sfile_put", __fs_method_vfs_sfile_put);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "readlinkat", __fs_method_vfs_readlinkat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "readlinkat", __fs_method_vfs_readlinkat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_slabinfo", __fs_method_vfs_get_slabinfo);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_slabinfo", __fs_method_vfs_get_slabinfo);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "do_get_slabinfo", __fs_method_vfs_do_get_slabinfo);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "do_get_slabinfo", __fs_method_vfs_do_get_slabinfo);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fscache_print_info", __fs_method_vfs_fscache_print_info);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fscache_print_info", __fs_method_vfs_fscache_print_info);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "alloc_fs_handle_for_same_device", __fs_method_vfs_alloc_fs_handle_for_same_device);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "alloc_fs_handle_for_same_device", __fs_method_vfs_alloc_fs_handle_for_same_device);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "free_fs_handle_for_same_device", __fs_method_vfs_free_fs_handle_for_same_device);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "free_fs_handle_for_same_device", __fs_method_vfs_free_fs_handle_for_same_device);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "memfd_create", __fs_method_vfs_memfd_create);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "memfd_create", __fs_method_vfs_memfd_create);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mknod", __fs_method_vfs_mknod);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mknod", __fs_method_vfs_mknod);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "rename", __fs_method_vfs_rename);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "rename", __fs_method_vfs_rename);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mkdirat", __fs_method_vfs_mkdirat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mkdirat", __fs_method_vfs_mkdirat);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "link", __fs_method_vfs_link);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "link", __fs_method_vfs_link);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "unlink", __fs_method_vfs_unlink);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "unlink", __fs_method_vfs_unlink);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "symlink", __fs_method_vfs_symlink);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "symlink", __fs_method_vfs_symlink);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "getxattr", __fs_method_vfs_getxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "getxattr", __fs_method_vfs_getxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fgetxattr", __fs_method_vfs_fgetxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fgetxattr", __fs_method_vfs_fgetxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "setxattr", __fs_method_vfs_setxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "setxattr", __fs_method_vfs_setxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fsetxattr", __fs_method_vfs_fsetxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fsetxattr", __fs_method_vfs_fsetxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "listxattr", __fs_method_vfs_listxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "listxattr", __fs_method_vfs_listxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "flistxattr", __fs_method_vfs_flistxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "flistxattr", __fs_method_vfs_flistxattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "removexattr", __fs_method_vfs_removexattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "removexattr", __fs_method_vfs_removexattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fremovexattr", __fs_method_vfs_fremovexattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fremovexattr", __fs_method_vfs_fremovexattr);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "iommap", __fs_method_vfs_iommap);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "iommap", __fs_method_vfs_iommap);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mmap_create", __fs_method_vfs_mmap_create);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mmap_create", __fs_method_vfs_mmap_create);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mmap_release_file", __fs_method_vfs_mmap_release_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mmap_release_file", __fs_method_vfs_mmap_release_file);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mmap_change", __fs_method_vfs_mmap_change);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mmap_change", __fs_method_vfs_mmap_change);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mmap_fill_page", __fs_method_vfs_mmap_fill_page);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mmap_fill_page", __fs_method_vfs_mmap_fill_page);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mmap_fetch_page", __fs_method_vfs_mmap_fetch_page);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mmap_fetch_page", __fs_method_vfs_mmap_fetch_page);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mmap_change_page", __fs_method_vfs_mmap_change_page);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mmap_change_page", __fs_method_vfs_mmap_change_page);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "mmap_fallocate", __fs_method_vfs_mmap_fallocate);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "mmap_fallocate", __fs_method_vfs_mmap_fallocate);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "gfd_table_update", __fs_method_vfs_gfd_table_update);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "gfd_table_update", __fs_method_vfs_gfd_table_update);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "gfd_table_remove", __fs_method_vfs_gfd_table_remove);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "gfd_table_remove", __fs_method_vfs_gfd_table_remove);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "gfd_table_expand", __fs_method_vfs_gfd_table_expand);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "gfd_table_expand", __fs_method_vfs_gfd_table_expand);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "gfd_table_acquire", __fs_method_vfs_gfd_table_acquire);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "gfd_table_acquire", __fs_method_vfs_gfd_table_acquire);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "gfd_table_release", __fs_method_vfs_gfd_table_release);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "gfd_table_release", __fs_method_vfs_gfd_table_release);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "gfd_table_replace", __fs_method_vfs_gfd_table_replace);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "gfd_table_replace", __fs_method_vfs_gfd_table_replace);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "gfd_table_fault", __fs_method_vfs_gfd_table_fault);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "gfd_table_fault", __fs_method_vfs_gfd_table_fault);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "anon_register_devhost", __fs_method_vfs_anon_register_devhost);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "anon_register_devhost", __fs_method_vfs_anon_register_devhost);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_unused_fd", __fs_method_vfs_get_unused_fd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_unused_fd", __fs_method_vfs_get_unused_fd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "put_unused_fd", __fs_method_vfs_put_unused_fd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "put_unused_fd", __fs_method_vfs_put_unused_fd);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "fd_info_update", __fs_method_vfs_fd_info_update);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "fd_info_update", __fs_method_vfs_fd_info_update);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "get_root_path", __fs_method_vfs_get_root_path);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "get_root_path", __fs_method_vfs_get_root_path);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "transfs_fget", __fs_method_vfs_transfs_fget);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "transfs_fget", __fs_method_vfs_transfs_fget);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "do_trans_fget", __fs_method_vfs_do_trans_fget);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "do_trans_fget", __fs_method_vfs_do_trans_fget);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "transfs_fput", __fs_method_vfs_transfs_fput);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "transfs_fput", __fs_method_vfs_transfs_fput);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "do_trans_fput", __fs_method_vfs_do_trans_fput);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "do_trans_fput", __fs_method_vfs_do_trans_fput);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvcall", "fscall", "vfs", "read_mounts", __fs_method_vfs_read_mounts);
	hm_debug("method is %s_%s_%s_%s, callnum is %u\n", "actvhdlr", "fshandler", "vfs", "read_mounts", __fs_method_vfs_read_mounts);
	hm_info("%s_%s, max method num: %d\n", "fs", "method", __fs_method_MAX);
}

#endif
#endif
