# Copyright (C) Huawei Technologies Co., Ltd. 2021. All rights reserved.
# Description: Configure file for hmcmakeng iTrustee toolchain
# Author: Huawei OS Kernel Lab
# Create: Mon Aug 02 15:08:28 2021

# AUTO-GENERATED by aarch64-euler-elf-hm-cmake-toolchain-cross

# Key to select Hongmeng Platform
set(CMAKE_SYSTEM_NAME Hongmeng)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

# Hack to make sub cmake inherit HMNATIVESDKPATH settings
# HMNATIVESDKPATH is a key interface between toolchain file and yocto.
# By setting HMNATIVESDKPATH and CMAKE_SYSROOT, toolchain file
# find everything from yocto recipes-sysroot and SDK.
# If HMNATIVESDKPATH is not set, user should set local toolchain
# by setting HMTOOLCHAIN_GCC_BINDIR and HMTOOLCHAIN_CLANG_BINDIR.
if(NOT HMNATIVESDKPATH)
    set(HMNATIVESDKPATH "$ENV{__HMNATIVESDKPATH_ENV}")
endif()
if(HMNATIVESDKPATH)
    set(ENV{__HMNATIVESDKPATH_ENV} ${HMNATIVESDKPATH})
endif()

message(VERBOSE "Use hongmeng cross-compiling itrustee toolchain 'aarch64-euler-elf-'.")

# Set HMTOOLCHAIN_CLANG_BINDIR:
# If user provides a -DHMTOOLCHAIN_CLANG_BINDIR in cmdline, obey this setting
# then try ${HMNATIVESDKPATH}/usr/bin/ (if HMNATIVESDKPATH is not provided, it is /usr/bin)
# then try PATH environment variable

## Part 1: Make sub cmake inherit HMTOOLCHAIN_CLANG_BINDIR setting
if (NOT HMTOOLCHAIN_CLANG_BINDIR)
    set(HMTOOLCHAIN_CLANG_BINDIR "$ENV{__HMTOOLCHAIN_CLANG_BINDIR}")
endif()

## Part 2: Compute HMTOOLCHAIN_CLANG_BINDIR
if (NOT HMTOOLCHAIN_CLANG_BINDIR)
    if (EXISTS "/usr/local/bin/clang")
        # First: try a hard coded path for yocto building
        set(HMTOOLCHAIN_CLANG_BINDIR "/usr/local/bin")
    elseif(EXISTS "${HMNATIVESDKPATH}/usr/bin/clang")
        # Then: try HMNATIVESDKPATH
        set(HMTOOLCHAIN_CLANG_BINDIR "${HMNATIVESDKPATH}/usr/bin")
    else()
        # Serch clang from PATH
        find_program(HMTOOLCHAIN_CLANG_BIN "clang")
        if (NOT HMTOOLCHAIN_CLANG_BIN)
            message(FATAL_ERROR "Unable to locate clang. Use HMTOOLCHAIN_CLANG_BINDIR to set one")
        endif()
        unset(HMTOOLCHAIN_CLANG_BIN CACHE)
        get_filename_component(HMTOOLCHAIN_CLANG_BINDIR "${HMTOOLCHAIN_CLANG_BIN}" DIRECTORY)
    endif()
endif()

## Part 3: Set __HMTOOLCHAIN_CLANG_BINDIR env variable to help sub cmakes
if (HMTOOLCHAIN_CLANG_BINDIR)
    set(ENV{__HMTOOLCHAIN_CLANG_BINDIR} ${HMTOOLCHAIN_CLANG_BINDIR})
endif()

# Same to HMTOOLCHAIN_CLANG_BINDIR, set HMTOOLCHAIN_GCC_BINDIR
## Part 1: Make sub cmake inherit HMTOOLCHAIN_GCC_BINDIR setting
if (NOT HMTOOLCHAIN_GCC_BINDIR)
    set(HMTOOLCHAIN_GCC_BINDIR "$ENV{__HMTOOLCHAIN_GCC_BINDIR}")
endif()

## Part 2: Compute HMTOOLCHAIN_GCC_BINDIR
if (NOT HMTOOLCHAIN_GCC_BINDIR)
    # Different from clang, gcc has prefix
    if (EXISTS "/aarch64-euler-elf-gcc")
        # First: try a hard coded path for yocto building
        set(HMTOOLCHAIN_GCC_BINDIR "")
    elseif(EXISTS "${HMNATIVESDKPATH}/usr/bin/aarch64-euler-elf-gcc")
        # Then: try HMNATIVESDKPATH
        set(HMTOOLCHAIN_GCC_BINDIR "${HMNATIVESDKPATH}/usr/bin")
    else()
        # Serch gcc from PATH
        find_program(HMTOOLCHAIN_GCC_BIN "aarch64-euler-elf-gcc")
        if (NOT HMTOOLCHAIN_GCC_BIN)
            message(FATAL_ERROR "Unable to locate aarch64-euler-elf-gcc. Use HMTOOLCHAIN_GCC_BINDIR to set one")
        endif()
        unset(HMTOOLCHAIN_GCC_BIN CACHE)
        get_filename_component(HMTOOLCHAIN_GCC_BINDIR "${HMTOOLCHAIN_GCC_BIN}" DIRECTORY)
    endif()
endif()

## Part 3: Set __HMTOOLCHAIN_GCC_BINDIR env variable to help sub cmakes
if (HMTOOLCHAIN_GCC_BINDIR)
    set(ENV{__HMTOOLCHAIN_GCC_BINDIR} ${HMTOOLCHAIN_GCC_BINDIR})
endif()

# -DHMTOOLCHAIN_CLANG_BINDIR:PATH=${HMGLOBALCONF_TOOLCHAIN_CLANG_BINDIR}
# But :PATH=xxx removes ending '/'.
set(CMAKE_C_COMPILER    ${HMTOOLCHAIN_CLANG_BINDIR}/clang)
set(CMAKE_CXX_COMPILER  ${HMTOOLCHAIN_CLANG_BINDIR}/clang++)
set(CMAKE_ASM_COMPILER  ${HMTOOLCHAIN_CLANG_BINDIR}/clang)
set(CMAKE_AR            ${HMTOOLCHAIN_CLANG_BINDIR}/llvm-ar)

# Still need GNU toolchain for libgcc. See Hongmeng-iTrustee-C.cmake
# This is iTrustee-C specific setting
set(CMAKE_GNU_C_COMPILER    ${HMTOOLCHAIN_GCC_BINDIR}/aarch64-euler-elf-gcc)
set(CMAKE_GNU_CXX_COMPILER  ${HMTOOLCHAIN_GCC_BINDIR}/aarch64-euler-elf-g++)
set(CMAKE_GNU_ASM_COMPILER  ${HMTOOLCHAIN_GCC_BINDIR}/aarch64-euler-elf-gcc)
set(CMAKE_GNU_AR            ${HMTOOLCHAIN_GCC_BINDIR}/aarch64-euler-elf-ar)

if (HMNATIVESDKPATH)
    set(CMAKE_FIND_ROOT_PATH ${HMNATIVESDKPATH})
    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

    # toolchain will be loaded multiple times, for all states we should not simply append
    # to them
    if (NOT ("${HMNATIVESDKPATH}/usr/share/cmake/Modules" IN_LIST CMAKE_MODULE_PATH))
        list(APPEND CMAKE_MODULE_PATH "${HMNATIVESDKPATH}/usr/share/cmake/Modules")
    endif()
    if (NOT ("${CMAKE_SYSROOT}/usr/share/cmake/Modules" IN_LIST CMAKE_MODULE_PATH))
        # Set target dir so find module installed into target can be found
        list(APPEND CMAKE_MODULE_PATH "${CMAKE_SYSROOT}/usr/share/cmake/Modules")
    endif()
endif()

set(CMAKE_C_COMPILER_TARGET aarch64-euler-elf)
set(CMAKE_ASM_COMPILER_TARGET aarch64-euler-elf)
set(CMAKE_CXX_COMPILER_TARGET aarch64-euler-elf)

# Hacky but not so hacky because cmake itself also use this trick to skip compiler
# auto detection. See CMakeCCompiler.cmake.in.
# By setting this to 1, we skip compiler auto detection (it should return Clang),
# and create a hongmeng specific compiler id "iTrustee". In Hongmeng-C-iTrustee
# Let's define hongmeng toolchain interface.
set(CMAKE_C_COMPILER_ID_RUN 1)
set(CMAKE_C_COMPILER_ID "iTrustee")
set(CMAKE_C_COMPILER_FRONTEND_VARIANT "GNU")
set(CMAKE_C_PLATFORM_ID "")

set(CMAKE_ASM_COMPILER_ID "iTrustee")

# detect clang version
execute_process(
    COMMAND ${CMAKE_C_COMPILER} --version
    OUTPUT_VARIABLE ITRUSTEE_COMPILER_ID_OUTPUT
    ERROR_VARIABLE  ITRUSTEE_COMPILER_ID_OUTPUT
    RESULT_VARIABLE ITRUSTEE_COMPILER_ID_RESULT
)

if (ITRUSTEE_COMPILER_ID_RESULT)
    message(FATAL_ERROR "Failed to execute ${CMAKE_C_COMPILER} --version")
else()
    string(REGEX REPLACE "^clang version ([^ ]*) .*$" "\\1" versionstring   "${c}")
endif()

# Detect clang version
if (NOT DEFINED CMAKE_C_COMPILER_VERSION)
    execute_process(
        COMMAND ${CMAKE_C_COMPILER} --version
        OUTPUT_VARIABLE ITRUSTEE_COMPILER_ID_OUTPUT
        ERROR_VARIABLE  ITRUSTEE_COMPILER_ID_ERROR
        RESULT_VARIABLE ITRUSTEE_COMPILER_ID_RESULT
    )

    if (ITRUSTEE_COMPILER_ID_RESULT)
        message(FATAL_ERROR "Failed to execute ${CMAKE_C_COMPILER} --version")
    else()
        string(REGEX REPLACE "\r?\n" ";" ITRUSTEE_COMPILER_ID_OUTPUT_TEXT "${ITRUSTEE_COMPILER_ID_OUTPUT}")
        foreach(line IN LISTS ITRUSTEE_COMPILER_ID_OUTPUT_TEXT)
            if (line MATCHES "^clang version .*")
                string(REGEX REPLACE "^clang version ([^ ]*) .*$" "\\1" ITRUSTEE_CLANG_VERSION "${line}")
            endif()
        endforeach()
    endif()

    set(CMAKE_C_COMPILER_VERSION    "${ITRUSTEE_CLANG_VERSION}")
endif()

if (NOT DEFINED CMAKE_ASM_COMPILER_VERSION)
    set(CMAKE_ASM_COMPILER_VERSION  "${CMAKE_C_COMPILER_VERSION}")
endif()

# Force setting CMAKE_C_STANDARD_COMPUTED_DEFAULT to 11, no need to compute
set(CMAKE_C_STANDARD_COMPUTED_DEFAULT "11")

# Only set once becuase toolchain file would be loaded multiple times
if (NOT ITRUSTEE_CFLAGS_SET)
    set(ITRUSTEE_CFLAGS_SET 1)

    # Since this is iTrustee, -march and -mtune are known
    if (CMAKE_C_COMPILER_TARGET MATCHES "aarch64")
        string(APPEND CMAKE_C_FLAGS     " -march=armv8-a")
        string(APPEND CMAKE_C_FLAGS     " -mtune=cortex-a53")
        string(APPEND CMAKE_ASM_FLAGS   " -march=armv8-a")
        string(APPEND CMAKE_ASM_FLAGS   " -mtune=cortex-a53")
    endif()

    if ((CMAKE_C_COMPILER_TARGET MATCHES "aarch64_be") OR (CMAKE_C_COMPILER_TARGET MATCHES "armeb"))
        string(APPEND CMAKE_C_FLAGS     " -mbig-endian")
        string(APPEND CMAKE_ASM_FLAGS   " -mbig-endian")
    else()
        string(APPEND CMAKE_C_FLAGS     " -mlittle-endian")
        string(APPEND CMAKE_ASM_FLAGS   " -mlittle-endian")
    endif()
endif()

# vim: ts=4:sw=4:expandtab
